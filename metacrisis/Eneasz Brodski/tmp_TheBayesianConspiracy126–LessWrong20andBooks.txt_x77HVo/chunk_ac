Well, they look more like beans than babies to us, or to me anyway.
Well, no, you make them little bears or something. Anyway.
We have gummy bears.
Okay, well, ours are.
They actually shape the exact terminology of the sweets.
I really want to go to Britain and just eat jelly embryos.
Oh, God. Yeah, sometimes this is horrible. Sometimes our housemates just like, I think Daniel Phylan, who's from Australia, just particularly much.
Well, he just asserts that something is completely normal in Australia.
What I cared about in Australia, I would just believe it, regardless of what it is.
Is there an Australian thing that started out that way that's like, I didn't come here to wrestle spiders or something?
And have sex with snakes? I can't quite recall how it ends.
All right, I'm going to go with jelly beans.
So you're like, what is the weight of a jelly bean?
And if you're like me, who has not done much cooking for myself, I don't really know how much things weigh.
Or I certainly didn't when I was reading the book.
And you're like, is it 20 grams? Is it two grams? Is it 200 grams? Is it 0.2 grams?
I don't know the right order of magnitude for this sort of thing.
And then if I give you the first jelly bean and you're like, this is 15 grams, you're like, huh,
I think I have a pretty good guess of what the next one might be.
I've zoomed in on roughly what order of magnitude, I guess.
And maybe you gave me a weird one that was like a broken piece of it and you're a bit wrong or something.
But I think often the first data point can orient to just what order of magnitude or ontology are we even talking about.
And so I have some sense that like, like I've not really lived in any other like physical universes
and I don't really have much intuition about what they could exist, what could exist.
But if I had thought about what sort of physical universes could exist or something and like what physics,
what the space of physics is, and then you just show me a thing falling,
I can imagine going, oh, we're in that kind of universe.
The sort where the things are attracted to each other with this sort of rough like,
I can see the Pfizer thing the water droplet fell to.
I can see the size of the water droplet.
I can see the way it like bent over one frame, which tells me a bit about the fluid mechanics.
I can see, you know, I can see that there is like things of a certain level.
I can see what level of organization we're on with like how many levels of atoms or something you're going on.
And so I don't feel confident either way about how surprised I could feel for the first time watching the physics of universe player
and therefore how much I could update on it.
So I don't have a strong opinion, but I don't feel confident that it's not two or three frames.
That's a damn good point.
If you don't even know what sort of universe you're in, those initial frames are going to give you a huge amount of info.
Yeah, and I just, I just don't know how much because I don't know.
I didn't have a prior coming to this universe very much.
Yeah, I don't know how many self consistent theories of physics they are that are like close by two hours.
Like, it's possible that they're just undead many and it's like, well, if you actually write down like, of course they infinitely many,
like actually like try to like order them by complexity and you're like, well, I don't know, like they're only like there's a bunch of ones,
like the only self consistent universes that like can support life actually have like one of these like maybe 100,000 options.
And just like this one really looks like it's in it's one of these.
All right, well, shall we move on?
I come through.
Oh, I actually I did want to add one thing in about predict it. Sorry, I just didn't want to give people bad investing advice.
You should Google a couple of posts unless wrong. I think it was even one of the last year about predict it because the main thing that goes wrong is you can often look at a predicted prediction and think that's wrong.
But the issue is there's a lot of transaction fees such that if you were to try and make money on the on the very small margins or something, they would actually charge you more money for trying to make the transaction such that it would not be worth it.
So there's some difficulties there. So don't just if you see a prediction that's a little bit off, don't immediately expect you can make money.
I would look into it a bit more.
The one that the top one here under US presidential election is that 95% 95% is the has the Democratic Party winning that the presidential seat.
I'm imagining that there's more than a nickel on the dollar for transaction fees unless you're probably betting a lot right.
So the problem is you can't bet a lot. That's the thing that makes predicted legal is that the cap the bets are capped per person that I think something like 500 something between $505,000 of sticks.
To me, that's a lot.
Yeah, I just, oh yeah, you couldn't bet, you know, several figures of income on it. But yeah, I get you're saying is that per bet or like per month.
I think it's like your total stake you're allowed to have in the market, like how much money you're allowed to have tied up.
Oh, okay. Yeah. And if you're like making five, 6% margin, that's not nearly enough to live on.
Yeah.
All right, that was my point about predicted three talk about sequences for another 50 minutes and then wrap up the podcast.
No, that's great.
Thanks for clarifying that actually that's good information.
And then Occam's easy.
Are we ready for Occam's easy.
Yeah, let's do it.
Go ahead.
Yeah, no, you did.
Okay, well, I was going to say, just a real quick recap of Occam's razor. I'm assuming everyone already knows what it is, but for anyone who may have missed it, it is the the heuristic that the simplest explanation is usually the correct one.
And the one that you should go with it, I believe, formerly it stated something like one should not multiply entities unnecessarily or something.
Okay. And in the post, a laser says that the more complex explanation is the more evidence you need just to find it in belief space is kind of his version of that.
And he said that Occam's racers often phrased as the simplest explanation that fits the facts is the definition Occam's razor.
And Robert Heinlein replied that the simplest explanation is the lady down the street is a which she did it.
Which on the face of it, you know, seems to be the simplest maybe, but it hides a lot of complexity within the sentence that we just don't think about, because there's a lot of labels in that sentence that have stored complexity in them.
He pointed it out that we could shorten the entire sentence just to a sequence of a few letters and say, look, it's even shorter. Does that reduce the complexity?
And no, it doesn't because the audience already has to know what those few letters stand for.
And in similar way, like which itself is a label for a lot of extraordinary assertions.
So just because we know about a concept that doesn't mean it's actually simple. And in fact, the human brain is the most complex artifact in the known universe.
So positing a human brain as an explanation for something already has a lot of complexity built into the answer.
Yeah, I've definitely like, I was confused about that post for a while. And I made some confused questions on this wrong, like three or four years about it.
Because I think the post really is two very different things. And I totally got them mixed up at some point, where the two things the first thing that it asserts is that many concepts that humans think of as simple aren't really simple.
And I think that's a point that's actually pretty hard to make. That requires a bunch more additional justification that totally the post doesn't do.
And then it makes a second point that's completely separate from that, which is that an explanation needs to actually reduce the complexity of the remaining data,
which is something like, if you want to give me an explanation, after I have like, you've given me the like, like the ladies down the street is a which she did it.
The thing that he's totally separate point he's making is that like, that doesn't tell me that the sequence doesn't come out like a b c d e.
I like still have to say that because actually like, having heard the first half of the sentence of like the lady down the street did it.
Like, doesn't actually help me at all predicting the sequence. It gives me like zero Bayesian evidence about the sequence.
Yeah, you're right. This should really be two posts.
And I think the first one is actually kind of hard, because there's this really real objection to to the to the flavor of Occam's razor that Eleazar is proposing here.
That like usually goes technically under the name Salomon of induction, where you have this this giant free variable.
That's the choice of universal Turing machine.
And he talks a bit in a post about like, well, you can choose universal Turing machine however he wants.
But I've actually found it like a pretty hard thing pretty hard to wrap your mind around.
Because just like, indeed, just like, there's nothing in the laws of physics and nothing in the laws of reasoning that we know of that means that we can't use like,
witches as fundamental units in our programming language.
Like, I can totally write your programming language that like, I choose as my universal Turing machine that has like, simulate a like, universe with a single witch in it and an empty wide room.
That's like a print like it's a primitive at the same level like let's say instead of like, we have Python, and we have Python plus and Python plus is all of Python, except it has to which command, which allows me to type in which open
parentheses sentence. And then what the which command outputs is a string that is whatever the which response after I simulate her in a like, large like infinitely large wide universe with a booming voice speaking down the string that I input into that voice into
that void. And that's like a language that is like, I can use that as my universal Turing machine. And now suddenly which is a fundamental concept. And now we need to argue for some reason that that is an elegant that that is a wrong that that sounds like a really
really weird choice of fundamental entity in my programming language. But there's all arguments that have to be additionally made.
I wait, I don't know, I don't think I could agree with that because I mean maybe he should have made a post about what a Turing machine is but like a Turing machine is the simplest possible way that information can be processed in concept, like you would have to have
some way to simulate a which first and to do that you would need something equivalent of a Turing machine because information would have to be processed to simulate anyone right
So the like a Turing like, when you think of universal Turing machines, usually what like the key question is what is the ontology of the thing that you are described like of the of the language you're writing in.
I do really think it's very useful to just think of programming languages Turing machines like that's like, I find that much simpler to think about as opposed to weird thing that Turing wrote down which is like this weird, like robot that like slides on a tape to the left and right.
And we know that every universal Turing machine can be modeled as a simple programming language, and that every programming language can be modeled as a universal Turing machine with an appropriate translator at the beginning of it.
But a Turing machine at its simplest is just a way of storing information and then doing things to that operation, doing operations to that information to change it into a different type of information.
You can't really have any simpler form of information processing right.
I think that seems right.
I think, by the way, I am totally confused about it. I was like, oh, I'll come straight up. I notice I feel really philosophically confused about it. And then we talked about it for five minutes and I feel basically as bad.
Certainly, I think with a Turing machine, you can in principle run, I think, the very costly computation that Ali was describing where you could, with enough space, you could simulate or emulate or compute what would happen.
You'd like specify the physics and you specify that there is like a witch in this void, and then you like output some translation from whatever the like physical vibrations are in the universe to a set of ones and zeros and have that be a part of the output of the Turing machine.
Oh, absolutely. I think for me that the idea of having like a witch function and then calling that simple like the meat of the witch function, you know, you go into define it, like all of that's going to be enormously complex, right?
And so I think.
The problem is, in that moment, you're begging the question. When you say that it is enormously complex, what concept of complexity are you using to assert that?
Oh, nice. Good point.
Well, there's a complexity that is grounded on the idea that you already have some programming language in mind that measures the complexity of that hypothesis.
But the whole point of someone of induction is that, well, you need to first choose a programming language in which you measure complexity.
And so there's a separate thing of just like elegance where, well, like it's kind of like humans have some shared intuitions of elegance and that points towards some natural choice of universal Turing machine that makes stuff like, well, we just going to like have a witch function.
Sounds really dumb. But I think now we need to argue from that intuition as opposed to arguing from some kind of mathematical truth.
I see what you're saying. Yeah, I guess what I meant is that the witch function wouldn't be brief in what it did.
I mean, so I don't know if that's the exact same thing as not complex, but I can't imagine the model of this, of the witch function being like, you know what I'm saying?
It's just a brief. You know, it's not going to be like adding two numbers or rolling a die. I guess it depends on what the witch function does.
If all the witch function does is, yeah, well, within what bounds, right?
Does it turn random villagers into newts? Or is it just lighter than a duck? If it was just ways less than a duck, then that witch would be super easy, right?
So I do have a hard time imagining, and perhaps this is like the root of where my intuition comes from that some things are simpler.
I have a hard time imagining creating a programming language where it was simpler to simulate a witch in the universe in chat with her and get her output versus, you know, writing some if statements.
I feel like both in terms of like the programming language and the like hardware, like the actual amount of hardware I would need to compute one of them versus the other.
Kind of. I think this is, I actually think modern neural nets provide like a really useful intuition pump here, and added like more people are familiar with them.
Like neural nets are kind of this archetypical example of in the space of like neural net programming languages, it's actually kind of hard to end up with one that's just like really good at reliably adding numbers.
It's like, I get what you're saying, but like the the biological neural nets that we were familiar with before DeepMind were human brains, which as stated, were one of the most complex artifacts in existence.
And like the the computer neural nets we have nowadays are not simple either they they take, you know, massive.
Yes, I don't even know the correct order of number to say how many bits they use up, and they are not not understandable by us is due to how complex they are.
They're simply much more, much more complex than the laws of physics, for example, which can be encoded in surprisingly few bits.
Well, no, like that's you did the statement can be encoded and X number of bits does not have any mathematical meaning.
If you don't specify a programming language in which you're counting the number of bits.
So you like you can't say that the laws of the universe are generally encodable in such a small number of bits, you need to say generally encodable in a small number of bits in this programming language.
Well, I think that's why he brings up the universal Turing machine because that one has simply, you know, bits of zero and one on off that can be manipulated into, you know,
But there's an infinite, there's an infinite number of universal Turing machines, all of which will use different ways of like, like we'll have different description lines.
And the core insight is that you can write a translator between any of them.
You can write a translator between any programming language that is Turing complete and any other one.
And a Turing complete programming language will have an associated universal Turing machine.
But of course, the space here is infinitely large.
There isn't just like one universal Turing machine that is handed down to you.
There's an infinite class and Python, which has to which function is an element of the unit class of universal Turing machines.
It's just like you can grab it in a puzzle Turing machine and there's the one that has to which function.
I guess I don't get.
I feel like I feel somewhat compelled by the idea that in general, it is not clear to me which Turing machines will be simple to compute in my universe.
I do feel like my experience of my universe.
I don't know that yours is that, you know, a couple of statements and a couple of loops can be run with far less physical matter.
That's a really interesting inference to make.
But it also has a really weird amount of circularity where like you're trying to use a monofinduction to determine what the physical rules of your universe are.
And then you're trying to use your model of the physical rules of the universe in which you're in in order to determine which choice of universal Turing machine is the right one for your monofinduction.
And you're like, well, is that valid or not?
My current answer is I don't know.
I feel confused about this.
It does get pretty circular.
Yeah, it's interesting.
It reminds me of Abram Dempsey's got a great post on Lesserung but I think came out this year called an orthodox case against utility functions where he does make a case that a lot of the way we standardly think about utility functions and so on is from the perspective of the universe.
Like you have all of these different like laws of physics and arrangements of matter and we have a function from them to states of utility.
And he offers a quite different model where which is from the point of view of somewhere or someone who is like part of the universe where they don't really understand the rules and they're like gradually splitting up their world model into different high level chunks.
And it, I don't fully grok it and potentially I will rock it better than I do.
But it's, it's something that I think tends tries to grapple with this question of some of the circularity of trying to say, I didn't come into the universe knowing which universe I was in.
And therefore I didn't know which sorts of program languages were simple to run in this universe.
And as I have explored it a bit more I have come to that sort of conclusion and I have fed that back into my expectation of which further hypotheses are simple versus complex.
Yeah, the other thing that I think is really important to point out epistemologically about the Occam's razor post is the fact that like I actually am not that sold on the complexity prior on its own.
Like the obvious other prior that you might want to have is the speed prior.
Like when you have like when you run a Turing machine or just a program, they are like two major facts about the program.
Number one is like how long it is, and number two is it how much compute resources does it take.
And in a bunch of places in the sequences, Eleazar basically asserts that well just the length of the program matters.
But he doesn't actually argue for it very well.
I think it's totally reasonable to be like well I want to buy programs.
I like assign higher probability to the programs that like both give me the correct answer and give me the correct answer reasonably fast.
And actually I just have a speed speed penalty for any program that takes like aeons upon aeons, 10 to the power of 10 to the power of up arrow, up arrow, up arrow, three years to give me the right answer.
The key point was Adam's deep mind.
Wouldn't it be basically a the length of the of the program is a function. Well, the other way around the speed is the function of the length because in at least in a universal Turing machine, you can only execute one instruction at a time.
So the more instructions you have the longer it'll take to run.
So are you familiar with the busy beaver number.
Oh, it's been a long time, but vaguely yes.
So busy beaver is the number that the length amount of steps that a universal Turing machine of length n can take at most.
So the longest running machine that terminates of a given complexity class.
And those are really, really, really, really big.
They're usually like in when people talk about fast growing sequences to busy beaver numbers among them.
Well, like for like, I don't know, I know that the busy that I think we know busy beaver three but we like busy beaver four no longer fits on like our hard drives and busy beaver five is like much, much larger than could ever be represented in the existing known universe.
I might be wrong here by many orders of magnitude is very easy to be often.
But it'll be why it's called busy beaver.
I don't actually know, I think it's just kind of, I just imagine it as like, I don't know.
I just have my head cannon, which is just that it's like, I associated with a small beaver that does a lot of work for a really long time.
And it has a somewhat cartoony aesthetic and it gets really exhausted after doing this for Aeons and Aeons.
But I do not know if it was the head cannon that people had when naming that.
Yeah, it goes for, I think it there is a bunch of different ways you can set up the problem.
But for the one where you have for one of them with a two symbol, it's a two state Turing machine.
It can go for six for three state, it can go to 21 for four state and give 107 for five state and go for 47 million 176,870 for a six state.
And it goes for 7.4 times 10 to the power of 36,534.
And the seven state goes, the seven state goes for 10 to the 10 to the 10 to the 10 to the 18,705,353.
Can I say a random silly thing about the speed prayer?
Daniel Phylon, who is surprisingly now a housemaid of mine.
Well, I guess you maybe shouldn't be surprised. It's only of the last month.
When I was at Oxford during my undergrad in my first year, he came and he was looking for a place to stay and I gave him a space in my room for free for like a month while he was visiting FHI.
And he had a poster created and mailed him in one of those tubes for a presentation because he'd just done some work on the speed prayer.
And I think it arrived a couple months ago.
