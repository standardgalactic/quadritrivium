and just to increase the size there.
So import data frames.
Data frames is a package.
That's the name of a package.
And I'm using import there to import, but you can also see down here
I'm importing get fly, but instead of import, I use using.
So there's a difference between those two.
There are a few differences.
One of the main differences are that if I want to use
some of the functions inside of data frames,
I have to use the data frames, the namespace,
the full namespace word there.
So data frames dot and then a function that lives inside of there.
Using for most of them, you don't have to do that.
You just use the function as is.
If you're familiar with Python, that would be importing NumPy as NP.
And then using NP dot random, for instance,
whereas if you imported from NumPy import random,
then you can just use random directly.
The reason why I'm going to do this here is I want to show you,
if I show you a function, I want you to know where it comes from.
Many tutorials, all these packages are just used to the using keyword.
And then functions are used, but you're not really sure where they come from.
So I'm going to restrict myself to import here, which is not the norm.
But just to show you if I use a function from, for instance,
from statspace, that you know that that function comes from statspace.
So where did I get all of these extra packages from?
Let's go back to the REPL.
It's going to delete there.
I'm going to hit the right square bracket.
And that brings me into the package management system.
And all I have to do is say add.
And then I could say data frames.
And if I hit enter now, the data frames package is going to be installed.
That's a permanent installation unless I remove it.
So it's always there.
But the first time that you start up the IDE.
So just to say to get out of that package, I just had to hit backspace and I'm back.
Before I forget, there's also the question mark that brings you into the help system.
If I were to look for the function called sum.
That's all.
Look at that.
I just get all that information.
I could also go to the documentation, of course, and type in sum.
And I'm going to get this information as well.
So the help system is always there for you.
Back to these packages.
You install them there.
But you have to import it every time you start the IDE or start the Julia kernel.
Again, you have to import or use the keyword using with ease.
And then they're going to be pre-compiled and they take some time.
So every time you import these packages, it is going to take time.
There's no way to rush this situation.
It's not like importing numpy as NP and it's almost instantaneous.
This has to be compiled.
So you can see here at the bottom, pre-compiling data frames.
And you see this little gear icon here.
It is doing the pre-compiling and you have to wait for that.
If you want the speed, you've got to wait for the language to compile.
And there we go.
It didn't take that long.
Let's also import distributions.
So the distribution package is going to give me access to a lot of discrete and continuous distributions.
GATFLY is a package for plotting based on the grammar of graphics.
If you use ggplot2 before, it should not be too difficult for you to pick up GATFLY.
So Render is very beautiful plots.
And certainly go to the GATFLY website and have a look around.
It is this phenomenal, the type of plots that you can create.
And of course, we're going to create the plots in this tutorial.
So let's do GATFLY.
It's going to take a little bit longer to pre-compile.
It's a large package and it's going to take a bit of time.
I'll continue talking about the hypothesis tests that's going to give us access
to a lot of statistical tests for inference.
So we're going to get our t tests, f tests, etc.
That is going to be available for us.
Not all inferential statistic tests are available.
Have a look at their website.
For instance, as I mentioned in an introduction, we are going to hand code
or hand write some code to do chi-square tests for independence at the end of this tutorial.
StatsBase is also going to give me access to a bunch of statistical functions
which makes life very easy.
It's a very useful package to have.
So let's just go back to hypothesis tests.
And you can see I'm doing for GATFLY and for hypothesis tests I'm using using.
But for statsBase, I'm using import.
It's just that I want to show you where these, as I mentioned, where these functions come from.
So I'm going to do import, by the way, to execute these lines of code.
I'm just at the end.
I can be anywhere inside that line and I'm holding down shift and I'm hitting enter.
Shift and enter or shift and return.
And that is going to complete that for me.
Let's do statistics.
Now, statistics and random, they come with Julia.
They build into Julia.
But if you want to use the functions inside of those two packages,
you have to import them or use the using statement.
CSV.
Of course, it's a package that's going to help us read CSV files.
If you work with spreadsheet software such as the ubiquitous Microsoft Excel,
never save your files.
If you're going to work with data, don't save your files as Excel spreadsheets.
Save them as CSV files, comma-separated value files.
Makes it much easier to work with those kind of files that have stripped away all the fancy things
that have been added to the rendering of your cells inside of Microsoft Excel
or some other spreadsheet software.
All you want is the actual data, not its representation as a percentage.
If it was captured as a fraction, you want those values as a fraction.
And then lastly, or second from last, we're going to use query.
That's a package to help us query language.
And that is a very powerful, it's not only for the data frames package.
I did mention the data frames package right in the beginning.
That's going to allow us to work with the data that we've imported.
But the query language on top of that is almost like a structured query language.
It allows us to write queries to interrogate the data.
And in the end, if we're going to do a chi-square test for independence,
we've got to have some contingency tables and the frequency tables or FREQ tables.
It's going to allow us just to do those counts along contingency tables.
So let's import that.
So what I'm going to do here next is we're just going to make use of this journal article that you can see here.
The link will be down below.
You can read that link.
The article itself used an organism and tablet form and randomized some participants
and had a look at the effect that would have on the cholesterol and specifically HDL cholesterol.
They've got beautiful tables in that journal paper.
And we're just going to use the summary that they go over in those tables
and just generate some data on our own.
That's one of the beauties of a computer language.
Of course, you can generate your own data.
So this would not refer to real-life data.
This is data that we're going to simulate based on the summary statistics in those tables.
So the first function that we're going to use you see here is random.seed.
Open close parentheses because the seed is a function
and I'm just passing in some integer that I decided on 12.
You see the little exclamation mark there?
That's the bang symbol.
So random.seed bang.
And I'll tell you a little bit more about the bang symbol a bit later.
To seed the pseudo-random number generator means all these random values that we are going to generate
will be exactly the same if I run this code again.
If you run this code, you're going to get exactly the same pseudo-random numbers as well.
If we don't do that, of course, every time you run this,
you're going to get different random numbers.
So the first set of random numbers, let me just execute that.
Shift-Enter, Shift-Return.
And now if I run these in order, of course, if I go back and rerun some of these,
it'll be different numbers.
But if I run these all in order, we should all get the same random values.
So the first random function we're going to deal with is a built-in Julia function, RAND.
And it's going to take some arguments and return one or more random values.
The first argument here is these oppositional, so you've got to put them in order,
is what to choose from.
And this is a unit range, 30 colon 65.
Because I don't put a default step size in the middle, so I could say 30 colon 2 colon 65.
That's going to go up in steps of 2.
If I don't put any step size, it's just going to use 1 as a step size.
So from 30 to 65, that is a unit range.
It's going to select from those values.
How do I know that that's a unit range?
Well, let's go to the REPL here.
There is a type of function.
And if we were to say 30 to 65, it'll tell us what Julia sees that as.
It sees that as a unit range of 64-bit integers, just as we suspected.
Back here to the comma, the next positional argument would be 46.
I want 46 values back from this interval of 30 to 65.
I want 46 values back.
The random is going to give us a uniform distribution with replacement.
So if the age 35 was chosen once, it goes back into the pile and it can be chosen again.
So just a uniform random distribution.
Shift-Enter.
And there we see we have a vector of 64-bit integers with 46 elements.
If I twirl down on it, you can see a list of them there.
46.
So in this paper, they had 46 participants, 23 in each arm, taking either the drug itself,
which as I say, we're just some organisms, or placebo.
And we want 46 of them.
And we're just going to randomize from a uniform random distribution.
Uniform distribution, we're just going to take 46 values.
And we're storing that, assigning that.
Remember, equal sign is an assignment operator.
It assigns what is on the right side of it to whatever is on the left.
And on the left, we've generated a computer variable name age,
creating a space in our memory where this object on the right-hand side is stored.
I'm going to use snake case for my computer variable names.
There you can see snake case.
In other words, it's a word I came up with, computer variable,
but the words have got these underscores in between them.
It's commonly seen in Julia, although you can use, I suppose, whatever convention you want.
Camel case, it's really up to you.
The next one I'm going to generate is gender.
And here I'm going to use the sample function from the stats-based package.
And that's why I used importing, so I have to now write stats-based.sample.
So my first argument is going to be an array.
And it is an array because of the square brackets.
An array is a list of elements.
And the two elements I'm going to give it is female and male as strings.
And in Julia, strings go inside of double quotation marks.
You can also use single quotes, but that's only with a single letter.
And then it's not a string.
It's actually a character type, not a string type.
