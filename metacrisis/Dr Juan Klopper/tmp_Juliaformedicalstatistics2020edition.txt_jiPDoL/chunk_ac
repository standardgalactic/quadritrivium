So there we go.
Now in this paper, there was just the binary allocation of gender.
So there was only female or male.
Then in the paper, 60% of participants were female and only 40% were male.
So I'm going to add some weights to this random sampling.
So stats-based.weights is my next function there, weights.
And again, I'm passing an array of 0.6 and 0.4.
Of course, that's going to sum to 1.
And I want 46 of those.
And it's a very expressive language because that's almost like an English sentence that I've written there.
Sample for me from this sample space containing two elements, female and male.
Sample with weights.
So that's 60% of female and 40% are male.
Or at every turn, that's that likelihood of being selected.
There's a 60% likelihood of choosing female and a 40% likelihood of choosing male.
And I want 46 of them as well.
So shift-inter, shift-return.
And we see my vector here of strings this time, not 64, but integers, but strings.
So let's tool that down.
We say we see male, female, female, female, male.
And with only 46, of course, it's not going to be completely a 60-40 split.
46 is a small number, but it's going to be in that order.
Now, next up, I'm going to create the group, this computer variable called group.
And now I'm going to use the repeat function.
So for the repeat function, I'm going to pass again something to choose from.
In other words, it's got to be an array, but this array only has one element.
And I want it repeated 23 times.
And you can guess at what's going to happen here.
I'm going to have a vector of strings with 23 elements.
And there we go, placebo, placebo, placebo, placebo.
So what I'm trying to simulate here is I'm just going to put the 46 patients or participants in.
They took the placebo, and then I'm going to add 23 of them.
They took the active ingredient.
So how do I add to the end of an already existing vector or array?
So you'll see it's called a vector here in atom, but if you just ran it in the ripple here,
it'll say array, not vector.
But if we just want to add to the end of that 23, another 23,
I'm going to use the append bang function.
So there's append and I'll tell you a little bit about the bang
because you get many functions with and without the bang.
What the bang does, or what it does to this function, it makes the changes permanent.
So I'm going to append to the end of these 23 placebo values,
and I'm going to put that inside of the group, computer variable,
but the changes will be permanent.
Sometimes you don't want those changes permanent.
You only want them to happen with an inside a for loop or inside of a function,
but then you want the original back at the end without the permanent change.
Yeah, I want the permanent change, append to the group variable, this repeater.
So repeat active 23 times.
And if I run this now, now suddenly my vector is 46 elements long.
I've appended to the end of those 23 placebos.
I've added 23 actives.
Great stuff.
So let's close these.
There we go.
The next one that we're going to go for is we're going to actually sample from a continuous distribution.
So in the paper, they looked at a lot of variables.
I'm not going to simulate all of them here, just a couple of them.
So they looked at HDL cholesterol, high density lipoprotein.
That's the good cholesterol before and after the intervention.
So they told us in the paper what the mean and standard deviation was for the sample values for those variables.
Of course, we don't have access to them, but I'm just going to simulate them based on those parameters for the normal distribution.
So I'm going to call my computer variable HDL underscore cholesterol underscore before.
I'm going to use the RAND function, but this time I'm going to not take a unit range.
So I don't want this uniform distribution.
I actually want the normal distribution with a mean of 1.24 and a standard deviation of 0.31.
So that comes straight out the paper.
So I'm saying use this distribution.
So that's distributions.normal.
So if I said using distributions in the end, you could just have said normal.
But because I said import distributions, we have to say distributions.normal.
As I say, I'm doing this so that you can see where this normal function comes from.
It doesn't just come from Julia or some other package.
It comes from the distributions package.
So it's all about just showing you about that fact.
So distributions.normal from a mean, these oppositional arguments.
It's always going to be mean, standard deviation.
As I say, that comes from the paper and I want 23 of those.
So let's do that.
And now we've got these 23 elements.
And then I want to add another 23.
So that was read from the table as far as the placebo group was concerned.
Now I want to add from another distribution according to the summary statistics in their table
for the 23 participants who took the active ingredient.
So what do I do?
I'm going to append with a bang because I want that permanent.
Append to HDL underscore cholesterol underscore before from this distribution with a mean of 1.24.
And so that was exactly the same there and 0.29 as far as the standard deviation is concerned.
So I'm going to add 23 values to that, which means I now have a 46 element vector of those values that we were interested in.
So we've simulated that.
So it's correct for all the two groups of participants.
Then I'm going to do this a couple of more times.
So I'm going to create an HDL cholesterol after.
And again, I'm going to go through the same thing, random from an all distribution with a mean of 1.4 standard deviation of 0.35.
And then I'm going to append to that some more.
So you can have a look at that code.
I'm going to run through it very quickly because it's just a repeat of what we've done before.
So there's a wait before and a wait after, diastolic blood pressure before, diastolic blood pressure before, and diastolic blood pressure after.
So I'm just going to run quickly through all of these, just create them from the distribution as per the parameters in the table.
So let me run through all of those.
Done.
So that would be one way to go about it.
Let's just show you something else.
And the reason why I'm doing this is just to show you how a for loop would work inside of Julia.
So we have BMI underscore before, and I'm passing to that an empty array.
And an empty array is just the two square brackets.
Open, close, square brackets.
It's a vector.
And now you see the type is any.
The type here is any.
Now I just want to stop there a little bit because I want to tell you just about the Julia type hierarchy.
Everything is the type in Julia.
So if I say what is the type of some typing in the repel on the right hand side here, what is the type of just three?
Well, it's a 64 bit integer.
What is the type of three dot zero?
So I'm just saying three dot Julia knows it's a zero.
So if I enter that, we see it's a 64 bit float.
And these are abstract types.
And you can instantiate an abstract type.
What that means is I can get a computer variable and I can assign three to it.
That would be an instance of a 64 bit floating type.
If I asked what the type of, and let's make three comma three, but I'm passing these inside of square brackets.
So that is actually an array.
And if we look at that indeed on the side, it'll say array on the ID, it'll call it a vector.
Same thing.
So it's an array of 64 bit integers and it's a rank one tensor.
In other words, it is a mathematical speak.
It is a real column vector.
And again, the 64 bit integers for us here or the array that we see here, that is a concrete type.
I can create an instance of that type, but I can also look up the hierarchy.
Let's see what the super type is.
Super type is my function.
What is the super type of array?
Well, in this instance, it has a super type of dense array.
Let's go up and say what is the super type of dense array?
Well, that's an abstract array.
Okay, let's go further up.
Let's see what the super type then is of an abstract array.
And that's any.
So any is right at the top of this type hierarchy.
And it's like a branch is going down on all sides.
You get all sorts of types.
So any will have many, many, many, many types.
But I can look at all the subtypes.
For instance, what are the subtypes of?
Let's make it number.
So number is some way up a different branch of the trees.
So let's look at the subtypes of number.
And we see it has two subtypes, complex and real.
So complex is actually a concrete type.
In other words, I can create an instance of complex.
Real, on the other hand, continues to branch out.
So I cannot make...
I can't instantiate real.
I've got to go all the way down to say integer or float 64 down that hierarchy tree.
If you're interested in that, Google it.
It'll give you...
You'll quickly find this whole tree structure.
Anyway, back to our for loop, which is what I wanted to show you.
So for i equals 1 to 46.
Again, remember that would be a unit range.
So I just put in 1 to 46.
And it's going to go from 1, 2, 3, loop through all those values
because I didn't put a step size.
So I could have said something like this.
That would have jumped 1 to 3 to 5, etc.
But if I don't put anything there, it'll be exactly the same as doing this.
I'm just going to go from 1 to 46 and I'm doing steps of 1.
So 1 to 46 to the following.
When you're at the end of the line there and you hit return or enter,
it's going to create this blank space for you.
And that helps us here with seeing what the flow is going to be.
A for loop is always ended with an end.
So you've always got to have the end there.
So what am I going to do here?
I'm going to create two random numbers.
And the first one is going to be stored in placebo underscore BMI underscore before.
And the next one is going to be stored in active underscore BMI underscore before.
And what are these two values?
Well, both of them are the ran function.
Both come from a normal distribution,
but you see there's slight difference in the mean and standard deviation
from which those are going to be selected.
And I haven't said, comma, I want five of them.
No, no, no, I just leave that blank because I just want a single one of them.
So just give me one random value back from that distribution.
Store that in this placebo computer variable.
Give me random value from this normal distribution.
Store that there.
So I've got these two values now while I still won.
And I'm going to use the push bang function.
And I'm going to push to BMI underscore before.
And this BMI underscore before, it's empty at the moment.
But now I'm going to push a single value to it.
What am I going to pass to it?
Well, that comes after the comma.
And what I want to do is to assign based on what is inside of group.
So let's have a look at group again.
I'm just going to show you here on the right-hand side.
So there's group and you can see it's the 23 placebos and then 23 active.
