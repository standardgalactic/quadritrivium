So we just have normal logic here.
So it is dot and and we want the df.group to be dot equals equals placebo.
So row by row.
And all these things have to be true before we, we get that row included.
Now we're down to 10.
And they are all going to be over 50 and they're all going to be in the placebo group.
You can see how easy it is just to manipulate the data to get something very specific back.
That means I can also create new data frames, sub data frames from the full set.
So I'm going to call mine placebo and intervention.
And I want to split the participants up into two very separate data frames.
Very easy to do.
Call the data frame, address the rows by df.group dot equals equals placebo, comma all the columns.
So in this new data frame only has 23 participants in it,
but they're all going to be in the placebo as far as the group is concerned.
And I'm going to do the same and I'm going to call that one intervention.
And of course in the group, it's only going to be the active participants taking the active intervention.
I promised to show you that I had to do this with a data frames code.
I should have said this difference between.
So if you want to create a new column, I have to create it this way.
So there's df, square bracket notation, and then by symbol name.
So if we scroll back up when I created this data frame, I did not use symbol notation here,
when I want to add a new column, I use symbol notation.
So create this new column.
And that is going to be the difference, the element wise difference between these two arrays.
And the first ray is df underscore bmi before dot minus to indicate that it's element wise df dot bmi after.
So that is going to allow me to have this new column in my data frame.
We see that I now have 16 columns.
Now I want to show you a little bit about the query language.
What I want to show you actually is this that it exists because it is phenomenal and it is vast for you to start taking or selecting and changing, manipulating only a part of your data.
So I'm going to show you just a couple of examples here, but that is many, many, many lectures worth of things you can do.
So I'm going to start with my data frame, and then I have this pipe operator.
So that will just be the up-down stroke on your keyboard or my keyboard that's above my enter.
So I hit shift and the key above, it'll be different for your keyboard, I'm sure.
And that's state data frame and pipe it into what comes next.
And here I'm using, I suppose, the generic form of the query package.
So I'm going to start a query and we're using a macro here.
So in Julia, it makes use of macros like this and what the macro would do, a macro actually generates code.
So instead of us writing out the long code, the macros, we can create macros that actually generate code and then that code gets executed.
So it's a very nice way to write the succinct, just the sort of a function there, a macro that will generate code and do something for us.
But this is built at query macro, is built into the query package.
So I'm going to say what query do I want to have.
So I'm going to create this variable called I.
Now it's another thing we haven't spoken about and it's local variables and global variables.
Let's do that.
Here I've created a variable name and I've assigned some object to it.
This placebo exists in a global space, in the global space.
In other words, I can make use of it anytime.
It exists in its value, exists everywhere.
Inside of a for loop, as we did before, we created some computer variables, but those only will have a local scope.
Outside of that for loop, they don't exist and I can't refer to them again.
They're not permanent.
They're not in the global scope.
So here we have query I and then begin.
To every beginning, there's an end here.
And then I'm going to use other macros at where I dot age is greater than 50.
So what's happening here?
This pipe operator piped DF into the query and it was put into the query right there with the I.
So I'm piping DF into I.
So when I say I dot age, I'm actually saying DF dot age.
It's just being piped into this I here.
So where the age is greater than 50, then at select, and I'm passing these inside of a set of curly braces,
I dot HDL cholesterol before and I dot HDL cholesterol after.
So it's going to select only those two columns for only participants older than 40.
And then end my begin, then my end, close my query parentheses there and pipe that into something.
And I want that to be piped into a data frame object.
But because we only used import data frames, I've got to say data frame dot data frames dot data frame.
So if I run all of that, lo and behold, I get this back.
Only those two columns that I asked for.
So DF dot HDL cholesterol before and HDL cholesterol after.
And it's only going to be for people who are older than 50.
So this is just a quick look at what the query language can do for you.
Now I could have done that much simpler before, but this complexity allows me to become very specific.
And there are more macros than just these.
Before I get to the next macro, I just want to show you this.
Many times when we collect data, we try to protect patient confidentiality.
And in a very simple example, what we might do as researchers beforehand, we're going to just subtract in our heads two.
So for instance, it's the value two from everyone's age.
So if someone was really 50, I'm going to capture 48 as the age.
No one outside of the study knows that.
So if someone got hold of that data, it's a little bit more difficult to bring that back to an actual human being.
So that's a very simplified example.
It won't work in the real world.
You'll have to be much more inventive than that.
And there are ways to do this.
But if I want to change something permanently, so DF dot age, I'm now saying assign that to DF dot age dot plus two.
So that's going to add two to everyone's age.
And if you capture data in that way, where you changed it before you analyze the data, of course, you want to change that back.
So that would just be the way to do that.
Here we are back with the query package.
So I'm going to pipe data frame into this at filter macro.
And we've done this one before.
I only want the ages back and whether on the placebo group.
This would be the way to do that.
We saw that before, but this is way to do it with query.
So pipe DF into this.
And instead of I, we have this underscore here.
So DF is going to go in place of those underscore, but I'm using at filter.
So I want ages greater than 50 and group equal to placebo.
Note the differences, though.
There's no at before that.
And I'm using the double ampersand.
And then so you've got to read the notation on the query package and I'm piping that into a data frame.
So what we're going to get back is this data frame of all the columns, but we're only going to have participants older than 50 again and only in the placebo group.
One more way just to use the query.
I just wanted to show you that we're going to pipe DF into the at group.
So I want to group by DF dot group because this DF was piped into this placeholder.
And then the at map query.
And I want two column headers.
My first one is going to be called key.
And my second one is going to be called count.
And to the key, I want the key function inside of query.
And you'll see in a while what that means.
And then in the count column, I want length.
Length is a Julia function.
And that is going to just count how many things they are.
So let's have a look at what happened here.
So I've created a data frame because I piped this all into a data frame.
And I have two columns.
One is called key.
That is my selection there.
And one is called count there.
Key, this key function, what it did to this placeholder because this was all piped.
So let's just look at this piping.
DF was piped into the group by.
So this now becomes DF dot group.
DF dot group, that got piped into all of this.
So this is now DF dot group.
So it's key of DF dot group.
And that's what piped.
We've got beautiful visions of that in our programming language for statistical analysis.
Same sort of thing.
You built this pipeline of execution.
So this DF was piped into this placeholder.
Now the whole lot was piped into this placeholder.
So this becomes DF dot group.
And the key of that is going to return for you the sample space elements.
What are all the unique elements that were found in that column?
So in the group, in the DF dot group column, there was only two sample space elements, placebo and active.
And that's what it's going to give me back.
But in the second one, I want to count how many times it occurred.
So this is a way to count the occurrences of your sample space elements of a variable.
And there we can see we had 23 with placebo and 23 with active exactly as we designed it.
Great.
Let's do some summary statistics.
The describe function is very, very useful.
So it comes from the stats-based package.
So if you just see the scribe, they would know where it comes from.
But I said import stats-based.
I've got to say stats-based dot describe.
And what I want to describe is from the DF data frame.
Take all the rows for me in the age column.
Remember, there are different ways to write this.
You could have just said DF dot age.
Anyway, let's execute this.
And the result is just a tick mark because it's executed in the REPL.
So it says there were 46 values.
There were no missing values.
The mean was 46.93.
The minimum, the first quartile, the median, the third quartile and the maximum value.
They were all there and they were all 64-bit integers.
So a nice descriptive statistics here of that column.
There's also the summary stats function.
That's going to do exactly the same.
But it's going to return it for me here in the REPL.
So I can cool down and see those results here.
And then the statistics package.
That is one of the built-in Julia packages.
You don't have to install that.
Remember how to install, go here, write square bracket, type add,
space and add what you want to add.
And then import it with import or using.
So statistics dot median.
So this is going to give me back the same value as we had before.
The 48, there's the median there.
It was 48 indeed, no problem.
One thing you won't see here is the standard deviation.
But there's a statistics dot STD that gives you back the sample standard deviation.
And if you read the documentation there,
you can also ask for the population standard deviation.
It has a mean and standard deviation, mean underscore and underscore STD.
That's a function inside of stats base.
And that's going to give me back a tuple.
A tuple is different from an array.
Instead of square brackets, we see parentheses.
And by the way, tuples are immutable.
So you can't change their values as you can with arrays.
But that's a story for a different day.
We get back the mean and the standard deviation.
Variants, of course, is just dot var.
Again, there is another argument that you can pass that gives you back the population variance.
This would be the sample variance.
There's a statistics dot quantile function.
And you can ask for what percentiles you actually want.
I want the 25th and the 75th.
That gives me the first and the third quartile values.
And you can see for age, those are the ones we saw there, 40 and 55.
In stats base, not inside of statistics, but inside of stats base.
There's an IQR that is going to give us the interquartile range.
But I can also do that with code.
Let me just go to the front of this.
