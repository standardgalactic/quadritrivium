I can say statistics dot quantile, the 75th minus statistics dot quantile, the 25th.
And if I execute that, I'm also going to get back 15 because that's what the interquartile range is.
The difference between the third and the first quartile.
Span, stats base dot span, that's going to give you the full range.
So the minimum and the maximum value.
And remember, initially we chose it from 30 to 65, but we added two to each.
One of the participants age.
So now we see the youngest was 32.
The oldest was 67.
Now this is a bit of a convoluted one.
I want to show you here in the describe function.
What if you don't want everything back?
So I'm saying here df, all the rows, comma, only these columns.
But this describe function can take back, can take as arguments some things that we want to create.
What do we want to create?
Well, that comes after the next comma.
Create a symbol for me.
That's a column header with a name AVE and attach to that.
And we have to use this arrow notation.
So that's equal greater than stats base dot mean another symbol STD and attached to that.
Stats base dot STD.
So that becomes quite convoluted.
And it takes a while for you to get behind what is exactly how to do that and remember how to do that.
But that gave me the age and the cholesterol delta.
And it gave me the average of each of those and the standard deviation for each of those.
So that would be another way to go about this.
And what you can start to see here, what's developing here is the fact that there's just so many ways to do things in Julia.
There's the unique function in Julia.
And I'm telling it go down the group column.
All the ones just give me back what is unique.
Well, we know it's going to be placebo and active.
So we're going to get back just sample space elements.
I could do it with query language.
Also, I could say pipe DF into the at group by.
So this is going to become DF dot group.
Pipe that into this map at map macro.
And all I want is a key and pipe that into a data frame.
And now I'm going to get exactly what I got back here with the unique.
Instead of getting back just an array, I actually pipe this into a data frame.
So I'm going to get my sample space elements there.
There's a statspace dot count map function.
So not only is it going to give me back the unique values, but it's also going to count how many there are.
And again, I see active and placebo.
But I can also do this just with the query language.
So I'm piping DF into group by.
So DF dot group, that gets piped into the map.
The key, so DF dot group, the key of that.
So that's sample space elements and the length is going to count all of them.
And you know exactly what we're going to get here.
This is what we have before.
We're going to get placebo and active and their counts.
So so many ways.
Whatever pleases you, you choose that way.
One more thing, let's do the median.
And we do only of people who are older than, participants older than 50 in the placebo group.
And then I can use another set of indices here.
And that is only give me back the median of the ages then.
So what we've done here is the median of the age of participants in the placebo group that were older than 40, the older than 50.
So this is a different notation to do this first and then what you actually want.
So hang on to that notation.
It is sometimes easier to use.
Sometimes it's much easier just to use some of these macros inside of the query language.
We can construct our own functions.
And that's one of the beautiful things of Julia.
Construct your own function.
So I see the function keyword there.
Tell Julia I want to create a function.
The name of my function, I decided on that.
And it's going to take a single positional argument X.
And it's going to return for me the following.
Statistics.meanofwhateveripassin, statistics.std ofwhateveripassin.
End.
We always have to have an end.
And now I have a new function, mean and standard deviation.
As you can see here, it is a new function.
And now I'm going to pass an array to it, df.age, into that function.
And so that takes the place of all the X's.
So I'm getting back the mean and the standard deviation of that.
So you can create your own functions too.
Let's do this last one before we visualize data.
I'm going to group by group.
I'm going to map the key.
And then create two column headers, average age and standard deviation age.
And I'm going to perform those two on it.
You can see what is going to be in that placeholder because df is going to be piped into there.
And then this makes a df.group that gets piped into there, which is also piped into there and there.
I think by now you get the meaning of how to write these pipelines.
So I'm going to get placebo and active back.
And that gives me the average age and the standard deviation of the age for those two groups.
Very easy to start learning how to put these together.
Now let's get back, let's get to one of the exciting parts.
We've summarized our data and we've really summarized it a lot.
We've created a lot of other variables.
So please play with them and see what results you can get.
That's the only way to learn is to start playing with these.
So get fly.
There are other plotting libraries as well.
I'm going to show you get fly here.
I like the way the plots look.
And it's a very simple specifically if you know how to use ggplot.
So get fly dot set default plot size.
I'm just going to set it for argument sake here to fit in here to 800 pixels by 600 pixels.
So here's a very simple plot.
Remember I said using get fly.
So I needn't have said get fly dot set or get fly dot plot.
I can just use the plot function directly.
Now get fly.
I like get fly.
It works very well with data frames.
So my first argument is this data frame.
It's the data frame we're passing on the x axis.
I want the group variable on the y axis.
I want the age.
And what geometry do I want?
Well geom dot box plot.
So I actually want Julie here to create a box plot for me.
There's a couple of guides.
One of them is title.
So guide dot title.
Give it a title as a string.
And then you can also do a theme.
So my theme here is going to have a default color midnight blue.
There's a bunch of these already built in.
You can Google that and see all the theme colors that are built in.
And I want to also just make a hundred pixels in between my box plots.
As simple as that.
I'm going to hit shift and enter, shift and return.
And I'm going to go make a cup of coffee.
Because the first time you create a plot,
there's a lot of stuff that have to happen behind the scenes.
It has been recognized that this is a bit too long.
And there's certainly a lot of work going on behind the scenes
and trying to improve this time to first plot in Julia.
It is a known problem.
You do wait quite a long time before that first plot is created.
So I'm going to go often have some coffee.
I don't know what you're going to have.
I'll see you back in a minute or two.
And there we go.
It really wasn't a minute in my case.
It was about 10 seconds.
It was slightly less than 10 seconds.
So it's not that bad.
Anyway, that is from the time I stopped talking, by the way.
And there we go.
I see a beautiful box plot.
I see my age on my y-axis.
I see the two groups.
It found placebo and active all on its own.
And we see the title that we created up there.
And we see these beautifully rendered midnight blue box plots.
Very nicely.
You can assign that to a computer variable
because you do get packages and you do get the draw function,
which can save this plot that you've assigned to P,
save it to your hard drive as a PNG file, SVG file.
Now you might have to import some other libraries.
I think with PNG you'll have to import Cairo, C-A-I-R-O,
uppercase C package to export to PNG.
Otherwise you can just export to SVG.
It's capable of vector graphics.
And those are very nice to use in other programs like Inkscape
or Adobe Illustrator, et cetera,
to add a lot more to your plots.
So here I'm going to use plot again.
Plus the def, I'm going to have on my x-axis the changing
cholesterol, color by the group.
Now this color has nothing to do with color.
Color argument here means split by.
So group by the group column, whatever the sample space
elements you find there, give me a geom.density.
So this is going to be a density plot of the changing cholesterol
before and after the intervention split by the group variable.
And then I've just added a title.
So let's have a look at that.
And there we see a beautiful density estimate
of the placebo and active group as far as the change
in the cholesterol values.
We're concerned if we look at these two distributions
for our data values.
So beautiful density plots there.
You can also just ask for plots that are models.
Look at this data frame.
x-axis is BMI before, y-axis is HDL cholesterol after.
So this is going to be a scatter plot.
And indeed, I'm calling geom.point.
That gives me point marker.
So this is a scatter plot of two continuous random variables,
BMI before and HDL cholesterol after.
So I'm trying to predict HDL cholesterol after
given an input of BMI before.
And I want that done separately
for each of my sample space elements in my group column.
So color equals symbol group, geom.point.
And then in the layer argument,
I'm going to call the stat.smooth function inside of GATFLY.
I want it to be a simple linear model
and I want a 95% confidence interval around my model.
And that's going to be a geom.line
and the ribbon is the confidence intervals around that.
