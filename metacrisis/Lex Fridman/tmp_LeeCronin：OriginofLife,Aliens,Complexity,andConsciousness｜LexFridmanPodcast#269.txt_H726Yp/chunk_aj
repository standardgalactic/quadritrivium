look, chemistry isn't that hard. Reaction, workup, separation, purification, do that in cycles,
forever, for any molecule, all the chemistry done. And they said, chemistry is that hard.
I said, but just in principle, and I got a few very enlightened people to say, yeah, okay,
in principle, but it ain't going to work. And this was in about 2013, 2014. And I found myself going
to an architecture conference almost by accident. It's like, why am I at this random conference
on architecture? And that was because I published a paper on inorganic architecture. And they said,
come to architecture conference, but the inorganic architecture is not nano architecture. And I went,
okay, and then I found these guys at the conference, 3d printing ping pong balls and shapes. And this
is 3d printing was cool. And it's like, this is ridiculous. Why are you 3d printing ping pong
balls? And I gave them a whole load of abuse, like I normally do when I first meet people,
how to win friends and influence people. And then I was like, Oh, my God, you guys are geniuses.
And so I got a got from they were a bit confused because I was calling them idiots and then call
them geniuses. It's like, will you come to my lab? And we're going to build a robot to do chemistry
with a 3d printer. And they said, Oh, that's cool. All right. So I had them come to the lab,
and we started to 3d print test tube. So you imagine, you know, 3d printer bottle, and then
and then in the and then use the same gantry to basically rather than to square out a plastic
out of a nozzle, have a little syringe and jump chemicals in. So we had the 3d printer because
simultaneously print the test tube and then put chemicals into the test tube. And then
was this really end to end? Yeah, I was like, that'll be because they've got gco to do it all.
I was like, that's cool. So I got my group doing this and I developed a bit and I realized that we
could take those unit operations. And we built a whole bunch of pumps and valves. And I realized
that I could basically take the literature. And I made the first version of the computer
in 2016, 17, I made some architectural decisions. So I designed the pumps and valves in my group,
I did all the electronics in my group, they were brilliant. I cannot pay tribute to my group enough
in doing this. They were just brilliant. And there were some poor souls there that said, Lee,
why are you making this design electronics? I'm like, well, because I don't understand it.
And they're like, so you're making his design stuff because you don't understand? I was like,
yeah, it's like, but can we not just buy some? I said, well, we can, but then I don't understand
how to, you know, what bus they're going to use and there's serial ports and all this stuff. I just
wanted, and I made, I came up with the decision to design a bunch of pumps and valves and use
power of the ethernet. So I got one cable for power and data, plug them all in, plug them all
into a router. And, and then I made the state machine. And there was a couple of cool things I
did. Oh, they did actually. We got the abstraction. So reaction, work, work up separation, purification.
And then I made the decision to do it in batch. Now it's in batch. All chemistry had been digitized
before apparently it was it's been done. But everyone been doing it in flow. And flow is
continuous. And there are infinities everywhere. And you have to just, and I realized that I could
actually make a state machine where I basically put stuff in the reactor, turn it from one state to
another state, stop it and just read it out. And okay, and I was kind of bitching it's electrical
engineer saying you have it easy, you don't have to clean out the electrons, you know,
electrons don't leave a big mess, they leave some EM waste. But in my state machine, I built in
cleaning. So it's like, we do all operation, then it cleans the backbone, then can do it again.
That's fascinating. So what we managed to do over a couple of years is, is develop the hardware,
develop the state machine. And we encoded three molecules, we did three, the first three, we did
nitole, sleeping drug, refinimide, anti-seizure and Viagra. You know, and I would like to make jokes
on the paper, it's a hard problem, blah, blah, blah, blah. That's very good. And then and then
in the next one, what we did said, okay, my poor organic chemist said, look, Lee, we've worked with
you this long, we've made a robot that looks like it's going to take our jobs away. And, and not
just take our jobs away that what we love in the lab, but now we have to become programmers,
but we're not even good programmers, we just have to spend ages writing lines of code
that are boring, and it's not as elegant. I went, you're right. So then, but I knew because I had
this abstraction, and I knew that there was language, I could suddenly develop a state machine
that would interpret the language, which was lossy and ambiguous, and populate my abstraction.
So I built a chemical programming language that is, is actually going to be recursively innumerable,
it's going to be a true and complete language, actually, which is kind of cool, which means
it's for me very viable. So where we are now is we can now read the literature using a bit of
natural language processing, it's not the best, the many other groups have done better job,
but we can use that language reading to populate the state machine, and basically add
subtract, there's, we got about a number of primitives that we, the, you know,
basically program loops that we dovetail together, and we can make any molecule with it.
Okay, so that's, that's a kind of program synthesis. So you start at like, literally,
you're talking about like a paper, like a scientific paper, that's being read,
yeah, natural language processing, extracting some kind of details about chemical reactions, and
the chemical molecules and compounds involved. And then that's, that in GPT
terms, serves as a prompt for the program synthesis, that's kind of trivial right now,
there you have a bunch of different like for loops and so on, that creates a program in this
chemical language, that can then be interpreted by the chemical computer, the computer,
yeah, computer, that works. Yeah, everything sounds better in your
British accent, but I love it. So the, into the computer, and that's able to then
basically be a 3D printer for these for molecules. Yeah, I wouldn't call it a 3D printer, I would
call it a universal chemical reaction system, because 3D printing gives the wrong impression,
but yeah, and, and it purifies. And the nice thing is that that code now that we call it
the KIDL code is, is really interesting, because now, so computation, what is computation?
Computation is what computing is to mathematics, I think. Computation is the process of taking
chemical code, and some input reagents, and making the same molecule, making the molecule
reproducibly every time without fail. What is computation? It's the process of taking a,
using a program to take some input conditions and give you an output, same every time, right,
reliably. So the, the problem is, now maybe you can push back and correct me on this.
So I know biology is messy. My question is how messy is chemistry? So the, if we use the analogy
of a computer, it's easier to make computation in a computer very precise, that it's repeatable,
it makes errors almost never. If it does the exact same way over and over and over and over.
What about chemistry? Is there messiness in the whole thing? It, can that be somehow leveraged?
Can that be controlled? Can that be that removed? Do we want to remove it from the system?
Oh, yes and no, right. This, is there messiness? There, there is messiness, because chemistry is
like you're, you're, you're doing reactions on, on billions of molecules, and they don't
always work, but you've got purification there. And so what we've found is at the beginning,
everyone said it can't work. It's going to be too messy. It will just fail. And I said, but
you managed to get chemistry to work in the lab. Are you magic? Are you doing something?
So I would say, now go back to the first ever computer or the ENIAC,
five million soldered joints, 400,000 valves exploding all the time. Was that, would you have
gone, okay, that's messy. So we've got the, and have we got the equivalent of the ENIAC in my lab?
We've got 15 computers in the lab now and they, are they unreliable? Yeah, they fall apart here
in there, but are they getting better really quickly? Yeah. Are they now able to reliably make,
are we at the point in the lab where there are some molecules we would rather make on the computer
than have a human being make? Yeah, we've just done, we've just made a
anti-influenza molecule and some antivirals, six steps on the computer that would take a human
being about one week to make arbidol of continuous labor. And all they do now is load up the reagents,
press go button and just go away and drink coffee. Wow. So this, I mean, and this is,
you're saying this computer is just the early days. And so like some of the criticism just
have to do with the early days. And yes, I would say there's something like this is
quite impossible. So the fact that you're doing this is incredible. Not impossible,
of course, but extremely difficult. It did seem really difficult. And I do keep pinching myself
when I go in the lab. I was like, is it working? Like, yep. And it's not, you know, it does clog.
It does stop. You got to clean. This is great. You know, but it's getting more reliable because
I made some, we just made design decisions and said, we are not going to abandon the abstraction.
Think about it. If the Von Neumann implementation was abandoned, I mean, think about what we do
to semiconductors to really constrain them to what we do to silicon in a fab lab. We take
computation for granted, silicon is not in its natural state. We are doping the hell out of it.
It's incredible what they're able to accomplish and achieve that reliability at the scale they do.
Like you said, that's after Moore's law what we have now. And where we, you know,
how it started, you know, we started at the bottom, now we're here.
We have only have 20 million molecules, well, say 20 million molecules in one database,
maybe a few hundred million in all the pharmaceutical companies. And those few hundred
million molecules are responsible for all the drugs that we've had in humanity except, you know,
biologics for the last 50 years. Now imagine what happens when a drug goes out of print,
goes out of prints because there's only a finite number of manufacturing facilities in the world
that make these drugs. Is that a print? Yeah. It's the printing press for chemistry. Yeah.
And not only that, we can protect the KIDL so we can stop bad actors doing it. We can encrypt them.
And we can give people life. Yeah, that's the name of the programing language.
The KIDL is the name of the programming language and the code we give the chemicals.
So Kai, as in, you know, just for, it's like a, it's actually like an XML format. But
I've now taken it from script to a, to a fully expressible programming language so we can do
dynamics and there's four loops in there and conditional statements. Right. But the structure
it started out as a, like a, like an XML thing. Yeah. Yeah. And now we also, the chemist doesn't
need to program in KIDL. They can just go to the software and type in add A to B reflux,
do what they would normally do. And he just converts it to KIDL and they have a linter to
check it. An error correct. So how do you, you know, not with ASCII, but because it's a Greek
letter, how do you go with, how do you spell it? Just using the, the English alphabet.
XDL? XDL, or we use, we put in Kai. And it was named by one of my students. And I,
one of my postdocs many years ago, and I quite liked it. It's like,
it's important, I think, when the team are contributing to such big ideas,
because there are ideas as well. I try not to just rename, I didn't call it Cronin or anything
that, because they keep saying, you know, is a, is it the chemistry when they're putting stuff in
the computer? One of my students said, we are asking now, is it Cronin complete? And I was like,
what does that mean? And I said, well, can we make it on the damn machine? And I was like,
oh, is that a compliment or a, or a majority? But they're like, well, it might be both.
Yeah. So you tweeted, quote, why does chemistry need a universal programming language?
Question mark. For all the reasons you can think of, reliability, interoperability,
collaboration, remove ambiguity, lower cost, increased safety, open up discovery,
molecular customization, and publication of executable chemical code.
Which is fascinating, by the way, just publish code. And can you maybe elaborate a little bit
more about this KDL? What does the universal language of chemistry look like? A Cronin complete
language?
Well, it's a Turing complete language, really. But so what it has, it has a series of operators
in it, like add, heat, stir. So there's a bunch of just unit operations. And all it is, really,
is just, it's, with chemical engineers, when I talked about this, that you've just rediscovered
chemical engineering. And I said, well, yeah, I know. I said, well, that's trivial. I said, well,
not really. Well, yes, it is trivial. And that's why it's good. Because not only have we rediscovered
chemical engineering, we've made it implementable on the universal hardware that doesn't cost
very much money. And so the KDL has a series of statements like define the reactor. So defines
the reagents. So they're all labels. So you assign them. And what I also implemented at the beginning
is because I give all the hardware IP address, you put it on a graph. And so what it does is
like the graph is equivalent to the process of firmware, the processor code. So when you take
your KDL, and you go to run it on your computer, you can run it on any compatible hardware and
any configuration says, what's your, what's your graph look like? As long as I can solve the problem
on the graph with these unit operations, you have the resources available, it can compile,
chem piles. We can carry on for years. I mean, it is really, it's a compilation.
And what it now does is it says, okay, the problem we have before is it was possible to
do robotics for chemistry, but the robots were really expensive. They were unique.
They were vendor locked. And what I want to do is to make sure that every chemist in the world
can get access to machinery like this at virtually no cost, because it makes it safer.
It makes it more reliable. And then if you go to the literature and you find a molecule that
could potentially cure cancer. And let's say the molecule that could potentially cure cancer
takes you three years to repeat. And maybe a student finishes their PhD in the time,
and they never get it back. So it's really hard to, to kind of get all the way to that molecule,
and it limits the ability of humanity to build on it. If they just download the code and can
execute it, it turns, I would say the electronic laboratory notebook in chemistry is a data
cemetery, because no one will ever reproduce it. But now the data cemetery is a Jupyter
notebook, and you can just execute it and people can play with it. The access to it
reverses the magnitude is increased. We'll talk about the, so as with all technologies,
I think there's way more exciting possibilities, but they're also terrifying
possibilities. And we'll talk about all of them. But let me just kind of linger on the
machine learning side of this. So you're describing programming, but
it's a language. I don't know if you've heard about Open AI Codex, which is-
Yeah, I'm playing with it.
Hey, playing. Of course you are.
You really are Rick from Rick and Morty. This is great. Okay.
Except philosophically deep. I mean, he is, I guess, kind of philosophically deep too.
So for people who don't know GPT, GPT-3, it's a language model that can do natural language
generation. So you can give it a prompt and it can complete the rest of it. But it turns out
that that kind of prompt, it's not just completes the rest of it, it's generating
like novel sounding text. And then you can apply that to generation of other kinds of stuff.
So these kinds of transformer based language models are really good at forming
deep representations of a particular space, like a medium, like language. So you can then apply
the specific subset of language like programming. So you can have it learn the representation of
the Python programming language and use it to then generate syntactically and semantically correct
programs. So you can start to make progress on one of the hardest problems in computer science,
which is program synthesis. How do you write programs that accomplish different tasks?
So what OpenAI Codex does is it generates those programs based on a prompt of some kind.
Usually you can do a natural language prompt. So basically as you do when you program, you write
some comment, which serves the basic documentation of the inputs and the outputs and the function
of the particular set of code and it's able to generate that. The point being is you can generate
programs using machine learning using neural networks. Those programs operate on the boring old
computer. Can you generate programs that operate this guy be a clever version of programs for this
but can you write programs that operate on a computer? Yep. There's actually software out
there right now. We can go and do it. It's a heuristic. It's rule based. But we have what we've done
inspired by Codex actually is over the summer, I ran a little workshop. Some of my groups got
this inspired idea that we should get a load of students and ask them to manually collect data,
to label chemical procedures into QIDL. And we have a cool synth reader. So there's a bunch of
people doing this right now, but they're doing it without abstraction. And because we have an
abstraction that's implementable in the hardware, we've developed basically a chemical analog of
