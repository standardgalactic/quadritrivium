Every closure talk ever.
Hi, I'm Alex Engelberg.
I didn't really rehearse my slides that much.
I'm basically gonna stand at the podium
without moving around much.
I'm probably just gonna read all the words
directly off the slide verbatim.
Chances are that you can read faster than I can talk,
in which case when you finish reading
the end of this sentence, there'll be an awkward moment
where even though you're done reading it,
I'm still not done saying it,
so you just have to sit there
and wait for me to finish talking
before we can go on to the next bullet point.
Also, fun fact about me, I like pizza.
This slide is about me, but this talk isn't about me,
it's about you.
It's about us, it's about community.
It's about the 80% of you that are jammed
into the equivalent of a cheap budget airline middle seat.
It's about building.
It's about us.
It's about me saying nothing of substance,
but saying it in a way that sounds like maybe there is.
You knew this was coming, so let's get it over with.
Profound, you take the dictionary
and you split it apart and then you're done.
That's that simple.
So let's do just that.
Pro from the Latin, professional.
This talk is going to be very professional and found.
We found all the content in your talks, thanks.
So who are we?
We are Random Corp and our mission is to change the world.
How do we do it?
We leverage blockchain technology to power IoT solutions
in the cloud, using machine learning
at scale to optimize cryptocurrency ICOs with Kubernetes.
Everybody in this room should work for Random Corp.
We're amazing, we've got it all figured out
and we have some very unique perks.
Alex, why don't you tell them about them?
Weekly invigorating leadership speeches.
Have finished research projects to put on your resume.
You're welcome.
Late paychecks.
That happened once, one time, Alex.
Triplet programming?
Pair programming is like super last year.
So there's one thing I want you to take away from this talk.
It's that software is hard.
And one thing that we didn't really consider
when we were trying to build this vision
is just how hard software is, you know?
And my job is to kind of walk you through what we encountered
and teach you some lessons along the way.
And I want to show you this architecture diagram
that we came up with.
We have a front-end server.
And we have a cluster of front-end servers
and we figured we needed to sort of balance the load.
So we added a load balancer
and this got us another sort of six months or so.
Then we realized the front-end server was falling over.
So memcached.
The memcached also got us sort of another three months
of leeway before more traffic was coming in.
And then the memcached started running out of memory.
So we were like, another memcached.
So it's to me.
We heard a lot of good things about message queues.
And we really wanted to include a message queue
in our architecture, the sort of,
we couldn't choose between the sort of top competitors,
Kafka and RabbitMQ.
So we just include both of them.
And we just let them kind of chase each other around
a little bit.
So that's the front-end server.
Then we get to the back-end server.
And this is where it gets interesting
because this is where you have to choose your database.
And we step back and we said,
what problem are we trying to solve?
And we decided we needed a database
that was that had high read throughput.
It was version controlled and it was highly available.
And you know, we're at a closure conference.
You can probably guess what technology we went with.
We ended up going with Google Sheets.
And hey, it's like atomic but cheaper.
So we had the front-end server, the back-end server.
We were like, what's next?
The back-end server.
Three tier architecture.
So we went on like this
and we made a lot of architectural decisions.
And before we knew it, it looked like this.
And we were just, I think this diagram does a good job
of really illustrating that the decisions
that you make early on in your company
can really kind of bite you later in your company's life.
If you really don't really take the time
to really think through those architectural decisions.
So hopefully this kind of teaches you all a lesson
on how you should really build your architecture.
So we ran into some challenges.
And at Random Corp, we consider challenges
to be opportunities.
They're opportunities to give back our lessons
to the community.
And let you avoid making the same mistakes again.
And when we wanted to transmit those lessons back to you,
we turned to the only form of communication
that really makes sense for these,
which is angsty medium thought pieces.
The first thing we did was we used Slack
for revision control.
Hey, if it's more than 10,000 messages old,
you probably don't need it anymore.
Our continuous integration was actually
just a cron job on my laptop.
Hey, if I give my source code to the cloud,
what if they don't give it back?
Finally, type systems.
Ugh.
That's my nuanced hot take.
I'm just gonna leave it at that.
So we had these challenges.
And if you look at these problems
that our company was having,
if you can kind of distill that down
to one thing we needed to change in our company,
I think it was obvious,
we needed to choose a new programming language.
Obvious, obvious.
Now choosing a new language is a big decision, right?
This can be make or break for your company.
And we wanted to be thoughtful about it.
You've seen evidence of our thoughtfulness already.
We wanted to follow a scientific process
where we really evaluated the pros and cons
and understood the elements of the language
that we're gonna best fit random corp in our goals.
So of course we turned to the same tool
many of you have in the past.
Wheel of Hacker News.
And we spun the wheel and it let us down a path.
Just so happened we started with go
and wasn't bad, things were going pretty well.
But our code base started to grow
and yet the compiler was still super fast.
And we couldn't really trust the compiler
was doing a good job when it was that fast.
So of course we moved on.
Ruby came up next.
And unfortunately after some brief research
it was discovered that Ruby's actually a color,
not a programming language.
So that was right out.
Then Scala, we thought should we use Scala?
Maybe, maybe not.
And so we moved on, we built more Scala
and unfortunately this is what we looked like
while we were waiting for it to compile.
So that didn't work either.
And we just kept going down the list
and there were so many possibilities
and so many languages to try
and we tried all of these and it was just,
it was such an arduous process to go through
and to try and understand the pros and the cons
and to pluck from this list and figure out
which language really works for us,
which language is really gonna power
our next generation random court platform.
But we found problems in each of these
and the biggest problem was that
half of these languages don't exist,
we just made them up.
That didn't help.
So we needed a different approach.
And we've learned from many of you
that when you're trying to make a decision
that involves closure, sometimes, you know,
going to Wikipedia and other places
isn't necessarily the best way to do it.
So instead, we went to our local library
and we walked directly into the section
with the oldest books we could find.
You have to walk through a dust cloud to get there.
And we plucked from the shelf, just by happenstance,
some old book.
And some old book was incredibly powerful and inspirational.
It was written by very smart people
and they use very big words.
To be honest, we didn't really understand a word of it.
And it was definitely not at all about closure
and yet it was because we say it was.
