And it became clear that closure's the language for us.
Off we went.
So it's time to learn closure.
We were coming from a Java architecture
and when we started learning closure,
we noticed a bunch of stark differences,
some good, some bad.
And I want to show you kind of the things
that we ran into.
First, we'll start with the good.
And first thing is error messages.
You know, Java error messages,
you're going to get a lot of these
if you write a server in Java.
You're just going to see these all over the place.
No pointer exception, what does that mean?
Stack traces, where did these come from?
But then we turned to closure
and we noticed a stark improvement.
Boom.
Two and a half hours later,
I was able to find what was wrong in my form.
Yeah, yeah, I know closure 110 is going to fix this,
but just like let me have this one.
Let's talk about state.
In Java, we love encapsulation.
And what encapsulation means is you have your class
and you have private variables.
And you put your state in those variables
and don't let anyone else touch them
except through your getters and setters
and your constructors.
And this is encapsulation,
and we came to know and love this
when we were working in Java.
Then we switched to closure and we were like, okay.
Apparently it's like more elegant
or better or decomplected
if we switched to records or something
and like everything's better now.
But I was very unsatisfied
with this seemingly clean approach
because where did my encapsulation go?
I wanted my encapsulation back.
And that's clearly the best solution
because it's my opinion.
But closure is extensible.
So when I have an opinion,
I can just change the language to my liking.
And I'm a problem solver.
So I put together a solution to this problem.
So I'd like to show you what I came up with
and I think it's really awesome.
I brought back the encapsulation.
We have our getters and setters back
and then it came time to put in the state
and we were like closure is usually immutable variables.
But they have atoms, so let's just use them.
Yeah, there's that at sign signaling to me
something's wrong, but I just kind of went with it.
And I think this is clearly the best way to use state
and I hope you agree.
Let's talk about macros.
If there's one thing I want you to take away from this talk,
it's that macros run at compile time,
which means like it's the obvious conclusion to draw
is that there are no downsides.
Like at all.
I promise.
Which means you should use as many macros as possible.
Let's talk about threading macros in particular.
Now I think these are a real game changer
because you can take a data structure,
you can apply a lot of operations to the same data structure.
And it looks nice and iterative, it's really easy to read
and I really like these a lot.
And you probably do too, but we also sort of run into
this problem with threading macros
that eventually we have a lot of different operations
that we wanna apply that don't quite fit into the same mold
of the same threading macro.
So for example, we have conge
and that takes the collection as the first argument.
We have map v, that takes the collection
as the last argument.
And so we ended up having the thread first,
thread last, we had the as arrow and the conge arrow.
And I think this looks really ugly
because we have to compose all these macros together.
It's just gross.
It would be nice if we had one macro
that could combine all these together.
And I'm a problem solver and I can extend this language.
So I did, I have the thread first,
thread last backwards question mark as arrow, conge arrow,
bang, and this is amazing.
It's the most elegant way to solve this problem
because it's a single macro that combines all these different
macros' behavior.
And, it's so much better already.
And we introduced this in our code base
and it was an absolute game changer instantly.
And I'm so sold on this idea.
I've actually made a repo, you can check it out.
This actually exists.
If you want to go check this out,
just go to thread first, thread last backwards
question mark as arrow, conge arrow, bang,
it's pretty awesome.
This is the bread and butter of our code base
and I hope you get some use out of it.
You guys can go there right now on your mobile phones.
We're happy to wait, should just take you a few minutes
to tap that in there.
Yeah, give it a star.
Don't mess up the character.
Yeah.
Build tools, when we got to build tools,
we determined the options available to us were line again.
So I'd like to move on the REPL.
If there's one thing I want you to take away from this talk,
it's how amazing the REPL is.
We're Clojureans, we love our REPLs.
And it's the most instantaneous way to run your code.
And if you've written any other closure,
or any other non-closure language,
you've probably had to worry about how much time
is it gonna take before when I write my code
and when I get to see if it works.
But when you have your REPL available to you,
you can instantaneously send your code to the REPL
and it's the speediest experience for development.
I could just keep talking about this,
but I just want to show you.
We have a demo prepared.
It's gonna go great.
Please demo, gods.
Shine upon us.
So yeah, so if I just type line REPL,
and this is gonna be instantaneous.
It's about immediate feedback, it's about speed.
Speed.
Once this loads, it's just gonna be
the fastest experience ever.
We just have to wait a few seconds for this to load.
Okay, it's making progress.
Yeah, this is gonna take a little while.
It's fine, this happens a lot.
I'm just gonna go back and we'll come back to this.
So we've noticed a lot of you as you go
through your closure journey.
You start off a little like we did, right?
Maybe translating from the thing you knew
to the thing that's new.
But there's that moment in all of our journey
where we get it.
Closure makes sense.
We find the essence of closure.
I think everybody sort of comes to the same realization.
And so we want to share that realization with you.
But first, I want to talk about where we started.
3%, we were very proud of this.
3% was the reduction in overall lines of code
when we translated from Java to closure.
Thank you.
3%.
Thank you.
Powerful, transformative effect.
And yet, we talked to people, we watched your talks
and it seemed like maybe we were missing something.
Some people thought we could do even better.
It seemed unimaginable.
But then we got it.
We figured it out.
They didn't.
We figured it out.
And because it's so important, this was an epiphany,
I'm going to look everybody in the eye,
walk to the edge of the stage,
and say very slowly, this epiphany we all reach,
it's just data.
I don't know if everybody got it.
So I'm gonna continue my walk across the stage.
And I'll just say it again from here.
Move the slides.
It's just data.
I'm saying it really slowly, so you know it's important.
But I feel like I need to say it one more time over here.
It's just data.
It's we all get it at some point.
They still don't get it.
Okay, I'm gonna do it one more time,
but I'm just gonna say the last word
and I'm gonna say it very slowly.
So you know that's the important one.
Data.
That's what closure's about.
That's the essence of closure.
That's what we were missing.
And it's closure, so it's not just data data.
