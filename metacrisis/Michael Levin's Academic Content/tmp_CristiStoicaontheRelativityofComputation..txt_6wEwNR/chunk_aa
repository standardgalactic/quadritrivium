Okay. I don't know if you can see it. So, oh, shit, I have to press a button.
All right. All right. So it's okay now? Yeah, good. I can see it. Yep. Go for it.
All right. Perfect. Now, this is the plan. And we can follow it or we can jump depends
how fast things are going. The first point, which I already mentioned is that computation
is a convention, but I don't mean it in a sense that it's not real. It's just by changing
the convention, you change the computation, and none of them is more real than the others.
They are all either equally real or equally conventions, but they work, all of them. This
is my point. And I will show you the program if we have time. And I start with very, very
simple in case you said you recording, if it gets online, I start very simple so that
other people who are not well prepared about this can understand. So suppose we have an
alien device, I say it's alien because we don't know how it works. And we are supposed
to don't know how it works and to not be able to break in to see how it works. And we know
what it does. So it has, I don't know if you see the mouse, but it's a knob with two possible
positions, A and B. And Q is a switch with two possible positions, C and D. This on the
left and at the right, there is a pointer, which can indicate either X or Y. But these
notations are just put here so that we can refer to these positions. They are not written
in the device because it's alien and they didn't know these letters. But we know that
if we put the knob and the switch in the positions A and C, the pointer will indicate X. And if
we switch the switch to D, the pointer will indicate X. But then if we put the knob in
position B and the switch in position C, the pointer indicates Y. And then the other remaining
possibility, it indicates X again. So now there are two guys, Alice and Bob, who try to figure
out what it does. And Alice believes that it is an AND gate. And for this, she puts the labels F
from false and T for true to the knob, the switch and the pointer. And indeed, it works like the
truth table for the AND boolean function. So only when both of them are true, the pointer
indicates true and the other case it indicates false. But Bob used a different labeling. So what
he got is a different function, the NAND gate, which is basically like AND, but at the end,
you're negated. So he just flipped these two labels. So they get into an argument, they ask
their friends, Carol, David, and so on. And each of them comes with different interpretations.
And they are different, eight different boolean functions. And the device can compute the result
for each of these. We can arrange them like this, where the in and young choices correspond to
true and false. But this is just a nice way to arrange them. So they conclude that there is
something, a relativity of information and computation. They depends on the convention
of the user. They are not an objective reality, but they are a consensus or something, a convention.
In the case of a computer, you have N, suppose you have N different memory cells. Some of them
can be written by the user. There's that form the input. Some of them can be read by the user,
not directly. We use some user interface to do these kind of things. And others are not exposed
to the user. And at every step, the processor changes the state of the memory by following a
particular rule. This rule, although usually computers are not presented like this, but since
it's a state machine and works in steps, this rule is a function that takes N bits and then
computes what those bits should be at the next step. So it's a boolean function again, or N
boolean functions, if you want. So in this case, you can choose the convention, like in the case
of the alien device. There will be two to the power of N just by choosing what each memory cell,
how to interpret each memory cell states as zero or as one or the other way around.
And the particular case is this. So this is the same like this case within memory cells,
but with only three. And this is the alien device that we discussed earlier. It's just like this,
but the computer is more longer and it repeats. It takes its own state as an input that it computes
the next state. And the first objection that comes to mind, and which also blocked me for a while in
this question, was that you can have an AND gate, which is with two push buttons connected in series
and an OR gate, which is two push buttons connected in parallel. And if you ask anyone, they will
say, yeah, the one in series is an AND and the one in parallel is an OR. Everybody who studied a
bit of computer science, they will say this. But still, you can use them to compute any other of
these eight gates that I mentioned earlier. You can use the circuit in series to compute OR,
or you can use the circuit in parallel to compute AND and the other Boolean functions that
that we encounter with the alien device. And of course, computers are made of transistors. So,
and we can say this objective push buttons is either pushed or is not indeed. But you can
formulate a different sentence is about the buttons being pushed on or
being in a position on and off. And there will be different sentences
with different truth values. But they will be
all equally valid. There will be none that is more special. So,
this at first is not very convincing. But if we look at how computer science is applied and how
computers are built, we will see that they actually don't respect this idea that
there is an AND objectively and there is an OR objectively. They switch the convention all the
time. I mean, when I say they, when the hardware is produced for optimization purposes, the convention
is switched internally by design. The hardware, the people who design the hardware, they choose
to do this and they will give some examples. So, now if the objection is that even if we insist that
we can represent the push state of the button as a zero or as one, we make this choice once for all
and it never changes. But in the computer, it actually changes. So, I will give some examples
that will show. So, first of all, there are memory cells that don't look different. So, they are the
mirror image of one another when they are in the state that we want to call zero or in the state
that we want to call one. They look just the same and there is no reason to prefer a convention over
the other just by the fact that they are symmetric. But then even if we choose
a particular convention for a computer, we can see that the other convention works too. So,
for example, to people who have computers that are implemented using different conventions,
they can communicate by flipping the bits they send to each other by inverting them.
Two AIs would be able to communicate and you can conceive of an AI that has a part of actually
this is how they are. They are not, the AI is not in the same computer. They are spread in a network.
So, it's like, we have some neurons in a computer, some neurons in another and so on.
It's even more complicated. But they still work. So, if you change, if you would have a hardware
with a different convention, it will still work because what matters is that at the end,
there is a synchronization between these conventions. And it's actually even in the same
computer. So, we have different kinds of memory sets in the Ezra memory. We have a way to represent
the bits on the hardware a different way and there is no problem about this. Another thing is that,
okay, so this is about communicating when used to opposite conventions. You just use this gate.
Another example is the Arithmetic Logic Unit, which does, which performs additions.
But you can use it to perform subtractions and even various logic operations by changing the
conventions of how to represent the numbers by bits. For example, there is this complement
notation that you use to make easily subtractions as if you do additions and so on.
But the interesting, okay, now about universality. You can use a NAND or you can use a NOR. I mean,
you can make a computer only on NAND gates or only of NOR gates because they are universal. So,
you don't need to have all possible logic gates in the same computer. You can have only one kind
of logic gate and it will do the same operations. So, now the question will be, for example,
if we talk about the computers being sentient. If there is a very atomic experience that is
associated with performing the operation NAND, and my computer doesn't have such a gate because
it's made only of NOR gates, doesn't mean that I don't have this experience. The NAND operation
will be made. It will be realized out of NOR gates, but there is no NAND gate inside of it. So,
these are some kind of questions that we should ask when we try to think how the computer can be
sentient, for example, if we think it can. So, there is this kind of interpretation that I
discussed so far that you can choose to invert the convention for the bits to represent 0 and 1.
There is also another convention that is used by hardware manufacturers to permute the bits,
and these papers illustrate this and they are very important for the computer science.
But even more, computer science has a very central concept, the concept of simulation. So,
when you have a Turing machine, and I describe a bit what a Turing machine is, it has like an
infinite, this is a theoretical abstract Turing machine. Computer is an implementation of physical
instantiations of this, but it has finite memory, but this one has an infinite possible memory
that can access. This tape is possible, it can be extended infinitely,
indefinitely, and all it does is to move at each tape to move to the left or to the right one cell,
or to read the content that is in the current cell or to write. And then the internal state changes
and decides what's the next step. And this is a Turing machine and all computer programs or
algorithms can be implemented with Turing machines, and there are Turing machines that can simulate
any Turing machine. And now the question is, what does it mean that they simulate? They simulate,
I'll give an example. So, here there is the initial state of the tape in the left and the
final step after the computation in the right. And we see that there are three ones, a space between
them or a zero between them and two ones. And at the end, it will be five ones together. Another
example is this one, another example is this one. And if we look a bit like this, we realize that at
this example, we realize that we can interpret in two different ways at least. One of them is that
they perform additions. And another one is that this Turing machine performs, just removes the
isolated occurrences of zero. So, they look like different functions, but they behave the same.
So, when you describe what it does, you can describe it in different way, but the operation,
the physical process is exactly the same. And if we examine how in computer science, we decide
when a Turing machine is able to simulate another Turing machine, we see that it is something like
this. You select some of the states of the first Turing machine, say A, Turing machine A simulates
the Turing machine B. And then by the process of the Turing machine A, it will go from one state
to the other of those that you selected. Either it goes directly or it goes through intermediate
states that are not necessarily among the ones they selected, but it ends in those. And if this
connectivity between the states is identical to that of the other Turing machine, then we say
the first one simulates the second one. And the interesting thing is that there are universal
Turing machine able to simulate any other Turing machine, but there is nothing in the hardware
to tell us what kind of the number of symbols, for example, of the Turing machine or the number of
because when a Turing machine simulates a Turing machine with a different number of symbols or
with a different number of possible internal states of the head. Since it's universal, it
will behave just like that one, but it's hardware will still be made of, it will still work as
is the first Turing machine. And yet in computer science, we say that they are equivalent. I mean,
the computation done with the first Turing machine is equivalent to the computation done with the
one that it simulates. And these are examples of very small universal Turing machines,
with 15 possible internal states in the head, that reason, right? And with only two symbols,
this is like a world record. And another one is with only three internal states, but with nine
symbols. And there are more examples. Actually, it's very easy to make universal Turing machines.
This cellular automaton is another universal Turing complete, but it's not,
doesn't look like a Turing machine, it's just a cellular automaton. So you have a row where you
can have dark or light cells. So there are only two possible colors. And the rule is like this,
if there are three dark cells, no, three full cells, the one in the middle changes to empty,
and so on. These are the rules. And these are listed the rows in a temporal succession. So
you start with one with a single cell that is not empty. The other ones on the row are empty.
And by applying this rule, you obtain an X-Row and an X-Row. So you represented each row
to represent the state of the same row, but at a different time. And this is universal. And
you can choose the initial row so that you can implement any other Turing machine,
any computer program. So if you want, you can make, you can, you can simulate on this Turing
machine your operating system of your computer or whatever. But this is in principle because nobody
is doing this in practice, they just prove that it's universal. And the same with the
corner is game of life. This is also Turing complete. So you can, on the corner is game of
life, you can program any computer game, for example, but you can also program this cellular
automaton and vice versa, because those that are Turing universal, they are considered equivalent.
So it doesn't really matter. There is nothing objective there. The only objective thing is the
way they connect. And this is not, this doesn't enforce, which is zero or one, doesn't enforce
what the states represent. This is the part that we put in and it is our convention.
And now I'll give some examples that again, going back to the computers,
we have, for example, this is when you transmit the information,
you transmit information, but there is noise that and some of the bits can be damaged. So to make
sure that this doesn't happen, you use an error correction code. And this is a very simple example.
So you just take each bit and multiply it so that you have three copies, and then you send it. And
in case the noise damage is one of them, then you'll vote, basically, so the majority of the,
so in this case, two are zeros and one is one, but you trust the majority and you put it back
to zero and you recover the bit. Of course, it can happen that two or three of the bits are
damaged by the noise. But this is the reason why we use more sophisticated, but in any case,
no matter what error correction code you use, it is possible that you will get
the wrong message after the transmission. Now, these are not quite used in the computers normally,
only when you transmit the information, but in the case of quantum computing, they use
much more sophisticated correction codes because otherwise, the computer itself doesn't remember
its own state if you don't use this. And what I mean by this is that this is a very simple
example where you copy it, but the more complex error correction code that I use in practice
replace the bits with more complicated strings following more complicated rules that have no
relation apparently with the initial bit, except that you know the code that you by convention
decided to use. And this is even more so in the case of the encryption where you can choose
a way to encrypt and the key and you'll encrypt the message and it doesn't look like at all like
the original message. That's the whole idea. But the interesting thing is that now
there is encrypted computing, so you have a computer program running on a server. You send it the
input in an encrypted form and it computes it and then it computes it without decrypting it because
it doesn't have the key. So blindly, basically, is like, I don't know, you have a computer program
that you want to solve a Rubik's Cube and you send the Rubik's Cube, but you don't tell how it is and
yet still he's able to solve it without seeing it. So it looks like magic, but it's something
based on very rigorous isomorphism between mathematical structures and it actually works and it's used
more and more. And the conclusion of this part is that interpretations
are actually not only very important, but without them, you wouldn't be able to have a programmable
computer because to program the computer means to simulate on it another computation. So basically
another Turing machine and the fact that the convention is not so strong connected with the
state of the hardware, it's changed on the fly, allows us to use the same logic circuits to do
different operations. So like, for example, when you use the adder to perform subtractions or
a shift on beats and so on. Although it's designed to work like another, it's also
usable like these other things and it's used. So if we would be so stuck to the hardware to
have a convention that it is right there in the processor and in the memory of the computer,
respected all the time and is never changed, there will be only one program that will run,
there will be only one Boolean function that this computer computes. But now we can change it by
programming. So this means that programmable computers and universal computers, although this
is an abstract universal means that you can program anything with them, but obviously you'll
need more and more memory if you want, because there are programs that require more memory.
But supposedly you can access it through internet,
find some server and use that server to store the additional memory. So anyway,
this will not work without changing the convention. And I say secretly because at the end the user
doesn't see that you change it. So you change it, you do the operation and you deliver to the user
back in its own convention, in the original convention, so that the user doesn't
