have to interpret using his own mind because this is why we have computers.
The user fixes the interpretation but internally is not represented.
And for example here Alice put some
letters labeled the states of the knob and the switch and of the pointer.
And she fixes the interpretation of what the alien device does. And internally it could be
implemented in any possible way. I mean it could be an or like connected
some push buttons in parallel. You wouldn't know because you use it like an and as Alice wants.
It could be any of the eight possible Boolean functions. So you can take any of the possible
eight gates and put it inside this device and simulate any of the other seven out of the eight
possible Boolean functions that you can realize with this. And there will be no difference for the user.
So if we believe that the computer has a mind like the AI or the chat
GPT has a mind, it's actually our own convention. I mean it's obvious when you look at the computer
science but I don't understand why computer scientists themselves think that it can be
conscious. But let's move forward to see why I don't think.
It's too long. The presentation is too long. I will skip a bit.
But I because I want to show that there is a way to probe experimentally how
how big is this ambiguity that is allowed by the fact that it's a convention.
I'll move forward to an experiment. So I have I chose a problem which is
so-called NP complete but it's very simple. It's the simplest one. You get, for example,
a number of coins and you want to divide with the friends so that each of you get equal value,
equal share. So this is not a good partition but this one is a good partition. And the
problem is the partition problem is that you get a list of numbers and you want to find out if you
can split them equally without throwing out any of them or cutting in half the coins or whatever.
And the program cannot solve it in a polynomial time. It requires an exponential time although
this can be optimized but never polynomial but it can verify it. So if you give the numbers
and the partition, it will verify very quickly if the partition is fair. So this is why it's
it's a good problem because it's not too simple. You can solve it hard but you can verify it
fast, verify the solution once you know it. And what I did was I made maybe now I should
share another new share. Okay so here I have a computer program that does this. So what it does
is that it has a partition and it has a list of numbers and it has a partition which in this case
means that all the numbers are in one of the parts of the partition and no number in the
other one but we can choose any partition. And anyway if I press I, I can input but if I press
A it will test all possible partitions but how it will test them? It will run the program for this
partition and then it will read the result of the as if it tested the other partitions without
calculating, without running the algorithm to test each one of them. So there are two in this case
to the power of six possible ways to to split six numbers into two. Sorry, I'm only seeing the
code itself if you've got some sort of output it's not being shown. Oh no, all right, sorry, yeah.
So this is another screen which is runs when you run the, sorry, is it okay. So
it's basically the program when you run it and what it does is it verifies for a single partition.
So you call the program just to verify not to go through all the partitions just to verify
one of them and you have to tell it I put these numbers in the left and these numbers in the
right. In this case I put all the numbers in the left and no number in the right and yet
the program can decrypt from by changing the conventions of the bits can decrypt what would
have been the result if you would have passed a different way to a different partition to verify
and it does this just by using the fact that there is of this fundamental notion of simulation
in in computer science. So what it does it changes the conventions of the bits
without running again the partition it says yeah I know that I sent you 000 000 and I get
this result but I change the convention without running you again and then I read the result
according to the new convention and I collect all these results and compare them with what would
have happened if I would run the program for that partition and what the program shows and the reason
I make it open so that everybody can verify is that it does it for a single case and the user
can debug can go step by step through the program and see what it does and check that indeed it does
for a single case but then somehow from that single run it know what would have happened
in the other cases by changing the convention of course this is not a trivial thing to do but
all the code is available and it can be verified not very much code but just this is just for the
verification I mean to verify that the program really works as I claim so there is a small
algorithm that just add those numbers and compares them basically that
but I did it in a way that so that I could apply
decryption and encryption to to those bits to those to the data because
you cannot decrypt it in all possible situations you have to have a program that keeps the input
in the memory until the calculation is finished you know but even so if you put 100 numbers in your
input data and then 100 bits to be zeros and ones you have to to the power 100 possible inputs
calculations but it only needs to do one now this doesn't mean that it reduces the
search for a solution to finding an actual solution this would be this would mean that
p equal and p and this is not proved yet either away or either proved or disproved
because the verification itself takes an exponential time you have to verify each
possibility but you verify it without running again the the program to compute it this is
this is what I mean so so basically it's like you have a machine that does a thing and instead
of Alice Bob and six other people believing that it does eight different things there is a
potentially unlimited number of people who believe it does different things and everybody
can look at the machine and find the result for for their own Boolean function that they
attribute it to the machine and they will all work at the same time so it's not it's nothing
magic here it appears surprising because we tend to believe that there is a unique computation
that the computer does when it works like for example from this moment to
five minutes later what it did is a unique physical process but if you look at the
unique physical process in different ways you can read the more possible computations that's all
and I need of course a way to encrypt and decrypt and the problem with this is that
for a simple program I can write something like this to encrypt and to decrypt
to the interpret basically the data in a way that I read a different computation than
then initially but for an AI this would be impossible not because because I'm not smart
enough and I don't have computational power enough to encrypt and decrypt the complex processes
that you have to run when you run an AI on the hardware so but what I show is that it is possible
in principle and in practice for simple cases so it's it's it would be easier to break all the
encrypted communications than to decrypt but what do I mean to decrypt an AI
so the mic let me formulate the questions and connect with what I did so with what I explain
so far I'll return to the slides can you see the slides yep okay so what I what where I where I am
going with all this discussion because okay people can agree okay there is a lot of conventions
involved but always stick with the convention the point is that suppose that the computer will
become sentient according to whose convention because if we can make an exponentially large
number of possible conventions depending on how much memory the computer has there will be
many conventions and it he doesn't know our convention because the convention is in our
mind so the physical process is the same the what I do when I press the keyboard for example is the
same but I read I interpret differently the convention and the computer doesn't know what's in
my mind so let me let me show using so this experiment can be verified
let me let me show where where can it can be downloaded in case everybody somebody
wants to verify it so sorry this this page on github and this is the the file it it's in
c++ and people can go step by step and can verify that what I said is so and also in this paper
which is at this link and has this title it can be downloaded it has a description of the
of the algorithm so I was met a matrix multiplication to to to do this thing that
that's for the reason I explained earlier because if you work in a particular reference frame
you may believe that this is an objective thing but if you change the reference frame you can read
a different a different story from from this so basically I had a geometric
way to to approach the problem and the the implementation is
is at this page when github the code now I return to the slides to say how can you use
this to produce more ai's in parallel first I I want to explain in in a different way what
happens if I run so you see the slides now right okay so this is a server and I run the
that program that I showed earlier on the server and somebody sends so these guys around are connected
and are the clients that use the program that is on the server and they send a partition as
number of zeros and ones and the the numbers are all the same they send a list of numbers in
the partition and the server computes them but they don't tell the partition that they have in
mind they flip the bits to to encrypt it so they send it to the server the program on the server
computes it and it gives the result and then they look at the result and decrypt it and find the
result for for their partition and if it happens that everybody sends the same data it to optimize
it will say okay everybody send the same data I will run only once because it's only one data
but each of them can encrypt in that data a different partition so for example they can
in this case there are eight it would be like three bits to represent the partition to be like
they have three numbers and the three numbers can be partitioning two in eight possible ways
these three bits will represent this but in the program that I shown you can change the number
I start with six but you can change the number but potentially it can be so that everybody on the
planet sends at the same time the same partition to the server it computes the only ones but each
one of them have different partitions that we started with before we encrypted them but we
can encrypt and get the same result by using different encryption keys and then we can decrypt
the same result because we all receive the same result but it is encrypted but each one of us
apply different key because we encrypted them with different keys and you will get all possible
partitions at once computed by running only once the program on the server by everybody
by all clients so
oh here I described the steps
did I go too fast or did I have questions because I don't want to skip over the details and
no no it's all good unfortunately I'm gonna have to run in about nine minutes I've got another
meeting I have to be on okay but yeah please go ahead all right so I'll move forward now if you
have here an AI on the server and the I said I will do the calculations by my own hand I will not
run this program because the I and the program live on the same server but the I said I will do it
myself because I am an AI and I'm smart and it will do the program and suppose that at the end it
doesn't send back the result of the calculation it sends all the data that also contains the state of
the AI by the same idea to decrypt I can decrypt the full string but it would be a very huge key
a very complicated encryption and decryption but
this is a thought experiment so suppose I am like a very smart guy who can do this decryption
are everybody of the clients are such smart brilliant gods basically to decrypt such
a big complex data they will see different AIs and the I will have different experiences because
it will take the steps on the computation and it gets different numbers so for example the I suppose
has some reactions to the numbers like people like when I meet seven I say it's luck so seven
dwarfs or 12 it's like 12 months and so on that you have some additional thoughts that are triggered
by by those numbers and then the I can go in the direction of the thought and dream like they
dreaming like we do all the time when when and we start from from an apparently random thought
then the I will become the possibilities to interpret what the I experienced diverges
because you just because I changed those numbers and it can have different experiences for for
example it reminds the anyway I will not be able to finish if I give all these details so let me
go back to what I said I will do first establish that the computation is a convention that there
are many possible ways to obtain a computation that it's depend on the user is relative to the
user and if they I would be would be sentient the same hardware will run many different this
this was what I was trying to establish at this point and the rest is not necessarily related to
to poly computing because the rest is I am using this ambiguity to make a probabilistic argument
that we are not reducible I mean our consciousness is not reducible to a computation so I would say
I would stop and here's some comments from you and see what where we go great well thank you very
much a couple of things so yes as you saw from our poly computing paper I'm completely in agreement
with you on the the conventions and the observer relativity and all of that my main comment is
and and I'm not you know trying to define properly sentience consciousness all of that is
is a difficult thing and that requires you know much more time but I will say just one thing
which is that everything that you've just now said applies to the biology in other words biology
does exactly the same thing there are all of the parts of an organism are constantly trying to
reinterpret everything that everything else is doing and it is completely free to interpret
those signals in in new ways and that kind of observer relativity is something that biology
uses extensively and you know this idea of multiple minds on the human brain I mean the
reality is and I'm not just interested in human brains I'm interested in you know all kinds of
biological things but the reality is that if if you take some sodium pentothal and you put it into
your carotid artery and you put the sleep the left hemisphere for about 20 minutes the right
hemisphere usually doesn't talk but it can can write and what if you ask it questions about
what does it believe and how does it feel about your job and your various things you will get
answers that are often completely different from what the verbal hemisphere reports and that's not
in and so there's that there are issues of dissociative identity kind of scenarios I mean
this this idea that we are running just one mind is is tough it's tough to support the borders of a
mind or you know right now you and I our left hemispheres are having this this conversation but
there are many other modules in there yeah right that action and so and so re-interpreting everything
re-interpreting memories re-interpreting signals is something that biology does all the time so I
think this is a very valuable way to look at things but I don't think it distinguishes
biologicals from devices that are that are made in other media I think this is something very
fundamental to any kind of cognitive system no matter what it's made of it's going to have the
same the same property but that's but that's my opinion yeah all right how many minutes do you
still I have about two minutes and and I will send you I just it's funny I just wrote something
fairly lengthy on exactly that topic so I will I will send it to you and maybe we can we can have
we can have another another discussion about it all right great thank you very much I don't know
because if I start something else I'm afraid I will speak more way more than two minutes and
we'll we'll exchange emails and maybe chat another time to if we if we need
absolutely and I agree with with you and to some extent so I think that indeed biology
but I am not a biologist but I'm happy that but that biology needs to interpret in different ways
uh so basically to use the environment as a computer in different ways and its own parts
yeah in some sense because uh if I understand it's between one hemisphere and the other but
I I believe that in the hemisphere you have different clusters of neurons that would disagree
about what what happened to you and if they given the chance to to speak they will say different
things and if they are not given the chance they they will force you to to commit this
the Freudian sleep or something just to to express themselves and uh I I am totally in
agreement with this part and especially that you need these resources for survival and for
evolution even at the cellular level you need to be very flexible in what you
attribute to in how you interpret the environment
yeah the environment and the contents of your own memory so so your own memory is is is constantly
being interpreted and reinterpreted and there are some remarkable examples yeah
