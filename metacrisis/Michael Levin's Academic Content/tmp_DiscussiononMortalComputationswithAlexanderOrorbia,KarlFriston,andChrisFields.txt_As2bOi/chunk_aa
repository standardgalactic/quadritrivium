No, that's great.
Okay, so maybe we could start.
I think, Alex, if you could start
and just give a few more words on this,
the whole notion of mortal computation
and specifically the issue of programmability
and morphology and how we can sort of distinguish
when we're looking at a system,
how can we distinguish what aspects
of mortal computation we're looking at.
Anything along those lines,
I think would be very useful for us.
Maybe we could start there.
Yeah, so I did, by the way, read last night
the paper you shared with me and Carl and Chris
at one point and some of your notions in there.
First of all, a lot of it sounds like parts
of mortal computation, just maybe you're not using
the word mortal computation phrase.
So in terms of the morphology part,
so the argument that Carl and I make in that paper
is just that the structure, right,
is critically important to the actual system itself.
So you don't want to devour,
there's a lot of this idea of the amorphic formulation
of computational models.
So when you take, and actually Carl and Chris had a paper
that predated the mortal computation paper,
but we developed that metaphor further,
you can draw a dot and arrow diagram of a neural network
and that endows it with this pedagogical morphology,
but really at the end of the day, it doesn't matter.
It's just a pile of linear algebra
that will do its calculations.
And then we have to go through
the von Neumann computing architecture
to transmit the weight, memory and all that.
And then that's where this great thermodynamic cost.
So living systems, I know as you know very well, Michael,
but in general are inherently morphic.
And actually this is the part where we didn't have it
in the paper, but your paper used the word polycomputing,
which is the idea that a substance
can compute many different things simultaneously
is like one way to look at that word.
And the idea is that it's all about the substrate.
And so mortal computation then just says,
if we're going to think about artificial
general intelligence or machine intelligence,
we're sort of going about it in the wrong,
potentially wrong direction by having this divorce
of the computational architecture and construct
separate from the morphology or the substrate too,
that this is going to be enacted on
because living systems, if you change the morphology,
you change the properties of the system,
you change also what it can compute, what it can do.
Now you talk about the liquid kind of brain
or the idea that we have this self over time,
which doesn't actually sit at odds with mortal computation.
So the idea is that you're constantly through change,
you're persisting, you're almost like I want to persist,
but I understand that my system
is going through like auto pieces.
So mortal computation sort of absorbs that
and tries to say we should be designing systems
from that perspective.
So just so I don't keep rambling,
you were talking about programmability.
And I think that was an interesting part
that we didn't really get to chat a whole lot about
and it wasn't 100% clear what was meant
by programming the morphology or the system
because actually after reading your paper,
I think that sort of gave the answer as to how,
because I said originally, oh well,
I'm thinking that the morphology or the substrate
dictates strictly what you can and can't do.
Yes, it will change and it will repair
and go through damage or do things like self-replication.
But I wasn't thinking about the human designer,
he would say if we are designing a chimeric system
or something new, manipulating that morphology so easily,
it's more like, well, we're gonna be looking
at computational simulations of that
and that would be programmable.
And then that's where I was talking about,
oh, we could do like a software simulation
of Anthrobots or something, or Xenobots of that form.
And then you could sort of set the properties
of the environment in the system roughly
according to something you wanna look at
and then simulate it and see what it does.
But then your paper sort of essentially,
in your work as an example of you can directly program
like the genetic aspects of a system,
or you can kind of manipulate the bioelectrical chemicals.
You had an example of like a tadpole or a froglet
where if we apply the right electrical stimulation,
you can get it to grow a tail or get it to grow a leg
and there's some properties there.
So I think that is where the programmability is.
And then that would be more,
you would have even actual experience
programming the morphologies.
Whereas I was thinking more from the perspective
of neural networks where we have the structure
and we want that to now be at the very top
of what Karl and I call mills.
And that you remember in the paper,
there's the mortal inference learning and selection.
And at the very, very top is structure.
And that would be something that I think is underexplored
in the area about, oh, maybe we have neurogenesis
and naphyogenesis and then the system sort of has to use
that as another aspect of how it evolves over time.
But that was thought of,
or at least the way I was writing it originally,
it's sort of doing that in its own way.
You're not really involved in saying,
oh, I'm gonna help you do model selection,
but maybe if you encode priors,
that was the other aspect I had.
If you were encoding certain constraints,
you say, well, I just, I'm gonna play,
I'm gonna skip ahead for what evolution
would naturally walk, randomly walk you to and say,
these types of structures are invalid.
That would be like programming,
maybe structure from that perspective.
I don't know if this is making sense,
but I think it's a tricky topic
because I wasn't entirely sure what exactly two
was meant by programmability
because you have experience actually doing that.
So the answer is yes, it can be done from your perspective
and we would just be translating it to chimeric systems
or artificial systems
rather than it only just being like biological material.
I hope that makes sense.
Yeah, yeah, I mean, the kind of programmability
I had in mind, so just as an example,
we have these flatworms, these planaria,
and you can chop them into pieces
and every piece regrows a complete,
perfectly patterned little worm.
And you could ask the question,
how does it know how many heads to make?
And so it turns out that there's an electrical pattern
that sort of a body-wide electrical pattern
that dictates the number and the location of the head.
And the amazing thing about that substrate
is that if you change that pattern,
the tissue will hold it.
So we can change the pattern to say no,
two heads instead of one, and it holds.
And those worms in perpetuity forevermore,
despite their completely normal genetics,
will continue to regenerate as two-headed worms.
So it's a very minimal example of reprogrammability
because we don't have anything like complete control yet,
I think in the future, maybe we will,
but at the moment we don't.
But it is an example where the hardware
in an important sense, so the genetics are normal,
all this, there are no weird nanomaterials,
there's no genomic editing,
there are no synthetic biology circuits,
it's stock hardware, but because of this experience,
this physiological experience that it's had,
it now has a different pattern that it uses
as the sort of target morphology
of what it's going to do if it gets cut.
So that's the kind of thing,
the kind of plasticity that it has where
the material is basically the same,
but it has really a memory of a past event
and that memory guides how it behaves
in anatomical space in the future.
So that's the kind of thing I wanted to sort of explore
with respect to this framework.
And I don't think what you described is at odds
with what you would do with a mortal computer.
I mean, the idea is that is where the programmability
comes into play, you're kind of encoding that
and then seeing how the morphology
and the system evolve over time.
If you want the two-headed worm example,
I don't see any reason why that wouldn't translate
to artificial systems or maybe non-biological systems
if we are able to formulate what that morphology looks like.
I think the key is setting that up
and that's what Carl and I have at the very end of the paper
we talk about, well, for example, someone like me,
a computational neuroscientist, computer scientist,
I don't have access to Xenobots
or the biological material that I'd love to,
or organoids, right?
I really find those fascinating,
but maybe we could simulate them
