I can construct functions that solve
any computable function.
For example, if I want to construct something
that solves this transformation of information,
something that mimics this Boolean logic circuit,
I can do that with this term
that I divided across two lines.
So this function, it takes ones and zeros
represented with K and KI.
And if I mindlessly apply each one of these rules
step by step, I end up with the correct answer
that corresponds to the output
of this Boolean logic circuit.
Now, I want to emphasize that, again,
Boolean logic circuits are the weakest form of computation.
This is just an example of something
that a combinator logic can do,
but you can also implement more complex functions
that Boolean logic circuits can't compute.
So for example, you can have a recursion,
you can implement unbounded addition,
you can basically any program,
any algorithm that you can code up
in your favorite programming language,
you can also code it up in the language
of combinator logic, okay?
So it's a very powerful versatile computation language.
Now, how do I implement this with RNA?
Well, representing strings is trivial with RNA.
We even have a precedent for that in biology.
We know that biology uses RNA strands,
which are composed of an alphabet of nucleotides,
four symbols to represent strings of amino acids.
So it's using these codons,
we're using triplets of nucleotides.
So it's easy to imagine some kind of representation scheme
that maps motifs of nucleotides
to the symbols of combinator logic,
but implementing the rules of combinator logic
is where the challenge lies, not just representing.
So representing terms is easy.
We want to figure out what kind of rules
can we imagine happening at the molecular level
that correspond to the application rules
of combinator logic.
And we know that RNA strands are frequently edited.
One of the most common editing rules is splicing,
almost all RNA strands undergo splicing
where some part of the strand is excised
and the two ends are ligated together.
And what I want to do is try to imagine
how can we get editing rules like this,
very simple operations like this,
to map onto a set of application rules
that compose a universal computation system.
Now, the most challenging part of doing this
is parenthesis matching.
In combinator logic, if I want to execute
the application rules properly,
I have to know what a full term is.
So if I'm confronted with a open parenthesis symbol,
I have to be able to tell where the corresponding
closed parenthesis is to treat that whole stretch
of nucleotides as a single term, to maybe swap it,
delete it, or do whatever I want to do with it.
So if I show you this string and I ask you,
what's the corresponding closed parenthesis
to this open parenthesis?
You can't do it immediately.
You need to scan the string with your eyes,
keep track of the parenthesis depth,
adding for every open parenthesis,
subtracting for every closed parenthesis,
until you get to zero.
And then you can call this entire stretch of symbols
a single term and then do whatever you want to do with it.
Now, to imagine something like this happening
at the molecular level and natural,
and endogenously in cells,
that would be too much to expect
from an undiscovered molecule
because you'd have to traverse an RNA strand,
which already kind of looks like what a ribosome is doing.
And you also have to keep track of an arbitrary integer,
ads, track, there's a lot of things
that would need to go on to actually carry out
this operation that we do in our heads.
But fortunately for us,
RNA strands already solve this problem
of parenthesis matching.
The same way that DNA strands can come together
and form double helices,
RNA strands can also base pair with each other.
And sometimes the base pairing happens
within the same strand.
So it's two different segments of the same strand
can come together and form these base pairs.
And what results are these highly intricate
tree-like structures of a base paired segments
of the same RNA strand?
And now we can interpret these base pairings as parentheses.
So if I'm scanning an RNA strand,
when I approach one of these stems,
I can call this part an open parenthesis,
the content inside the stem, which is called the loop,
but you can call that the content,
and you can interpret that as the content
within the parentheses.
And then this other part of the stem
would be the closed parenthesis, all right?
And this example that I'm showing on the right
is an actually existing non-coding RNA strand.
So it doesn't code for proteins.
It's over 2,000 nucleotides long.
It's expressed in skin cells.
There's a debate whether it's really important or not,
but it's highly conserved.
There's kind of like a lot of mysteries
going on with non-protein coding RNAs.
So if we interpret secondary structure
as encoding a parenthesis structure,
now I can give you examples of what the operation rules
could actually look like in the RNA world.
So the applications are combinatorial logic.
I can show you how you can implement them
with very simple editing rules in RNA.
So here's one example that shows how to apply
the B combinator.
The rule for the B combinator is shown on the right
over here, and one important detail here
is that I'm using a different parenthesis convention
from what is typical in the field of combinatorial logic.
And combinatorial logic, usually they use
left parenthesis convention, meaning that if you write XYZ,
that means a parenthesis around X and Y,
and then a whole parenthesis around XY and Z.
But that makes, the difficulties with that,
if you wanna implement that with RNA, for some reason,
that I can get into a right associated parenthesis
suddenly magically kind of work out nicer
so that you only need cleavage and ligation
to apply these rules.
So okay, so putting that detail aside,
this is the application rule for B.
Now, let's walk through how this transformation here
corresponds to this transformation here.
First, I'm gonna show you how this RNA structure
corresponds to this term here.
So if we start from the three prime end,
you all can see my mouse, right?
Yes, okay.
So if we start from the three prime end,
this part can be interpreted as open parenthesis,
then open parenthesis, then open parenthesis.
And as I'm reading this, you can notice
how this corresponds to the symbols over here.
And then the B motif, which could be some hypothetical motif
or some codon or something that represents the B combinator.
And then we have X, and X could be anything.
It could include other stems inside itself,
and that's how you can get variables, basically,
nested parenthesis inside parenthesis.
So that's X, and then close parenthesis,
and then Y, and then close parenthesis,
and then Z, and then close parenthesis.
So X, Y, and Z could be anything.
And the structure on the right here
also corresponds to this.
So start from the three prime end, open, open, X, close,
open, Y, close, Z, close.
And I just read out this string over here.
To get from here to here, all you need to do
is a few cuts and ligations.
So you only need an enzyme to come in,
recognize the B motif,
and then perform cleavages and ligations
at fixed relative positions
to where it found the B motif.
And then you can get this, this structure on the right.
And then that enzyme could float off
and do something else.
And these are examples,
these are the transformations for two other combinators,
for the C combinator and the K combinator.
And again, all of these can be implemented
with only cleavage and ligation, locally defined.
Because we have this parenthesis structure,
the enzyme that comes in to carry out
these application rules doesn't really need to care
about detecting what counts as a full term,
where the matching parentheses are,
it's already there in the RNA structure.
And that makes it easy to imagine to already occur.
Okay.
Can I ask a quick question?
Of course.
So for the strings,
there is an intrinsic left to right ordering, right?
And I noticed that for the RNA strands,
it chose to go from the right strand.
