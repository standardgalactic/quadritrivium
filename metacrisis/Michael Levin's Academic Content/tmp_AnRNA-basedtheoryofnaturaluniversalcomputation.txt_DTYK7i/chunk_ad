Is there something intrinsic about the RNA strands
that sort of conveys this right to left ordering
or it just chose to do it that particular way?
So maybe I understood your question
if I didn't correct me,
but RNA strands, they have an intrinsic directionality
and people usually denote that with the three prime end
and the five prime end.
So there is a directionality in how you can traverse
an RNA strand.
In fact, that's how a single RNA strand
can uniquely encode a protein structure,
which is a string of amino acids
without accidentally coding for the reverse representation.
Is that was that your question or?
Yeah.
Yeah, that answers the question.
Thank you.
Yeah.
Yeah.
So there's no ambiguity in terms of what the string represents
because of directionality issues.
Okay.
So these three combinators by themselves,
they don't form a universal set.
So going back to this chart over here,
I've shown you B, C and K, but not W.
And the reason I didn't show W
is that I can't imagine W happening
with only cleavage and ligation
because W requires something more complex.
It requires duplicating a strand of arbitrary length.
So if you look at rule for W,
it says WXY equals XYY.
So there's a term that appears twice on the right side
and once on the left side.
And to imagine something like that happening naturally
in cells is kind of difficult.
You need some kind of enzyme to go in
and duplicate a strand of arbitrary length
and then reintegrate that back into the strand,
the template strand.
And we have things like RNA dependent RNA polymerase,
which uses an RNA strand as a template
to produce another RNA strand.
But first of all, we can't imagine a way for that
to systematically integrate that back to the same strand.
And also, RNA dependent RNA polymerase
doesn't exist across all life forms.
So, and I'm trying to imagine a system
that could exist across all life forms
and not be detected yet.
So fortunately, again, there's another trick
that can help us circumvent this need for the W combinator.
And to get to that, I wanna first introduce
how we can implement variables
and referencing with the system of computation.
So if we interpret parentheses as being represented
by these RNA duplexes,
I could imagine a system of addressable memory
within the cell,
where every variable is represented with an address sequence
and it can be referred to by its reference sequence.
So a strand that's representing a variable
might have the address sequence on its five prime end
and the content of that variable in the rest of the strand.
And then another strand could reference that sequence
with the reverse complementary sequence.
When these two strands come together,
they can base pair.
And with only a single cleavage and two ligations,
you can get the content of that variable nested
in parentheses exactly where it was referenced, okay?
So this creates a system where you can have
a shared addressable memory space within a single cell
where RNA strands can interact with one another,
they can refer to other strands
and they can even refer to copies of themselves.
And through that, you can implement recursion.
So if we have recursion,
we really don't need the W combinator
because one of the uses of a W combinator
is to basically define a function in terms of itself.
But if we already have a system that's capable of doing that,
we don't need the W combinator.
So this system slightly deviates from combinator logic
because it has explicit variable naming
and it has explicit references.
And to prove that this is a universal computation system,
I had to construct a proof
that you can simulate any Turing machine
with linear algorithm complexity
using that addressing and referencing system
and only these three combinators, okay?
So without the W combinator,
with that addressable memory system,
you can still achieve universal computation, okay?
So as an example of what you can compute with the system,
I constructed this RNA program
that solves unbounded addition.
It consists of two functions,
this A function and the B function.
B is recursive, it refers to itself
and A is recursive, it refers to itself
and also refers to B.
And to calculate something like six plus two,
you can do that through building this strand
which has some part of the strand
is representing the number two,
some part of the strand is representing the number six
in some contrived binary representation scheme.
And this strand refers to the program A.
So through those rules,
A gets integrated into this strand,
the operations, the BCK operations get applied,
they can be applied in any order.
So the order doesn't matter,
that's something, another cool thing
that kind of magically works out with combinator logic
where the order of operations doesn't matter
and the end result, so it can happen in parallel.
And at the end, you get a strand
that represents the number eight,
which requires four digits,
not the inputs were a two digit number,
a three digit number, but the number eight
is a four digit number, but that's fine,
it can deal with adding digits.
And if I simulate this,
just to show that it's efficient
in terms of its algorithmic complexity,
you can see that the number of operations
grow logarithmically with respect to the sum,
the final result, okay.
So this is just a demonstrate,
I don't think this is how addition actually happens in cells,
this is just a demonstrate that you can treat this system
as a programming language,
just like any other computer programming language.
You can construct any algorithm you want,
there's no like non-linear slowdowns
in terms of the number of operations.
So to summarize, DNA contains,
to summarize the theoretical model,
DNA contains a static library of functions
which are used for computation.
And sequences which encode these functions
are transcribed from DNA to RNA.
And a handful of cleavage and ligation rules
execute the steps of these functions.
I showed you three rules,
but you could imagine other sets of combinators
that execute different kinds of application rules
and also reach that level of computation power
that's needed for universal computation.
And a function can refer to any other function
including the copy of the same function
and this implements percussion.
Okay, so this is a theoretical model
and the question is,
does something like this happen in cells?
Obviously we don't know,
but the idea behind this model
was to inspire empirical investigation.
So now that we know that something like this can exist
and can be mediated through very simple rules
that could have got unattected,
now the goal is, okay,
can we try to find how nature actually does this?
And can we use some of the details in these kinds of models
to guide us in finding a universal computation system?
So those are the steps that I'm currently pursuing.
So one of the things I'm looking at is if this is right,
if RNA strands are being edited,
it should be possible to find traces
of these editing rules in sequencing data
if you're using the right kind of method for sequencing.
So what I'm looking at first is evidence
for swapped segments in RNA strands.
We already have ways to imagine how segments
within a standard can be deleted with things like splicing.
So that wouldn't be surprising,
but if we can find systematic rules
that determine how two parts of a strand
can show up in reversed order, that would be surprising.
And that might lead us to one of the,
maybe one of the operation rules
that implement a universal computation system.
So what I'm looking at right now
are high fidelity, full length reads,
sequence with packed bio from zebra finch brain tissue.
The data is publicly available,
it's published by the Jarvis lab here
at Rockefeller University.
And this example that I'm showing you on my screen
is one of the biggest examples
that I found in this dataset.
You can see that there are two reads to RNA strands
that contain sequences that are both
over a thousand nucleotides long,
