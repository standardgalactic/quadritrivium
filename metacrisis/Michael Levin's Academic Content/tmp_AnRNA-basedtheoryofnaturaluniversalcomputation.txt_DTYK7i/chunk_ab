dynamical systems are universal.
But the fact about this is that the kind of networks
and dynamical systems that have so far been
shown to be capable of universal computation,
they lack a certain feature called structural stability
that makes them impossible to build practically
or impossible to find to occur in nature.
And there's a really nice paper by Chris Moore that
explains this and the rationale behind why
structural stability is a criteria
for practical realizability.
So this opens a problem for us to solve.
Why haven't we found a universal computation system
where you've been able to imagine a universal computation
system in nature?
And maybe you might say, OK, that's fine.
Biology is messy.
And it gets by with what it can.
And it doesn't really require universal computation
for the kinds of tasks, the kinds of computation tasks
that it wants to perform.
But I find this idea difficult to accept,
especially given that it's very easy to accidentally stumble
upon universal computation.
So these are three examples, weighing tiles, Conway's Game
of Life, Wolfram's Rule 110.
And none of these systems were initially
intended to serve as a powerful computation system,
but they were later proven to be universal.
And back in the 1930s, also, the different kinds
of computation systems that the mathematicians came up
with, general recursion theory, lambda calculus,
and Turing's Automatic Machine, Post's Machine,
all of these ended up being the same.
It seems like there is a bucket of computation power
that's really easy to accidentally fall into.
And we use universal computation systems.
We use the von Neumann architecture
for things that don't really require universal computation.
We use them in toasters, vacuum cleaners.
We use them in appliances that could have been fine
with just analog computers.
So the way I think about it is it's easy to reach
and there are many, in terms of survival and reproduction,
there are many benefits to having a computation system.
So, and also we know that evolution is capable
of building highly complex systems
that abide to the principles of optics,
like your eye or mechanics.
So why not principles of computation?
So I just want to, for the rest of this talk,
let's just entertain the idea
that there is a natural universal computer,
but we just haven't found it yet.
What could it look like?
And I think the most promising place
to search for a universal computation system
is at the level of DNA and RNA with a polynucleotides.
And the reason for this, there's-
Can I ask a question first?
Go ahead, yeah.
Why do you say that physical computers
with an in biology are like,
they cannot be built, they are stable?
Yeah, okay, so there's this property
called structural stability.
Sorry, do you hear me?
I don't see my, okay.
There's this property called structural stability,
which some dynamical systems have it, some don't.
What it means is that the system we're talking about
has a non-zero measure in the space
of all dynamical systems,
meaning that there's a neighborhood
of close enough dynamical systems
that are homomorphic to the system,
meaning that the number of orbits,
the number of like attractor points,
all that is the same.
You can map the space of nearby dynamical systems
to that dynamical system.
If a system is not structurally stable,
that means you can't approximate it
as you get closer to it.
It's not like the closer you get,
the more it resembles the intended dynamics
of the system you're trying to construct.
So even if you construct a system
that's close to like with an error of one part per billion,
you still haven't created a system
that can be mapped onto the intended system.
And here we're talking about noise,
not during runtime, but noise in the parameters.
So you have to fine tune the parameters of your system
so much that there's zero noise.
There can't be any amount of noise.
Does that make sense?
Yeah, it makes sense.
And do you have any reference for this stuff
because I think it can be interesting?
Yeah, of course.
So there's this paper by Moore
and in that he references a bunch of other,
his own papers,
papers that have shown that universal computation
is possible with, let's say neural networks,
but all of those are structurally instable.
So if you, I can also send this paper to you
if you want after this.
No, I took a note, I will look it up later.
Of course, yeah, right.
Okay.
Okay, so I think the most promising place to search for it
is at the level of RNA and DNA.
And people recognize this going all the way back
to the 70s, but most of the previous work
have been attempts to build synthetic models of computation
using these molecules.
And some of these models are universal.
But the question that we're interested in
is not whether we can build
a universal computation system with RNA and DNA,
but whether nature has already done so.
Okay, so but what could it look like?
Of course, you can imagine
some very complex molecular machine
that looks something like a universal Turing machine
that operates on DNA,
but that sort of machine would have to be huge.
Ribosomes, which do the very simple task of translation
are 20 nanometers in diameter
and they're visible in electron microscopy.
So a universal Turing machine that would have to follow
some much more complex logic would have to be enormous.
So the question is,
can we imagine a molecular computation system
that doesn't require these kinds of extraordinarily complex
molecular machines and could have evaded detection until now?
And that's what I'm going to try to answer
with the model that I'll present.
The details of the model that I'm gonna present
are almost certainly incorrect,
but they're only meant as a proof of principle
that you can imagine something like this can exist
without being undetected.
And then we can say, all right,
let's try to look for similar systems
or some kind of in the space of all possible
computation systems that could have evaded detection.
Let's find what's going on in biology, all right?
Okay, so the model that I'm going to present to you
is all about bridging two fields,
already molecular biology and a combinatorial logic
for equivalently lambda calculus
and recognizing the parallels between the structures
in these two fields and how they're operated on, okay?
So I'm gonna present each one of these.
I'm gonna first present a combinatorial logic,
what it is, and then briefly how to use RNA biology
or how to imagine RNA biology could be
implementing a combinatorial logic.
So in combinatorial logic,
we have these entities called combinators.
And combinators are essentially just functions
of functions to functions.
They take other combinators as inputs and output a combinator.
For example, the I combinator is a function
that returns whatever it receives as input.
The K combinator can take two inputs
and return the first input and deletes the second input.
The C combinator takes three inputs,
returns the first applied to the third applied to the second.
So it basically swaps two of its inputs.
So let me just show you how this looks like in action
with two simple examples.
If I wanted to compute CKKI, I look up here,
what's the rule for C?
I have to swap the second and third input.
So if I do that here, I get KIK.
Now to compute this, to apply the left most combinator,
I look up, what's the rule here?
It says KXY equals X, I have to delete the second input.
So I just return the first inputs.
So this ends up being I.
Here's another example with parentheses
to show you that you can treat combinations of combinators
as a single entity, a single term.
Okay, so the really cool thing is
with only a handful of combinators,
a handful of these kinds of rules,
you can construct a system
that's capable of universal computation.
So here's a list of a bunch
of different primitive combinators
and two basic sets, two sets of combinator primitives
that achieve universal computation are BCK and W or SNK.
And these are the most popularized examples
of universal sets.
So with just these four combinators, BCW and K,
putting them together in the right way,
