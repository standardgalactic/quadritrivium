So let's consider this Cartesian product of three sets,
A times B times C,
but this time we're going to have C be a one element set
consisting of just a little C here, no C1, no C2,
just a little C.
So it's A times B times just the set containing C.
And it's the set of four ordered triples.
So we've ordered triples, not ordered pairs,
but there's only four of them.
So we do see that it is isomorphic to the A times B
that we saw several slides ago,
which had just four ordered pairs.
Now, if you were to ask a math student,
an undergraduate math student,
is this the Cartesian product A times B?
They would say no,
because the Cartesian product A times B
consists of ordered pairs, but this is ordered triples.
But by testing it, instead of just assuming
we know what it can do,
we can see that it does the job of the Cartesian product
just as well as the Cartesian product does.
And we can see that because we can factor A times B
through A times B times C here
to make everything be equal just like before.
So what this is gonna do
is we're gonna take an ordered pair,
let's say A2 comma B1,
our function H in this case will map it
to the order triple A2 comma B1 comma C,
and then we're gonna end up at A2
regardless of where we go
or regardless of which path we choose,
or we'll end up at B1
regardless of which path we choose on the right.
So this does in fact show that A times B times C here
is the Cartesian product.
It does the job of the Cartesian product optimally,
even though it doesn't look like it should.
Now if you're wondering, well, isn't this also optimal?
That's because it factors back the other way through H prime.
We can sort of take either path.
So these are isomorphic.
So they do the same job
because in a sense we can treat them as the same.
There's a unique isomorphism specifically.
We have one and only one way of transforming one
into the other so that they do the same job.
So we're indifferent which one we choose.
So C isn't helping us, but it's not hurting us either.
It's not costing anything.
And we would have only learned that
by actually testing the system with functions
instead of just assuming by looking inside of it
at the parts and pieces.
One other cool thing we can do
with the universal property of the product
is we can take that solution type that it constitutes
and map it onto a new body type.
So instead of looking at ordinary sets,
let's look at an ordered set.
So we've got our set consisting of X and Y and Z
and these relationships mean X is less than or equal to Y
and X is less than or equal to Z.
You could think of this like biologically
as like descendancy.
So Y and Z are the parents and X is their child.
So what if X has a child?
So let's say W descends from X and also from Y and Z
then X is the greatest lower bound.
It's the biggest thing that is smaller than Y and Z.
So this is a very important concept in math.
You're constantly talking about bounds
and greatest lower bounds when you're doing mathematics.
So we've defined a very important concept here.
Now how does this relate to universal properties?
Well, let's take this diagram and turn it upside down
and you can see it's the exact same diagram
as the universal property of the product of sets.
I haven't labeled the arrows here
because the labeling doesn't matter
but otherwise it's the exact same diagram.
The forcing here is given by the fact
that in an ordered set there's only one way
to be a descendant of something else.
You can't have like two different kinds of child.
There's just one way to be a child.
So if we can take our universal property of the product
and we can, you know, when we're trying to solve
like what is the greatest lower bound?
What does that mean?
We don't need to, you know, reinvent the wheel.
We can import our solution type from another body type
from just plain sets into ordered sets.
And we find out that the greatest lower bound
is in fact the product in partially ordered sets.
So what I take from this is that math
doesn't make specific solutions to specific environments.
It makes a problem solving morphisms
where morphisms is a generic term for these kinds of arrows.
So that takes us through the end of universal properties.
Appreciate how bearing through that.
I know it can be kind of dense and tedious.
And now we're going to move on to adjoint functors.
We'll try to get through this
and see if we have time for timeless agency as well.
So adjoint functors are a very important concept
in mathematics that relates to optimal reconstruction.
So if you're an organism trying to survive
in your environment, you need to have an internal model
of your environment.
So you're recreating your environment inside yourself
but you have limited sense data
and limited computing power.
So you can't perfectly recreate your environment
instead you want to optimally recreate your environment.
And adjoint functors also relate to being lazy
and we'll see that being a lazy or leased action
ends up being related to optimality.
So you want to be lazy, you want to be optimal.
We'll see how those end up being highly related
to each other.
So what is an adjoint functor?
An adjoint functor is a pair of relationships
one of which forgets information
and the other reconstructs what was forgotten.
Once you forget something
you can't necessarily remember it perfectly.
So we settle for optimally reconstructing it instead.
We'll work through a specific example
of building something lazily.
We'll see that building something lazily
lets us build it optimally as well.
So we're going to build something called a monoid.
So a monoid is a fancy word for something very familiar
which is a set combined with an operation.
And operation is a way of combining two elements of the set
to create another element of the set.
And in particular, what's important is a given set
can have many operations.
So let's take our set to be the natural numbers.
Well, one, combine them to create nine
or we can have multiplication take two and seven
combine them to make 14
or we can have maximum as the operation
a bit different from a normal arithmetic operation
but we can define two and seven
we can find them to create seven
as the maximum of those two.
So we're combining things to create things
so that's an operation
or we can even do something like concatenation
and take two and seven and combine them to make 27
which is kind of silly
and we can use zero as our identity.
So this is a monoid
it's a very familiar concept
a set combined with an operation.
Excuse me, let me drink some water.
So now we're going to look at using this idea of a monoid
we're going to ask how do we turn a monoid
into a set in a lazy way?
How do we turn a set into a monoid in a lazy way?
We're going to do this with what are called
free and forgetful functors.
So a functor is just a fancy word
for a generalization of a function
just think of it as a function
for all intents and purposes
that's going to be okay for this talk.
So our forgetful functor
we're going to have our monoid
our monoid is going to be our set of natural numbers
along with some operation
I'm not going to say what the operation is
some arbitrary operation
it doesn't matter
which we'll just denote with an asterisk
our forgetful functor asks
what's the laziest way to turn our monoid
into just a set
just a regular set with no operation?
Well, the easiest way to do that
is just to forget about the operation
just throw the operation in the trash
and just keep the set
so take the natural numbers combined with the operation
and turn it into just the natural numbers.
So that's the easy part
that's not too interesting.
Now let's ask how do we reconstruct our monoid?
So we're, we just have our natural numbers
we threw our operation away
we don't remember what it was
but we do want to turn this back into a monoid.
What's the laziest way we can do that?
And that's going to be with our free functor.
So we're going to construct what's called a free
or lazy monoid on the natural numbers.
The way we're going to do that
