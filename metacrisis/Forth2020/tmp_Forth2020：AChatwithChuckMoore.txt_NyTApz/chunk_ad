Who wants to reduce bugs? You want to get the bags out?
Yeah.
For instance, what you really need is just an IP stack, an internet or Wi-Fi interface.
And once you have those, you're pretty much good to go.
Sorry.
The hard part is the Wi-Fi interface due to proprietary firmware, though.
Wow. Yes, exactly. That's why I went to the 144, rather than try to interface with the
existing world. I wanted to try something different, something standalone. Now, the 144
could drive a GPU. I don't know how to do that. I don't even know how to find out how to do that,
if it could be done. It can be done, of course. But whether you can figure out how
is a completely different question. And I've given up on that.
Chuck, here's a challenge. If you were to develop the 144 to do bitcoining,
everybody will stop using the GPU processors, and the sales of the 144 would go through the roof.
You'd be making money over money, because the people out there wouldn't realize just how fast
the 144s could process the hash tables.
Quite right. But among other things, it takes money to develop such an ambitious application,
and we don't have any money. I have an open question for you, Chuck,
if I may. First of all, let me say that I'm very honored to speak to you today.
I mean, fourth for me was a fantastic concept since the 80s when I was a student. So definitely
it's a wonderful experience to speak to you. Now, for the question, it's related to IoT.
Since fourth is by design, very efficient in terms of power consumption, in terms of processing
efficiency, I'm surprised that fourth is not more commonly used for old developments based on
IoT, where of course energy consumption and responsiveness and real-time aspects are absolutely
critical. What do you think about this? I think that's an absolutely wonderful application area.
And Greeneray's projects, which are trying to address that, the fact that we use very little
energy is an o-brainer. But we haven't found the killer app.
If you will, next week I have to go and explain to a professor at University of Wyoming
why the fact that we don't run standard high-level languages in a pair of streaming glasses
is not a killer of our technology. The point is, the reason why people don't use
our chips is that we don't have these giant, fat libraries of crappy code, which they can
glue together, which is all they know how to do. They don't know how to write code,
they don't know how to program in a story. No, that's the first. I've got a question for Chuck.
I may. Yeah, please go ahead, Ken. It's a historical question, Chuck. When you made the
transition from software to hardware in the very early 1980s, did you prototype any of the early
fourth hardware using, I guess, TTL at that time? Before you moved to the gate array of the
Novix, did you prototype any of that stuff? Thanks.
Yes, I did. I did build a prototype of a fourth computer in TTL, or CMOS chips,
which was sort of a proof-and-principle. But then I moved to simulating the
gate array as a more helpful design tool in fourth. So the fourth hardware prototype
wasn't really helpful, didn't go anywhere. It only helped to convince some other people to
support the gate array. Okay, thanks. That's quite fascinating. So I guess you were on the
transition between building prototypes and hardware to simulating them. By 1981-82, I guess we had
16-bit PCs and simulation became a reality. Yeah.
So I see Gerard. Yeah, hello, everybody.
No, now you're muted. Now you are muted.
So we just had a couple of words and then your mic went off.
No, no, no, no, no, no. No sound. We can't hear you. It just broke. Yeah.
Aha, now comes the mic.
No sound. Can you hear me? Yeah, yeah. Yes, sounds good. No, no, no, no.
Not now. That's strange. It was just, again, just a word. Maybe you can log off and log back in
of the Zoom, like drop if you're having problems with the audio. Sometimes that fixes it. Yeah.
You may get a message to reinstall the Zoom software like it happened to me. Reinstall Windows.
Yeah, whatever. I want to, I put on the chat something that Chuck will love to see.
I will put this on the chat. Probably you have seen some of you. I am watching,
I started watching yesterday on Netflix, the billion dollar code battle of over Google Earth
and a German company called Der Ravition. It's absolute amazing, a fantastic film.
And this has to do with this killer app we were speaking before. This is very interesting to watch.
Thank you. I've got a question for Chuck.
Yeah, I'm just curious about the changes in fourth from the sort of the classic fourth
from the early 80s through to Kalapur and some of your observations and reasons for
the kinds of the way forth has gone from the classic fourth to the fourth you're using now.
What were some of the reasons that drove some of those design decisions in the more recent versions
that you're using now? Wow. Fourth was originally an interpreter.
And I had to learn how to make it into a compiler.
And that was largely a question of confidence.
The model I used was a Bellgall developed at Stanford.
And I was a graduate student at Stanford. And there's this team of half a dozen people
who wrote a Bellgall compiler. And I said, well, if they can do it, I can do it.
And so I wrote a standalone fourth. That was the first one.
The criteria was to make it simple because I couldn't do anything complicated.
And I think all of my later developments of fourth implementations
were to try to make it simpler.
Originally, fourth had a threaded dictionary. And that hung on for a long time,
perhaps until UHD fourth. Now, I don't have a threaded dictionary. I have a dictionary broken
into pieces. Each piece, there's the each array. One array contains the words. Another array contains
parameters. Another array contains the code address. This lets me search the name array
with this hardware instruction. But really, nothing has changed. I'm amazed that the original
concept, structure of fourth, with this dictionary and stack, has remained for 50 years without
significant alteration. At the moment, I don't know how to make it any simpler.
And of course, the hardware has changed. It was originally memory constrained. And now it's not.
It's an amount of memory. Fourth doesn't know how to use infinite amounts of memory.
It's just not necessary. So I don't know where to go from here.
I have a question, which is not about technology only. I mean, and as Christian said, I mean,
you are free mind, right? What is the topic? I mean, considering the news, considering the
where the world is going at the moment, what is the topic that makes you passionate about
at the moment? Could be fourth, could be AI or could be something not about technology?
AI goes back to my early days at the, what do they call them? The early neural nets.
Deceptron. I'm of two minds.
You can see this played out in the full, full self driving cars. Do you use artificial intelligence
or do you use pre-programmed decision making? I'm a pre-programmed decision maker. So I
that's the way I do things. If AI becomes magic, as it has in the case of go and chess,
I'll be disturbed because we can't understand how it does it. If we get AI in the form of a mobile
robot or a mainframe in the cloud, that we don't know how it works.
I don't know that we've accomplished anything. You've got the oracles of ancient Greece
who could answer your questions. How is that different if an AI is answering your questions?
But I don't know what side to come down on. I think I will stick with my deterministic clock
and perhaps try to get precision time protocol implemented or something like that.
Chuck, this is Don. We're working on this FPJ-based fourth. I'm very curious about your
comments on the dictionary because we haven't implemented the outer interpreter in the dictionary
quite yet, the compiler part. You said that you have three arrays. You have the CFA's,
you have the strings, the word strings, the name of the words, and then you have the data.
What's the data?
Because the data is usually on the stack, right? In the case of a constant, it would be the value
of a constant. Oh, okay. It's an array. Well, it's an array. You can put anything in it you want.
The address of a variable, the value of a constant, I think those are the only two I actually use.
But you have to have a data field. In the case of a code reference, the data field
merely indicates that it is a code reference.
But this has led to the most efficient implementation of all these things that I've ever had.
I have a second question. You know I'm in the space business now. I'm working on space robotics.
The fourth has a very rich history in space. Your RTX especially. I know that talking with Dr.
Ting in 2010, the Goddard Space Laboratory had him do some work implementing fourth for one of their
missions. Can you talk a little bit about the history of fourth in space?
I programmed reconnaissance satellite once.
But I had very little to do with it because the NC-4000 was the prototype of the RTX.
And yet I had no contact with it at all. Nobody ever asked me a question. Nobody ever paid me
money to do anything. So that whole space application went on without my participation.
So most of the space stuff was done by 4th Inc. and Elizabeth Rathers people.
Well, they were kind of the central focus. John Hayes and Hopkins University.
Yeah, Johns Hopkins University crew.
Well, they were good people. What was his name?
Prove that fourth was provable language, which was an issue at the time. Prove it was correct.
Although I don't know why that is interesting because it's pretty obvious it's correct.
Well, what's very interesting right now that I found being in the space business
is FPGAs are naturally radiation immune. So they're very much favored in space because the geometry
is much larger than the modern microprocessors. So a radiation hit is not going to impact an FPGA.
And I think this is a huge opportunity for 4th. If you can imagine 100 robots working out in Pluto
assembling something and you have this low speed data link and you're going to send a C binary
blob up there every time you want to change code. 4th is interactive. You just make your core words,
deferred words, and you update as necessary using text. I think it's...
That's the same thing applies to the over the year updates that Tesla uses.
I don't know how they do it, but I doubt they use a 4th model.
Okay, we have a queue of people that raise their hands to ask questions. So Dimitri is next as far as I know.
Yeah, I put my hand up after Don. My question for Chuck is, okay, I've got a few finite lists.
What would you say are the most important things about 4th that someone learning the language
needs to know? I'm interested in those who are learning it today. I myself am quite young.
I've learned 4th in the past couple years. So I was wondering what your thoughts on this?
The first thing you have to learn is how to handle the stack.
Conventional programmers don't think in stack terms. And there is a transition that takes
of maybe a couple years before you really know what to put on the stack and what not to put on
the stack and how to keep the stack clean. The processor used in green arrays chips
has a circular stack. So you can put things on it, leave it there, and it will be forgotten
in an optimal way. You don't ever have to keep the stack clean. And that's what I do in UHD 4th
also. I have a circular stack. It's a little more expensive, but it's a hard lot, a lot easier.
Beyond that, you've got to learn to factor. Take a problem, break it into pieces, give names to each
line of code so that you can combine them into a higher level structure. That's not unique to 4th.
That's a kind of good programmer practice that no one uses. C has made it conventional to use
very large subroutines with lots of parameters. And 4th has very small subroutines with
almost no parameters. You have to make that mental transition.
How many things do you recommend leaving on the stack at a time? How many things in the stack
should a word consume? Is there any rough guide on that? One or two? One or two, yeah. The GA144 has
eight deep stacks. It doesn't have 16 deep stacks, whatever. But my UHD 4th has eight deep stacks.
That's all you need. Yeah, I think on the FPGA processor I'm working on with Don,
yeah, we've implemented a circular stacks. And I think it's 32 at the moment, but I thought 16 might
be a reasonable depth for 4th programming. So that's reassuring to know. Since others have
their hand up, I'll ask my next question, which is, what was it like working with 4th compared to
Fortran or Algol? What was it about Fortran or Algol that made you think I need to develop the
language 4th? Interactivity. As others have said, in Fortran, you have to recompile the entire
application. I worked in Fortran. In fact, an early version of 4th was coded in Fortran.
And it was a pain to have to recompile the whole thing. It took half an hour maybe.
And I wanted something that was easier to patch. Now, there are two flavors of 4th that I've seen.
One is where you have a large body, a large dictionary with many things in it,
and different vocabularies. The other is which you know, noble vocabularies, and you recompile
apps on top of each other. That's the way my UHD 4th works. One of the most common apps I use
is the editor. It overlays whatever other app might be active, because clearly it isn't
interesting any longer. And it compiles a new version of a block. And then I can recompile
that block to make the new app. So my compile times are zero. My edit times are trivial.
And the application is tiny. So I have a lot of tiny apps instead of one huge one.
Wow. So that really is fascinating. And I've tried out using blocks, I think,
as implemented in the ESP32 4th. And I found it very, very handy.
My final question which follows on from the previous one is, do you think that 4th still has
these advantages that you mentioned? Do you think it still has these advantages
over languages today like C and Java and Python?
Absolutely. I haven't seen any progress in the conventional language world since
Fortran. All these languages are infix notation. They are not interactive.
They are huge. Nothing has changed in the last 50 years.
What would you say is wrong with infix notation?
It's a perversion of notation and concept and implementation. In high school,
people have taught infix notation as algebra. And it is a pain because it is unnatural.
HP calculators are much more efficient in keystrokes than an infix calculator.
It's just a path that society has taken that I think is suboptimal.
Yeah. I would agree with you. And that concludes my questions, by the way. Yeah,
I would agree because I had a bug recently at work which was caused by an infix operator
that I got the precedence for it wrong. And so it was evaluating it completely incorrectly and
I was thinking, if I was using 4th, this would not happen. And it's amazing how often people run
into these things. You see problems on Facebook sometimes where someone says, solve this math
equation. And it's because it's confusing. These rules are confusing. They're good for mathematics,
but they're not actually as intuitive as people think they are. They're only intuitive because
we're taught them. But yeah, that's it for me. Thank you for answering my questions, Chuck. And
I will continue learning. Sure. Yeah. Thanks. So next with the right hand is James Norris.
Please go ahead.
We can't hear you, James. There you go. You hear me? Yeah. No.
I was wondering about the x86 hand coding that you're doing. Would you consider using
a similar or why don't you do it? A similar is just another layer of software that gets in your way.
What I have is the hex op codes with subscripts, which I will put a number on the stack.
And the subscript indicates how many bytes that will take in the object code.
And stringing these numbers together gives you a program. Now, this is totally inappropriate
for large programs. This is insane. But for a one line fourth definition, it's trivial.
Would you be interested? I wrote a fourth base x86 assembler if you ever want to do anything bigger.
And my second question is, what about using forth as a, right now they're coming out with
Rust trying to do this. They figured out that a lot of program languages have problems like
