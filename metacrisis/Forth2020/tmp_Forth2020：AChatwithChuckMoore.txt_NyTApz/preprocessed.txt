Okay, we want to see who is who is going to start you. Okay, we have written some questions for him.
My first question is, we don't see Chuck much online, and I'm very interested in what he's doing now and is he still working on and with Ford.
Yes, of course.
Can you hear me.
Yes.
Yes.
Okay.
Wonderful version of color force, which I use almost every day.
I'm not doing anything impressive with it, just messing around with computers.
Basically, I'm retired.
I spend a lot of time exercising, trying to stay alive.
I eat a lot of food.
Very pleasant, very pleasant life. And I certainly don't want to be under any kind of pressure to produce things.
So I'm basically not.
I have a number of applications in color force that I enjoy.
They are emphatically not portable.
Forced to me I agree with Ulrich is a personal language, and I'm doing it my way.
And I would be happy to share ideas.
But no one would be interested in my fourth code.
I think we all interested in everyone's ideas and especially yours.
I would love to see it.
Sometimes maybe I can show it to you but I'm not set up to do that now.
What's the computer are you doing it at the moment.
Sorry.
Are you doing it on the GA 144.
Not a computer, a special computer maybe.
It's on a PC.
I've got a 4k display.
And it's all tuned to 4k.
Although I have the parameterized so I could display it on 2k.
It doesn't work very well.
That means it's small screen.
55 inch.
55 inch 4k display.
It's a PCL television.
It works just fine.
You only do force on it.
So other things.
I browse the web and YouTube.
That is my fourth display.
It's very nice to meet you.
We have got an old club here.
From 1979 about.
Okay.
We are rather active still with a few members, maybe 13 members are active.
And more than a hundred members are there, but not here normally.
And they're all very happy to use force because it's very flexible.
And it's very basic. You can do very smart things with a few.
A little bit of pop.
It's always been my favorite language.
I'm impressed.
I'm very happy.
I'm impressed with how many people are interested.
I gave up long ago.
Trying to promote force.
Yes, it's a hard sell.
And I would just rather use it myself.
I can understand that it's really a hard sell.
You can write beautiful code with it.
Most people only do a segment of relations.
I believe.
And that doesn't help.
Beautiful code is right.
It's.
Back in the back in the old days.
I thought that people would write their own programs.
And it forced to be a great vehicle for doing that.
And it would appear that.
A thousand people.
Out of.
8 billion.
Are willing to write their own programs.
Yes.
Most of the people like to copy and paste only.
Question for check more.
I really wonder what your most used application does.
The application I use.
The application you mostly use.
It's a clock.
I have a, I have a screen full of numbers.
The date and time.
Julian day.
Moonrise.
I don't know what the number of days till.
Things like they like savings time.
All of the.
Time questions that I asked myself.
Have got the answers.
And it's a pretty display.
Sounds nice. Thank you.
One thing I have done.
Is a new character set.
You may be aware that I've done many, many different character sets.
This one is the prettiest.
And simplest.
And it has a unique property.
Normally what I have been doing.
Would be I would generate.
A character.
As a raster.
I would have.
What 48.
Symbols representing the.
Characters.
Stored.
In rain Ram.
It finally occurred to me that.
Computers are much faster than they need to be.
Instead of storing the.
Characters I store the code that generates the characters.
And when I want to display one, I can do it.
Computers are pretty fast to do that.
With those perceptible delay.
And it saves memory.
It adds flexibility. You can edit your characters on the fly.
And you can invest.
A fair amount of work in calculating a character because it doesn't matter.
So I've got pretty characters.
Available on demand.
I encourage people to design their own characters.
It's fun.
It's easy.
And it gives you another customizable.
And it's very, very nice.
So there's something that is called display post script on,
on Mac OS 10, for example, or I don't know whether it's called like this.
So this is something like display force.
So a force program runs when you display text.
Because it draws the characters.
Yep.
Yeah, great.
I like that.
I can draw characters sometimes when I can.
They're very pretty in 4k.
I can draw very large characters.
They're all scalable.
And some curves.
Chuck, this is Don.
You gave a talk, I think it was last fourth day where you were writing
directly to the memory buffer.
That's what this system you're describing is you're writing directly to the memory
buffer.
Yeah.
Oh, yes.
You have to have a.
Kind of speed.
If you go through the windows.
Interface.
It's much too slow.
Hi, Chuck.
This is Carlos here.
Hi.
I'm Carlos.
I'm a member of the planetary networking special interest group.
I know you have been.
For many years interested in space and space exploration.
Have you been working at some point.
About the late tolerant networking.
And interfacing with force.
What is called.
I don't understand.
DTN is a protocol.
That use environmental protocol encapsulates the TCP IP or LTP like
like the transport protocol to connect.
With the space it's using the international space station and also in
much rovers.
And.
I.
I've been looking to different languages to interface with.
DTN.
We are working with Pinto surfing this in this project about interplanetary
internet.
And I would like to know if you have been interested at some point in this
kind of communication.
I haven't been able to get on to the internet.
I'm indeed interested, but I've done nothing in that direction.
In fact, I haven't even been able to get onto the internet.
The.
Tools that windows provides are.
Opaid to me.
And I've just been forced to deal with things locally.
Thank you.
Hi, Chuck. My name is Bob Flanders. It's a pleasure to meet you, sir.
Yeah.
Somebody just brought up the original list things.
Hi, Bob. Nice. Nice to meet you. Nice to see you in the group.
Nice to meet you too, Peter. It's been a, it's been a long time coming.
There's kind of an interesting little story about what's on the screen on
2011 or thereabouts.
It's been a pleasure to talk to ask if he had any old code.
For the IBM 1130, which was the first computer he wrote for thought
of fully working forth on this. I understand it. In fact, the name of,
of four would have been F O U R T H had it not been for the 1130s
limited file system, which only allows five characters.
So it had to be named F L R K H to be a file on the 1130.
Just kind of fun and has led to the idea of it being something that we go
forth.
So anyway, in 2011, I sent a message to him asking if he had any old code
for the, to be 1130 and he said, yeah, I'll rummage around and,
and he'll take a look and see what he has. And he found this.
And he sent it to me, but I missed the message or something.
Well, a few years later, I guess it was 2017 or so.
Carl Clanch, who is a fellow IBM 1130 enthusiast,
sent me a message that he had spoken with Chuck.
And Chuck had said, I think I send it to the sky Flanders and
he'd since gotten rid of the papers and so I rummaged around
in my Gmail and I found it.
And it turns out it's either a free version one or pretty close to
version one copy of the code and the basic kernel,
the, you know, the assemble level words and then the additional words on
it, but, and I've had a tiny amount of contribution to helping Carl
get it working on the IBM 1130 emulator.
And Carl actually has a working IBM 1130.
And he's, he's gotten it working.
One critical word that we probably would all be completely lost without
had it not had that wasn't there in this version, which was period.
So he couldn't print out the top of the stack.
I think that the top of the stack may have only been shown in the
indicator on the, on the 1130 for the, for the accumulator.
And it was a very interesting, a very interesting bit of work to, to
put it together and get it running.
There were, there were some typos or some not typos, but some, some hand
written notes on the code and notice some things that needed to be
adjusted a little bit, maybe also we made typos, putting it in.
And there is, there's actually floating about out there a version one
fourth of the IBM 1130.
The way I became interested in fourth personally was I was hired by
MCI telecommunications.
Like 1986 or thereabouts.
And I had no fourth experience, but a friend recommended me.
And I came in and the guy said, well, listen, let's, let's give you a
try.
First thing I want you to do is write a word that shows a timestamp.
So I fumbled around and wrote a timestamp.
Then the next thing he said is I want you to implement drivers for a
multi port serial card.
And I wrote that and then he said, okay, you got the job.
And I ended up working for eight years.
And I ended up using LMI fourth under some DOS extender.
To implement a system that ran on.
At the end, I think it was nearly a thousand.
What we're called site controllers.
And they are put in their co located at the various MCI facilities and
talk to digital cross connects and extended.
Extender sup frame monitoring units.
And it would send all the information back to a central computer,
which would then use its interface support to do things like,
you know, a customer call up, say, Hey, I need a,
a circuit from Washington DC to Los Angeles.
And they would go into the digital cross connects hook up the,
hook up the T one, get it all running.
And then, you know, go out and get it delivered to the customer.
And then when they're working with their endpoints down to whatever
provision is necessary,
and it was very cool and interesting system. I haven't done much with
fourth sense.
But I'm always like, I'm always looking backwards, like, oh,
I want to do this.
I want to work on like, I'm writing 1130.
Emulator and things like that. So it's always an interest me too.
To do things with older current,
not necessarily New Yorker.
But I program and C-Shark and do a lot of sequel stuff.
Anyway, pleasure to meet you, sir.
Thank you so much.
Forth is brilliant.
It was brilliant.
It is brilliant, and shall continue to be better.
Take care.
Well, I can add a little bit to the 1130 story.
It isn't as if I was sitting in an office working with the 1130.
The 1130 was on the abandoned production floor of a textile mill.
It was a huge room about 200 feet long and 100 feet wide.
And the exact center of it was this 1130, which had been delivered by IBM.
And nobody knew what to do with it, except me.
And so that was the environment in which Forth was invented.
It was challenging in many ways.
Yeah.
It was the 1130.
If there hadn't been 1130 in my high school, this was about 1972,
and I started using one.
And at that time, I had no understanding of what I was doing.
Then, for the 1130, I probably would never have gotten into computing.
But that started my career.
The first minute computer.
Yeah. Yeah.
I call it my first personal computer.
Hi, Chuck.
Hey.
We've met a couple of times and many of us here will remember the August 1980 edition
of Bytes, where you introduced the language to a much wider audience.
But that was the time that you felt that the software had been done and you are now looking
towards the hardware.
Could you tell us a bit about how you made that transition from software to hardware
and you moved towards the Novics period of Forth history?
Yes, I did feel the software had been perfected in the context of Forth.
What I was doing at the time was putting Forth on many different computers and interfacing
it with many different devices.
And this, of course, is very easy to do.
That's why Forth exists.
But the interfacing with many different devices got very frustrating because these devices
were badly designed.
The interface I had to go through was bizarre, baroque.
And I got kind of tired of doing that.
And I said, well, I could design a better interface.
I could design a better computer.
Now, people didn't do that at the time.
This was the business of someone else.
So it took really a leap of faith to abandon software for hardware.
And I actually didn't because I had to develop the software to design the hardware.
But thereafter, my software efforts went in the hardware direction and simulators and
layout tools.
And it was very rewarding.
My hardware worked.
And it worked much better than anyone expected or even would admit.
And I'm still doing that in the sense of the Greeneray's multi-processor chips.
They are incredibly simple, incredibly effective, and totally unpopular.
So fourth hardware is just as unacceptable as fourth software.
Yep, and that's absolutely fine.
Some people like fourth, like everybody here, I would imagine.
Other people don't understand.
Hi, it's Howard Oakford here.
We've met a couple of times, too.
I'd just like to say thank you.
You've made my career in programming much more fun than it would ever have been otherwise.
May your fathom flowers bloom.
Thank you.
G'day Chuck.
I met you once back in 1988, back in the year when I was struggling symposium here.
But I've been using fourth since the early 80s.
I started the big project with that, and I've been using it ever since.
And yes, a lot of people won't admit that it works so well.
That's true, it was a hardware and software.
And it also makes the hardware a lot simpler.
We don't have to use any complicated hardware.
And that was my original fourth board I did up with the Rockwell chips, et cetera.
And then I ended up into a module, a little credit card size module.
But this is the mid-80s, and that was OK for the mid-80s.
And now I use the P2 multi-core processor with 64 smart pins, et cetera.
And so I do a lot of better control.
But this is a question I really wanted to ask you.
You just mentioned the greener rates.
It's got all these processes on there.
I've got the propeller, parallax propeller processor.
We've got eight cogs, well, eight cores.
It has hub RAM, so it shares everything.
And every one of those cores can access all the IO equally.
But when I look at the greener rates, I can't figure out how I can use it.
You're saying it's an effective processor.
What has it proved to be effective in, you know, really?
How can I use it for general embedded control and smart stuff?
That's a good question.
It has 144 computers.
They aren't exactly cores.
They're independent computers.
They communicate with one another.
And the ones around the edge communicate with pins.
So if you want to control a pin, you have to use the computer, which is attached to it.
And that computer pretty much can't do anything except run that pin
and communicate with its neighbors.
So you end up building a little network of computers, not 144,
but maybe half a dozen that all cooperate and communicate in running the protocol on that pin.
It's a fun thing to do.
It's totally different than any other computer where you would just run a serial processor.
Your whole attention is in coordinating the efforts of as many independent computers as you want.
I don't think I've done an application with more than about a few dozen computers.
So Chuck, so in talking about applications, if you had to showcase an application,
say, look how well it does this.
And I'm bearing in mind too that what you said already,
there's a bit of work setting it all up for those cores to communicate with one another.
Or, you know, those little secret years to communicate with one another.
I'm familiar with the whole architecture.
But what would you say?
Which, you know, you could hold up an application and say, man, you know, this does it so well.
Well, one obvious applications through and forth to.
You can use some of the some of the computers to drive a display.
You can use some of the computers to read a keyboard.
And you can put them together to run forth.
I haven't done that.
I've never got around to doing that, although I got close.
We've got each computer has 64 words of RAM.
And one of the computers interfaces with a flash memory.
So there's infinite, infinite amounts of data available.
Another set of three computers can communicate with DRAM.
So what you want to do is set up a system whereby.
You read code from flash, you store it in DRAM.
And you read it back from DRAM and do whatever you want to do.
So so with with, you know, so, you know, I'm wondering why you haven't got a PC with it yet.
Come on, you know, you can do it.
But the thing is, OK, so I use chips, you know.
So that one's got 512 K of RAM and plus all the 4K RAM on each CPU, et cetera.
And so it's really easy to make it work.
And if and I talk to an IO and I can even instruct the IO to do something by itself.
It's a smart IO.
It has everything built into it.
I, you know, I keep racking my brains looking at the green arrays.
And I can't think, you know, like, even if I could get it to do something,
it'll be a lot of work.
You know, it'll be fun, but it'll be a lot of work to do it.
And you mentioned memory displays, for instance, said, well,
there are a lot of more effective ways of doing displays.
But I can do a VGA or even a HD display from the RAM on this one.
But I have to add bolt on all that RAM onto the green arrays.
You know, I'd really love to see a green arrays one that was had less CPUs
had a bit more memory on each one and more access to the IO.
And it was like, that would be really great.
You know, 64 CPUs.
Forget about 144.
Give me 64.
And, you know, as you said, you don't need to use many.
We'd love to do that.
We've had plans for doing that, but we've never been able to make such a chip.
Right.
And we'd have to integrate someone else's memory onto our chip, and that isn't easy to do.
Yeah.
Well, yeah, I appreciate it.
I just wanted to ask you that question because it's like it's the one thing that bugs me.
It's like these fourth chips are going right from the early days.
I know VIX and all that.
And they're all really great.
And then, you know, like I've got 21, I've got the Shabooms and everything like that.
But I can't figure out how to use a green array.
So I'd really love to see some application or even forget about application notes,
but just by showcase, something to showcase that particular chip power was used really well.
Well, the biggest advantage of the 144 is it doesn't use any energy.
So if you have to put a lot of energy in to make it work, that's the trouble.
Yeah.
Yeah.
Right.
Thanks, Chuck.
Yeah.
No, I appreciate it.
It's all very much all your work.
We love fourth.
The other question, I just wanted to ask, nothing to do with technical things,
but we often talk about how is it that we can really promote fourth?
You know, it's just that mindset.
You know, you've had way more experience with encountering the opposition
and with people accepting fourth.
And it's like, well, I had fourth built into the chip and silicon on this particular P2 chip.
And that was a hard task to get that done at the time.
And but fourth is a dirty word.
You know, people just don't like, companies don't like mentioning it.
Do you see anything that would help break down that barrier?
A killer app.
We've been looking for a killer app for 50 years and haven't found one.
No.
Well, absolutely.
See, you know, I think I think most of the fourth use, you know,
I've always used fourth on micros embedded.
And and so it's built into airports and roadways and all kinds of vending machines,
anything, you know.
And so they're all out there.
People just don't see it, but it keeps going 24 seven.
And it's also my my prototype language that I use.
You probably want a prototype.
This, you know, people are used to using breadboards or fourth.
You can move stuff around like that.
You can fritz all you like with fourth.
And it's very quick.
So, you know, I have a project now where they are saying, hey, you know,
do it with Arduino, you know, C and everything else like this.
And I'm thinking they can ask me, but I'm still doing it my way
because, you know, I can get it done.
But yeah, but it's just that opposition to it.
And I don't know if there's anything we often talk about it on our group.
And fourth, 2020, how we can get young people interested.
It's not going to be a killer app.
I think it's going to be the easy use, how they're using it.
Make it's how to how to make it use fourth, you know, can use fourth easily.
Straight away, they say.
I have a question for Chuck.
Chuck, was the sun force in bios or open force open?
How was the name open OS?
Open boot.
Open boot.
Open boot from San Celeros.
Yes, exactly.
Open boot.
Was this not the fourth killer app because this was installed in so many computers
and also on the one laptop per child.
I know this was a really big, a really big installation of force.
Yes, that's true.
But bios is such a obscure application that it didn't attract any any any any attention.
It was a technical trial.
The attention that open boot attracted was attempts to replace it with conventional software.
That didn't work.
Fourth didn't work to because there was not an industry behind it.
That's always been a problem.
We lack large scale support.
Yeah, Intel came along and and killed open firmware open not open boot open firmware.
And yeah, Intel was responsible for UEFI and that killed open firmware.
But fourth really doesn't need corporate support to prosper.
It's it's an individual thing rather than a collective.
As you did check with your being a raised talk on you did a discussion of that video
how you got the 144 chipset to drive the video.
I was very impressed that you don't have generic video hardware driving the video
in your demonstration.
You had the green erase chips, each programming the timing.
And that was significant of how you got the green erase chip to do video.
That wouldn't be normally required just to produce an output for people to see.
In applications which don't really need consoles.
If you manipulating data, you work the data and you produce the storage of the of the
output for the for later display for people to see.
And so the video display was just just a really fantastic ability.
That the chip array could actually program and the speed.
I think it was absolutely significant was the.
The power savings that your chipset that nobody else could do.
And it was a lot of fun to program that DGA.
And it was it wasn't easy timing was a big problem.
And it was just fun.
I would say so too.
It's quite unique that you've got this hardware and you're interfacing the green
arrays into that hardware.
So there's another incredible example of what the green erase chipset can do.
It can bang anything.
It's got it's got the speed.
And this is with a an obsolete geometry 180 nanometers.
This is this is abandoned competitive with with the
10 nanometer geometries.
You could equate that the green arrays chipset to be a risk processor.
Where everybody's going to assist type processes with multi with multi instructions.
What you can do on a risk processor like the green arrays.
It's so much quicker.
It may need a little bit of effort to do the stuff that needs to be done.
But clearly the number of instructions to do the work supersedes the performance that any
of the standard processes can work with.
And at the cost of power, which was so much cheaper on.
I've got to jump in here a little bit about programming these machines.
Chuck's machines.
I was one of the first Novix programmers.
And one of the early green arrays series of processors.
Jeff Fox and I, at the beginning, we're doing our darned this to pack as much code as we could
into those 64 words of Ram over years.
Now we found that the smaller amount of code, the smallest amount that you can put into a node.
Let's them use the least power because each node is cooperating, sending messages between them.
And when it isn't running, it isn't, it's only got leakage power going.
So look for the earlier speaker about getting into a green arrays programming mind mode.
Look at the examples that are on the green arrays website.
You'll get a lot of that.
One of the things that I did sort of is a Skunkworks program with a good friend of mine, Bill
Minch, who was also an early programmer for the, I think it was the 24 processor chip,
was to implement a virtual machine to execute E fourth.
And we put Bill's, Bill was the originator of E fourth and Ting has taken off with it in assembly
language. We did it all in high level. And we built a virtual machine using, I think it was
three or four of the nodes to execute E fourth op codes, eight bit op codes directly.
And that has facilitated actually, it's been moved and Greg Bailey's version of poly fourth,
fourth things code is now running virtually on the, on the green arrays chip.
And all of the development that's happening currently is being done in standard fourth.
You do not need to know the details, just like every other processor. So take a look at those
application write ups on the green arrays website.
For example, if I may, 10 words of code forms an ethernet Manchester decoder and receiver
converting the legally signals on the twisted pairs into bits going to the next node.
Wow.
You know, I listened to all this and I think, wow, this is the stuff you guys are doing are
credible little chunks, right? And then there's a question of how could something like fourth
be paid? How do we take forth to the next level? How do we get it to, you know, push it into the
future? I'll tell you something, you know, I watched this one guy on YouTube, his name is Jeff
Geerling, and he's trying to deal with taking a video card and getting it to run in a PCIe single
lane on some of the new Raspberry Pi compute boards. If you could do something like build
a fourth driven video card with an open interface that could be, you know, could be
added to the drivers and such could be added to that would have some kind of a standard interface
that's like, you know, we'll work with OpenGL or I don't know what the current,
the modern of the current video standards are. If you could build something like that,
that would then sit in like a PCIe one, one lane PCIe slot, you sell a billion of those because
they repeat the CM4, the Raspberry Pi CM4s, things are taking, are becoming incredibly popular,
build small like, you know, systems with a bunch of slots and stuff like that for multiple
CPUs and then having a, you know, a PCIe card or something like that sitting in there to show,
have a video. It seems like a busy building. Bob, thank you. Track is busy building a thing
called HD fourth from his last, from his last discussion. And that seems so significant what
he's working with on an HDMI interface. It'd be interesting to see further development that
he's working on, on his HD fourth. The HD fourth has evolved into what I call UHD fourth.
Even better. For the 4K display. Wow. It's running on a PC.
A x86.
It's unique characteristic is that a lot of the code is an assembler. Well,
is in machine language. And there's no assembler. There are hex op codes for the x86 instructions.
Now, I had to memorize those op codes.
But it was as easy to memorize the op codes as it was to memorize the assembler code.
And it gives you beautiful versatility and efficiency. Completely unportable.
But that's, that's what I use. I call it color fourth, but that's, that's versions I'm using now.
And it is the nicest fourth I've ever had because it gives me the closest interface with the hardware.
On the other hand, in the old days, when you wanted to interface to a chip
or a board, that chip or board was documented. And you could really download the spec sheet and,
and work with it. Nowadays, there's no documentation. The best I have found is in Windows.
But Windows is incredibly complex, incredibly obscure, badly designed,
almost impossible to work with. And I work with it when I must. But it has turned me off trying to
interface with the larger world. As I said before, I've never been able to figure out how to get on
the internet. The world has changed. And I'm afraid it's changed in such a way as to disadvantage us.
The, well, calls hackers. You're supposed to sign on
to the corporate vision of computers. And if you don't, or can't do that, you're being left behind.
That perhaps some of you know, Werner Vinge's science fiction novels. He has one called
Oh, Fire in the Sky, something like that. In which the problem of
buggy, enormous software was mentioned. The spaceships of that era were programmed in some
obscure language that nobody could really master. And it was determined that you should
improve rewrite the software. So that that was simple, clean, bug free. And entire planets
attempted to do so. They could not reproduce all of the obscure bugs in the existing software.
So it was not useful on existing spaceships. And the whole project led to
enormous costs, effort and failure. That would equate in today's view with trying to reprogram
windows, say, or Linux in forth. It probably can't be done. It certainly is not
sound like much fun, because you have to reproduce the bugs.
Who wants to reduce bugs? You want to get the bags out?
Yeah.
For instance, what you really need is just an IP stack, an internet or Wi-Fi interface.
And once you have those, you're pretty much good to go.
Sorry.
The hard part is the Wi-Fi interface due to proprietary firmware, though.
Wow. Yes, exactly. That's why I went to the 144, rather than try to interface with the
existing world. I wanted to try something different, something standalone. Now, the 144
could drive a GPU. I don't know how to do that. I don't even know how to find out how to do that,
if it could be done. It can be done, of course. But whether you can figure out how
is a completely different question. And I've given up on that.
Chuck, here's a challenge. If you were to develop the 144 to do bitcoining,
everybody will stop using the GPU processors, and the sales of the 144 would go through the roof.
You'd be making money over money, because the people out there wouldn't realize just how fast
the 144s could process the hash tables.
Quite right. But among other things, it takes money to develop such an ambitious application,
and we don't have any money. I have an open question for you, Chuck,
if I may. First of all, let me say that I'm very honored to speak to you today.
I mean, fourth for me was a fantastic concept since the 80s when I was a student. So definitely
it's a wonderful experience to speak to you. Now, for the question, it's related to IoT.
Since fourth is by design, very efficient in terms of power consumption, in terms of processing
efficiency, I'm surprised that fourth is not more commonly used for old developments based on
IoT, where of course energy consumption and responsiveness and real-time aspects are absolutely
critical. What do you think about this? I think that's an absolutely wonderful application area.
And Greeneray's projects, which are trying to address that, the fact that we use very little
energy is an o-brainer. But we haven't found the killer app.
If you will, next week I have to go and explain to a professor at University of Wyoming
why the fact that we don't run standard high-level languages in a pair of streaming glasses
is not a killer of our technology. The point is, the reason why people don't use
our chips is that we don't have these giant, fat libraries of crappy code, which they can
glue together, which is all they know how to do. They don't know how to write code,
they don't know how to program in a story. No, that's the first. I've got a question for Chuck.
I may. Yeah, please go ahead, Ken. It's a historical question, Chuck. When you made the
transition from software to hardware in the very early 1980s, did you prototype any of the early
fourth hardware using, I guess, TTL at that time? Before you moved to the gate array of the
Novix, did you prototype any of that stuff? Thanks.
Yes, I did. I did build a prototype of a fourth computer in TTL, or CMOS chips,
which was sort of a proof-and-principle. But then I moved to simulating the
gate array as a more helpful design tool in fourth. So the fourth hardware prototype
wasn't really helpful, didn't go anywhere. It only helped to convince some other people to
support the gate array. Okay, thanks. That's quite fascinating. So I guess you were on the
transition between building prototypes and hardware to simulating them. By 1981-82, I guess we had
16-bit PCs and simulation became a reality. Yeah.
So I see Gerard. Yeah, hello, everybody.
No, now you're muted. Now you are muted.
So we just had a couple of words and then your mic went off.
No, no, no, no, no, no. No sound. We can't hear you. It just broke. Yeah.
Aha, now comes the mic.
No sound. Can you hear me? Yeah, yeah. Yes, sounds good. No, no, no, no.
Not now. That's strange. It was just, again, just a word. Maybe you can log off and log back in
of the Zoom, like drop if you're having problems with the audio. Sometimes that fixes it. Yeah.
You may get a message to reinstall the Zoom software like it happened to me. Reinstall Windows.
Yeah, whatever. I want to, I put on the chat something that Chuck will love to see.
I will put this on the chat. Probably you have seen some of you. I am watching,
I started watching yesterday on Netflix, the billion dollar code battle of over Google Earth
and a German company called Der Ravition. It's absolute amazing, a fantastic film.
And this has to do with this killer app we were speaking before. This is very interesting to watch.
Thank you. I've got a question for Chuck.
Yeah, I'm just curious about the changes in fourth from the sort of the classic fourth
from the early 80s through to Kalapur and some of your observations and reasons for
the kinds of the way forth has gone from the classic fourth to the fourth you're using now.
What were some of the reasons that drove some of those design decisions in the more recent versions
that you're using now? Wow. Fourth was originally an interpreter.
And I had to learn how to make it into a compiler.
And that was largely a question of confidence.
The model I used was a Bellgall developed at Stanford.
And I was a graduate student at Stanford. And there's this team of half a dozen people
who wrote a Bellgall compiler. And I said, well, if they can do it, I can do it.
And so I wrote a standalone fourth. That was the first one.
The criteria was to make it simple because I couldn't do anything complicated.
And I think all of my later developments of fourth implementations
were to try to make it simpler.
Originally, fourth had a threaded dictionary. And that hung on for a long time,
perhaps until UHD fourth. Now, I don't have a threaded dictionary. I have a dictionary broken
into pieces. Each piece, there's the each array. One array contains the words. Another array contains
parameters. Another array contains the code address. This lets me search the name array
with this hardware instruction. But really, nothing has changed. I'm amazed that the original
concept, structure of fourth, with this dictionary and stack, has remained for 50 years without
significant alteration. At the moment, I don't know how to make it any simpler.
And of course, the hardware has changed. It was originally memory constrained. And now it's not.
It's an amount of memory. Fourth doesn't know how to use infinite amounts of memory.
It's just not necessary. So I don't know where to go from here.
I have a question, which is not about technology only. I mean, and as Christian said, I mean,
you are free mind, right? What is the topic? I mean, considering the news, considering the
where the world is going at the moment, what is the topic that makes you passionate about
at the moment? Could be fourth, could be AI or could be something not about technology?
AI goes back to my early days at the, what do they call them? The early neural nets.
Deceptron. I'm of two minds.
You can see this played out in the full, full self driving cars. Do you use artificial intelligence
or do you use pre-programmed decision making? I'm a pre-programmed decision maker. So I
that's the way I do things. If AI becomes magic, as it has in the case of go and chess,
I'll be disturbed because we can't understand how it does it. If we get AI in the form of a mobile
robot or a mainframe in the cloud, that we don't know how it works.
I don't know that we've accomplished anything. You've got the oracles of ancient Greece
who could answer your questions. How is that different if an AI is answering your questions?
But I don't know what side to come down on. I think I will stick with my deterministic clock
and perhaps try to get precision time protocol implemented or something like that.
Chuck, this is Don. We're working on this FPJ-based fourth. I'm very curious about your
comments on the dictionary because we haven't implemented the outer interpreter in the dictionary
quite yet, the compiler part. You said that you have three arrays. You have the CFA's,
you have the strings, the word strings, the name of the words, and then you have the data.
What's the data?
Because the data is usually on the stack, right? In the case of a constant, it would be the value
of a constant. Oh, okay. It's an array. Well, it's an array. You can put anything in it you want.
The address of a variable, the value of a constant, I think those are the only two I actually use.
But you have to have a data field. In the case of a code reference, the data field
merely indicates that it is a code reference.
But this has led to the most efficient implementation of all these things that I've ever had.
I have a second question. You know I'm in the space business now. I'm working on space robotics.
The fourth has a very rich history in space. Your RTX especially. I know that talking with Dr.
Ting in 2010, the Goddard Space Laboratory had him do some work implementing fourth for one of their
missions. Can you talk a little bit about the history of fourth in space?
I programmed reconnaissance satellite once.
But I had very little to do with it because the NC-4000 was the prototype of the RTX.
And yet I had no contact with it at all. Nobody ever asked me a question. Nobody ever paid me
money to do anything. So that whole space application went on without my participation.
So most of the space stuff was done by 4th Inc. and Elizabeth Rathers people.
Well, they were kind of the central focus. John Hayes and Hopkins University.
Yeah, Johns Hopkins University crew.
Well, they were good people. What was his name?
Prove that fourth was provable language, which was an issue at the time. Prove it was correct.
Although I don't know why that is interesting because it's pretty obvious it's correct.
Well, what's very interesting right now that I found being in the space business
is FPGAs are naturally radiation immune. So they're very much favored in space because the geometry
is much larger than the modern microprocessors. So a radiation hit is not going to impact an FPGA.
And I think this is a huge opportunity for 4th. If you can imagine 100 robots working out in Pluto
assembling something and you have this low speed data link and you're going to send a C binary
blob up there every time you want to change code. 4th is interactive. You just make your core words,
deferred words, and you update as necessary using text. I think it's...
That's the same thing applies to the over the year updates that Tesla uses.
I don't know how they do it, but I doubt they use a 4th model.
Okay, we have a queue of people that raise their hands to ask questions. So Dimitri is next as far as I know.
Yeah, I put my hand up after Don. My question for Chuck is, okay, I've got a few finite lists.
What would you say are the most important things about 4th that someone learning the language
needs to know? I'm interested in those who are learning it today. I myself am quite young.
I've learned 4th in the past couple years. So I was wondering what your thoughts on this?
The first thing you have to learn is how to handle the stack.
Conventional programmers don't think in stack terms. And there is a transition that takes
of maybe a couple years before you really know what to put on the stack and what not to put on
the stack and how to keep the stack clean. The processor used in green arrays chips
has a circular stack. So you can put things on it, leave it there, and it will be forgotten
in an optimal way. You don't ever have to keep the stack clean. And that's what I do in UHD 4th
also. I have a circular stack. It's a little more expensive, but it's a hard lot, a lot easier.
Beyond that, you've got to learn to factor. Take a problem, break it into pieces, give names to each
line of code so that you can combine them into a higher level structure. That's not unique to 4th.
That's a kind of good programmer practice that no one uses. C has made it conventional to use
very large subroutines with lots of parameters. And 4th has very small subroutines with
almost no parameters. You have to make that mental transition.
How many things do you recommend leaving on the stack at a time? How many things in the stack
should a word consume? Is there any rough guide on that? One or two? One or two, yeah. The GA144 has
eight deep stacks. It doesn't have 16 deep stacks, whatever. But my UHD 4th has eight deep stacks.
That's all you need. Yeah, I think on the FPGA processor I'm working on with Don,
yeah, we've implemented a circular stacks. And I think it's 32 at the moment, but I thought 16 might
be a reasonable depth for 4th programming. So that's reassuring to know. Since others have
their hand up, I'll ask my next question, which is, what was it like working with 4th compared to
Fortran or Algol? What was it about Fortran or Algol that made you think I need to develop the
language 4th? Interactivity. As others have said, in Fortran, you have to recompile the entire
application. I worked in Fortran. In fact, an early version of 4th was coded in Fortran.
And it was a pain to have to recompile the whole thing. It took half an hour maybe.
And I wanted something that was easier to patch. Now, there are two flavors of 4th that I've seen.
One is where you have a large body, a large dictionary with many things in it,
and different vocabularies. The other is which you know, noble vocabularies, and you recompile
apps on top of each other. That's the way my UHD 4th works. One of the most common apps I use
is the editor. It overlays whatever other app might be active, because clearly it isn't
interesting any longer. And it compiles a new version of a block. And then I can recompile
that block to make the new app. So my compile times are zero. My edit times are trivial.
And the application is tiny. So I have a lot of tiny apps instead of one huge one.
Wow. So that really is fascinating. And I've tried out using blocks, I think,
as implemented in the ESP32 4th. And I found it very, very handy.
My final question which follows on from the previous one is, do you think that 4th still has
these advantages that you mentioned? Do you think it still has these advantages
over languages today like C and Java and Python?
Absolutely. I haven't seen any progress in the conventional language world since
Fortran. All these languages are infix notation. They are not interactive.
They are huge. Nothing has changed in the last 50 years.
What would you say is wrong with infix notation?
It's a perversion of notation and concept and implementation. In high school,
people have taught infix notation as algebra. And it is a pain because it is unnatural.
HP calculators are much more efficient in keystrokes than an infix calculator.
It's just a path that society has taken that I think is suboptimal.
Yeah. I would agree with you. And that concludes my questions, by the way. Yeah,
I would agree because I had a bug recently at work which was caused by an infix operator
that I got the precedence for it wrong. And so it was evaluating it completely incorrectly and
I was thinking, if I was using 4th, this would not happen. And it's amazing how often people run
into these things. You see problems on Facebook sometimes where someone says, solve this math
equation. And it's because it's confusing. These rules are confusing. They're good for mathematics,
but they're not actually as intuitive as people think they are. They're only intuitive because
we're taught them. But yeah, that's it for me. Thank you for answering my questions, Chuck. And
I will continue learning. Sure. Yeah. Thanks. So next with the right hand is James Norris.
Please go ahead.
We can't hear you, James. There you go. You hear me? Yeah. No.
I was wondering about the x86 hand coding that you're doing. Would you consider using
a similar or why don't you do it? A similar is just another layer of software that gets in your way.
What I have is the hex op codes with subscripts, which I will put a number on the stack.
And the subscript indicates how many bytes that will take in the object code.
And stringing these numbers together gives you a program. Now, this is totally inappropriate
for large programs. This is insane. But for a one line fourth definition, it's trivial.
Would you be interested? I wrote a fourth base x86 assembler if you ever want to do anything bigger.
And my second question is, what about using forth as a, right now they're coming out with
Rust trying to do this. They figured out that a lot of program languages have problems like
C++ has memory management problems and things like that. And it causes all these expensive bugs
for like Microsoft and stuff. And they spend millions of dollars trying to fix bugs in their
operating system caused by the programming language. So now they're trying to come up with
Rust as a magic solution. What about forth? You could take forth that's really simple.
You could put in all that error checking that doesn't have. What do you think about that?
Yes, he certainly could. Fourth doesn't have to be a standalone language. It can be a module
in an operating system. It just doesn't seem to strike people's fancy.
That was all my questions. Okay. Thank you. So Gerald's next try.
Okay. Next try. Can you hear me now? Yeah.
Very sorry about the blur before. So Chuck, I wanted to ask just because you also mentioned
before that not a lot has changed in force regarding to the basic structure of having
a directory and having a stack. But I actually recall having a discussion with you where you
mentioned investigating multiple stacks and using locals even. Did you do any further research
or has this just been a short excursion for you? No, that doesn't lead anywhere useful.
What I have done in UHD forth, I've taken advantage of all the registers that the x86 has.
And you could almost say that you could make a forth
register based instead of stack based. And I explored that a bit and abandoned it.
And why? The stack is absolutely essential. You might not use it all the time.
You might take advantage of the registers. But if you don't have a stack on which you can pass
parameters, you're crippled. And why did you give up on having even more stacks?
I don't use floating point arithmetic. So there's no reason to have a floating point stack.
And I have never found a use for any other kind of stack.
Okay. Thank you.
Right. Thanks. So our next question comes from Greg.
Yeah. Hello, Chuck. It's a pleasure to meet you. Actually, I was curious about
something that was said earlier. You mentioned as a general rule,
just limit the number of things on the stack to maybe just two. And so just as a possible example,
if I were to develop a word that is to draw a rectangle and it takes two points,
top left, bottom right, let's say, as parameters, that would be four arguments on the stack.
So I might think, well, maybe I should start thinking about structures. So maybe I'll create
a structure that's a point object. And so I could put two points on the stack. And
that's only a couple of things placed on the stack. But now I have a structure.
That structure would be, I think in fourth would be typically global, which some people might
look at scans that and say it's a global variable. I could also think of it in terms of, well,
maybe I could create an object called a rectangle and the rectangle might have methods to set its
points and to display itself or whatever I decide makes sense. And that I think fits well with the
noun verb structure that fourth, I think, encourages object action type of thing, machine
on, machine off sort of thing. Just curious as to what your thoughts would be on how you might
structure and your thoughts, a problem like that. And what are your thoughts on structures and objects
and that level of abstraction, in addition to just the basics of what fourth gives you?
That's one way of doing things. What I do
is I have a word at that sets the cursor, takes two parameters, and specifies the location on the
screen. And then I have another word called rectangle. It has the dimensions of the rectangle
that I'm going to draw at the cursor. So I've broken it into two pieces instead of having one
large piece. And I can use the word at for triangles as well, or for circles.
Now, in the case of a triangle, it's a problem because you've got three points.
And I use a structure for that. A circle only has one parameter, the radius,
so it's on stack. So to generalize and say everything should be structures
is not right. And everything should be in a stack is not right either. You have to be flexible.
What are your thoughts on objects, having a variety of...
I created an object in fourth called the month. And this object had the starting point in the year
and the number of days or something like that. This was backed back very early.
That's the only object I've ever done. And it was useless. I had much better ways of doing months now.
So I think object-oriented programming is the mistake. There are not enough instances
of the object to make worth the generalization.
Interesting. Thank you for your thoughts on that. Appreciate it.
That's why they call it oops.
Okay, Francis, please ask your questions.
Hi, Chuck. Can you hear me?
Yes. Okay. Hi, Chuck. It's an honor to speak with you
following for a while. And I just wanted to thank you for this gift to us.
I was wondering if you could speak a little bit about the motivations for the circuit
simulation software you wrote, its performance, and its current status.
Say again. So I was wondering if you could speak a little bit about your motivations
for the circuit simulation software you used to do the layout and electrical simulations,
its performance, and its current status?
Yeah. That is one of my favorite applications. It's one of the things that I've spent
most time on. And I think I've done the best job of.
There's two aspects to it. One is the circuit logic description.
And the other is the layout. If you are laying out a circuit board, or whether you're laying out
a chip, basically the same problem with different geometries.
And what I have learned to do is, in both cases,
I do the layout. And from the layout, I derive the circuit, an array of transistors and interconnects.
It's extremely efficient, extremely intuitive, pretty simple to implement,
and gives wonderfully complete results.
I've done a lot of circuit boards, but I've done even more chips. And the chip layout,
well, conventionally, one has a logic description of gates that are connected,
then you derive the layout. And I do it the other way. The layout is predominant,
and the function of the layout is determined from it.
This is a strange side effect. There is no need to do a validation proving that the layout accurately
reflects the circuit. The layout is the circuit, and is by definition correct.
And it's a lot of fun. I enjoy working with rectangles and layouts.
Unfortunately, again, just like the world doesn't let you interface with
chips or boards or GPUs, the world doesn't let you interface with chips any longer.
You have to give it a GDS approved layout, which they will validate before they
construct a layout which vaguely resembles the one that you worked from.
It's a frustrating technological development. I would love to have a chip making machine,
something that will generate a prototype chip in a desktop environment.
But the world prefers to have billion-dollar fabs.
I asked that because I was in my daily job. I do this as a maker and a hobbyist of the
cyber. In my daily job, I do chip design and process development for one of the big
semiconductor companies, and this is a cool interest of mine. I thought I would ask about that.
Just another question. What are the most interesting one or two applications you've seen
in forth from others that you didn't see coming? The applications in forth think those.
You can go to their website for a list, but they've done communication networks, device handlers.
I did a Hollywood robot camera on cement making plants.
I would love to see a self-driving car in forth. That's a heavy thing though. As soon as you get
into applications that risk human lives, it's a whole new game, and I've never done one of those.
And just a last question. In hindsight, has anything done differently with the gods to forth
in setting it up, developing it, all that? Looking back after all these news.
No. In hindsight, I don't know that I've done particularly well,
but I don't know that there's anything I would have or could have done differently.
In back in what 1970 or so,
forth in a sense was competing with Microsoft. Not directly, but conceptually.
And if we at forth think had developed an operating system,
we could have competed with Microsoft. But we didn't. We couldn't.
And I'm perhaps glad we didn't. I'm much happier with where we are now than where with Microsoft
is now. Microsoft has to be compatible with the exception maybe of Windows 11
with everything they have ever done before. And that is a horrible burden to bear.
Fourth, as it stands,
well, forth is free to reinvent the wheel. And I think that is a marvelous concept
no one should ever be afraid to reinvent the wheel. And we do it every day.
Thank you, Chuck. Thank you.
Yeah, thanks. And Howard, your turn. And please open the mic.
Hi, Chuck. I've already had a turn chatting to you. But one more question about one's
compliments. The whole used to be very popular a long time ago. The IP Internet Protocol
uses a one's compliments checksum. And it has some interesting properties. I have a feeling
that it's a really good way to go. And I observed that you use one's compliments in the color
fourth. And I just wanted to hear your opinion. Do you think that the world went wrong when it
moved over to two's compliments? No, I worried about this. One of the main frames I
programmed early on was one's compliment arithmetic. But two's is much more convenient.
And it doesn't cost anything in hardware. So two's compliment is definitely the way to go.
Yeah, I can understand that point of view. The thing I like about one's compliment is that
you've got this extra state in the system. In normal two's compliments, you've got zero,
and you've got everything else. And in one's compliment, you've got plus zero and minus zero.
And it strikes me that it's very useful to have this extra
state that can be used so you can have a value as either zero, not zero, or not set,
or some such. And I think this whole idea of having three states in a value rather than two,
it brings it closer to the optimal number of symbols required to transmit
data, which I believe is E, somebody proved a long time ago. So it's closer to three than two.
Anyway, it's just, I think it's a good idea. You're talking about having code?
Yeah, yeah, yeah. Yes. The introduction on computer file about that two days ago,
about having codes, and the transition of following the edges of the square to get to that.
Okay, thanks for the link. I'll look into that. Okay, thanks, Chuck.
Okay. Right. So Bob, you raised your hand. Hello. I'm raising my other hand.
Okay, I have one thing I'm wondering when I heard you, you programmed a mainframe that was
one's compliment. What mainframe was that? You remember?
That's why I didn't name it.
Could it have been a Sperry Univac?
No, it might have been the...
Who needs this?
Was it when you did that at the regs?
The first Supercomputer, right? I can't come up with the name of it.
Oh, Kray? Or us?
Kray, or maybe one of its input terminals, something like that.
Cool. Second question. You mentioned compatibility, and how Microsoft has maintained
compatibility. And then, of course, you've just mentioned mainframes. I was thinking
ZVM, which is the current version of OSM-MBS, which is OSM-BT, which is OS360, has maintained
compatibility across since the 1960s when it first started. And evidently, you could compile
a program today on ZVM, ZOS, rather, I'm sorry, ZOS mainframe in a run.
And it just, you know, it was interesting that you'd mentioned compatibility.
IBM has had it maintained that for all these years.
Compatibility guarantees there won't be any progress.
Yes. What is the smallest fourth you've run across? What's the minimum?
Like, if you could, I don't know exactly, I can quantify it, but like the smallest amount of
memory, smallest amount of stack space. What is that? What would that be?
The smallest one I've done was called CM fourth, for the Novix, I think it was.
At fourth, I think we had micro-fourth and mini-fourth, which explored the range of having a small
kernel and everything else compiled. E-fourth does that, I believe.
But I've heard references to these, some micro-computer fourths that had very small kernels.
I would say a kernel should not be more than 4k. If you get it down to 1k, that would be nice.
Okay. Cool. You mentioned in talking, and I forget who it was, but you mentioned that the
two parameters stack, but you mentioned the stack that's only deep. Is that for like
as many levels as deep as you go, or is it deep? I bet we thought deep and so often small.
I would think in terms of the circular stack with eight elements, so that you could put as many
things on the stack as you want, but you only have access to eight of them. Now, for the
nice circuit tracing algorithms, I've needed to stack thousands deep, because as you trace
the circuit, you're recursing and recursing and recursing. That's a whole different concept
that I would have a software stack for. The hardware stack can be very small. Four is too small.
Eight is small. 16 is plenty. Okay. Cool. Two more. One is, did you know that
the current .NET implementation of languages produced something called IL, and IL is a fourth
like stack language? So they actually compile C into a fourth like language. I don't know if
you've known that. I would say no, because I haven't understood what you've said. Okay. Well,
.NET is the kind of the, I'm sorry, Microsoft's answer to Java, C sharp is Microsoft's answer
to Java. It's become very popular. It's actually very nice language. If you're writing that kind
of software, but when it compiles, it compiles down into something called intermediate language,
which is actually a very fourth like language. It's a stack based language. I thought that was,
I thought that was interesting. I didn't know if you'd heard of that. Well, all
infects languages have to compile into a stack. So, yeah. But the interesting thing is this,
it doesn't compile, it doesn't compile to a native. It compiles to IL. IL gets compiled to native.
An intermediate language. Yes. That is,
to me, that is grossly inefficient. Why not write an intermediate language? And
the last thing is that you've talked about assembler and you don't even know the
x86 op codes and such like that. In the 1130 assembler, you wrote an assembler. I mean,
in 1134, you wrote an assembler so you could write 1130 instructions in a fourth like notation.
I mean, there was right there right at the beginning. It was very cool.
Not only 1130, all of my computers had assembly words. And I now think that that was a waste of
time. It was hard to figure out how to construct the words. It was hard to remember how they were
constructed. It was inefficient to implement. The xop codes are on any computer are far the
simplest way of implementing it. It's interesting you're saying that because it was just like,
that was when we were looking at the code. That was one of the most intense parts of the code.
Starting to understand what you're doing here. And then like saying, wow, we thought we thought
brilliant. So it was fun. It was, it was clever. But it was at least as difficult as the xcodes.
Yeah. Okay, that's it. I'm out of here. At least I'm calling you. Thank you for your time.
Okay, thanks, Bob. Our next questions come from Jan Bramkamp or Jan Brankamp. I don't know.
If my microphone is working. Yes. Okay. So my question is, you've already rented about infix
notation and how it doesn't compose. And what do you think about a prefix notation like lisp?
I'm sorry. I lost my earpiece. Sorry. Let me repeat that. You've already given us your opinion on
infix notation and how bad it composes. What's your opinion on prefix notation languages like lisp?
Um, they made an unfortunate choice. I believe the human brain works on postfix.
You, you, you accept data, you store it in your short term stack, and then you operate on it.
You don't prefix things.
Okay. Short answer. And are you satisfied with it?
Yes, I got my answer. Okay. Okay. Thanks, Jan. Next is Anton Erte. Anton, please go ahead.
Oh, maybe your mic volume has been turned down. So that's what happened to Jared. So we can't hear you.
Mic selection, maybe. Answer.
No, no, no. No, no, no. No, and now not again. So, yeah, yeah, no, I didn't speak.
Okay. Go ahead. All right. So the question is, what is your take on state smart words? I think you
have four systems, and then you eliminated them. And I'm not sure if you have them in
the reason systems. I don't think so. But can you talk a little bit about them? And yeah.
Yeah, I think maybe that's an area in which forth has made some progress, or at least my fourth.
And UHD forth is basically color force. And different words have different colors.
Now, the state smart words would have different colors for different states.
For instance, the color white means execute immediately. The color green means compile.
And those are only only two states that I need. But I do have to be aware in programming.
For instance, a conditional word like if or then is an immediate word and must be in white.
If I have an if in green, it means compile a reference to if for future use. And that's
basically what the state smart words did. You didn't have to be aware that they were
which state they were in. They knew. But now I must be aware
to distinguish green from white. And that is a programming challenge. Sometimes I get it wrong.
Thank you. Yeah, interesting. Yeah, Don, please. Hello, Chuck again.
How many items or how deep do you think we should build the return stack in our FPJ fourth?
32 bit fourth. That shouldn't matter.
I would go with eight. Eight, okay. I think the return stack
and the data stack need not be the same length. But by default, I would make them the same length
until experience proved otherwise.
The next thing. Sorry, can I just go in? Is it a circular stack that you're talking about?
It doesn't matter. Okay.
We actually implemented circular stacks. So that was Dr. Ting. We shared the code with
him. He said use circular stacks. Okay, so we did that. Demetri implemented that.
It costs nothing in hardware. My next question to you is
why don't you utilize FPJs? Because that is your desktop chip making scenario today.
And I will offer you when we get finished, I'll send you a complete system that you can play with.
And it's going to be in system bare log. And it's very beautiful code. Right now,
it's like two pages of code to implement a fourth processor basic.
So why haven't you used FPJ for development?
Because they wouldn't let me program them in fourth.
There you go. That's great.
That's literally the reason and the only reason. I would love to use an FPGA,
but they won't let me. I'd have to learn someone else's ugly language.
Yeah. Remember, that's only maybe five years that there are open source tool chains for FPGA
programming. Thanks, Jack. Okay. Or not. You're raising your hand and you're putting it down
and raising it. Maybe you have a question. I actually wasn't putting it down, but
yeah, I have a question. I think like fourth is like, you know, perceived as a runtime language,
but it could be like a meta language. It could be like incredibly like expressive and like, you know,
what are your thoughts about that? And also, yeah, I can ask the next question later.
So what exactly was your question? Oh, sorry. So the question is,
we're thinking about stacks and what stack to use and like, you know, what kind of stack size to use,
because like, that's a runtime for it, right? That's the fourth where it's like, you know,
we execute a stack-based, we have a stack-based runtime, right? And that has like a certain costs
in terms of like, you know, like third performance costs. And it doesn't actually map to architectures
like GPUs, for example, because there is not even like a concept of stacks. It's just like,
I mean, you could have like a memory stack on the GPUs. Sure. But it's got to work on like, you know,
I think, I think fourth can be an amazing like compiler, you know, like, it's, it's, it's,
I'm sorry. Yeah, I can be, I'm super excited. So I am somewhat in our particulates and can be harsh.
Sorry. Well, let me, let me try to address that. Yes. Thank you. The stack is nearly a tool that
fourth uses to express things compactly. And certainly fourth has applications far beyond
stack-oriented things. And yes, fourth would make an excellent compiler. Fourth would make a good
language translator. Fourth would make a good artificial intelligence effect.
And yes, I kind of agree. Fourth is a meta language. It lets you define an application
language suitable for your environment. Yes. Yes. Thank you. I mean, also that brings to the second
question, which is like, I also think like, having the, like, you know, the 144 chip, the,
how, like, in terms of like the simplicity, that's, that's the way to actually reach like the energy,
like consumption to the minimum, right? Yep. And yeah, we think there could be other constructs
other than the stack to like, you know, or like, it could be like, I don't know. I was thinking
maybe it could be like a hardware definition language where we define those kinds of constructs
for whatever problem at hand. So the hardware could morph, depending on like what kind of
application is what run we redefine the hardware sort of. You don't like need to be,
you don't want to think restricted to a stack. You don't have to use a stack
for everything. As I said earlier, you can have, you can have structures which relieve the depth
of the stack. And, but the stack I think is in this, at least the small stack is absolutely
essential for passing parameters. I think I also come to that conclusion, because like,
it's super simple to pass parameters. And yet I think like, you know, at some level, it's, it's,
it's all like, it's, it's, it could be even like, you know, of the implement the whole compiler
assembly and like, like use the, I, sorry, I can, I can, I can grab. Also, I just want to say like,
I, I thank you for, for all the inspiration and like, for everything. I mean, I am, I'm so, so
happy that I briefly got to introduce you to some of the work that I've been doing.
Okay, thank you very much. I think we follow up on that later. Dimitri, another one.
Oh, it's a very short question. It was, it was based on Don's question on the return stack.
And in the, in the chat on Peter Jackie, he was saying, well, you know, wouldn't the return
stack need to be deeper if you're going to factor your code heavily. So Chuck, how could we have a
return stack or say eight steep and still factor our fourth code?
Oh, no, it's a question. It's a question of complexity. If you, if you have two deep call
sequence, this calls that calls that calls that it gets complicated and you lose track of what's
going on. I rarely have more than two or three levels of nested calls, which is what the return
stack is for. I see. Okay. So it's quite flat to yes, because you can still, you can still
factor your application into lots of short words, but they're just not words that
call one another, one another in a chain. They all kind of stay at the same level.
That's right. The other use of the return stack is to hold
loop counts, although that's not the only way of doing it. So you want to consider how many nested
loops you have, as well as how many nested calls. Okay, that makes sense to me now. Thank you.
Okay, great. Thanks. So, Jan for another question. Yes, this time my question is regarding state smart
words, I found them a pain in the posterior to work with. And wouldn't it be possibly easier to
have an always compiling forth where interactive code is compiled into an anonymous function and
executed afterward, just to be immediately deallocated? Is there a downside to
setting up a fourth system like this, that it's always in compile mode? And
with the defining a word would only move the compile location from the scratchpad to the
dictionary? Yeah, I'm a little bit out of my depth because I don't know how state smart words are done
conventionally. But I do agree there needs to be two distinct
behaviors, one in which you're interpreting and one in which you're compiling.
And why do I need the interpreting state at all? Couldn't this be solved by
compiling into a temporary scratchpad area, large enough to hold a line of code or two,
then calling this code and reusing the scratchpad for the next interactive input. So always
being in compile mode? Yes, you could do that. I think I did that once upon a time.
What is the downside? It's no less clumsy. You still have to be aware of what you're doing.
And it's just a different way. Say there's three ways of doing it. One, you can have a state flag,
two, you can have different colors, or three, you could have this
compile the scratch and execute. There's three ways of doing the same thing. I think the color
way is latest. So what I went into with G4 or MACRISP still errors is that yes, there's a state
variable and some words respond to it. And as soon as you want to do heavy meta programming,
and you need one of those state smart words and another state smart word, we don't nest.
At that point, you're scratching your head and some four systems work around it by providing
non-state smart versions. And suddenly you have two or three times the number of words
for those words that got for special treatment. That's
that's bad. Yes. I would rethink your problem. Which is why I asked because
I have a state smart state smart question for Chuck. So you know what I was thinking is you
have a 32 bit wide fourth computer in an FPGA, but make the inside data bus
34 bits wide and then use the top four bits for your state or whether it's an immediate word
or you know compile. I guess it's compiling and immediate. Is that the two things you need to
figure out? I have done that on one of the early computers that I
had fabricated had 21 bit words. Whereas the memory was only 20 bits. And that extra bit
was used as a flag for various things. It was not good. It was as awkward and confusing and
difficult as anything else. Okay. Maybe I have a follow up question and another one on that.
You once talked about the ICE principle interpret compile execute. And so if we
enroll everything into just compile, don't we lose the interpretation capability
to calculate things upfront before we compile? So do we need interpret compile execute the ICE
principle? You're exactly right. We do need the ability to calculate things. And that's why in
color fourth, if I'm compiling green words, I can interpret interpolate white words to do the
calculation. Yeah. So we don't want to lose this. And maybe Jan, this also answers a little bit of
that. We don't want to lose the capability to do execution while we compile and calculate things
and generate code or whatever. I didn't propose to eliminate immediate words.
Anyway, my second question. You've been once talking about the map is not the territory.
And I would like to hear your current opinion on the statement and how you think about abstraction.
So do we... The map is not the territory.
But currently I prefer to work in the territory. No, that's not it. That's not accurate either.
In the case of drawing characters, you draw the character or you can describe the character.
And a long time ago, I would draw the characters. And that became a pain because I would somehow
move a pixel the wrong place. Now I describe the character. And I've come up with, I think,
a very compact way of describing characters. So I go back and forth between the map and the
territory. Yeah. Thank you. Thank you very much. And thank you very much for influencing my life
over the last 40 years. Sure. Yeah, maybe without knowing it, but you did. The responsibility.
Right. Next question. Come from Travis.
And you have to unmute so that we can hear you.
So about HD return stacks.
I've found a number of different uses for return stacks. Like, for instance, I'll make a word,
I have a word that out, that a lot space in the dictionary. And then deal lots afterwards.
And I'll use the return stack as scratch space for storing the top of the here pointer
for an afterwards so I can restore it and return it. Including if an exception occurs,
I'll catch the exception, restore the stationary, then rethrow the exception.
And also, in my fourth, I have to deal with exception frames, which go on the return stack.
And furthermore, there can be nested exception frames, where one exception is within another.
So furthermore, the multitasking uses the return stack. So to store registers and all that. So
in essence, I need far more than eight cells on the return stack to store all the possible states.
Even if my code itself does that go that deep. So what are your thoughts on this?
I understand. You can have a large, you can have a large multi-purpose return stack, certainly.
My concern is that it's getting complicated. And I tend not to like it being complicated.
I would observe that in the case of circular stacks, when you get an exception,
you don't need to do anything to the stacks. You just leave them where they are and get on
your business, because you don't need to keep them clean. So yeah, I think the simplest solution
is to have a small return stack. But I understand the convenience of having a large return stack.
Thank you. Okay. We have two other guys that want to ask questions. John Hardy, please.
So me again, I was just, I mean, it's return stacks, an interesting topic, because it is
necessary to discuss all sorts of different aspects of fourth, because the return stack is so
critical to the virtual machine. I'm interested in the changes that happened in Color Fourth.
Some of them have to do with your use of tail call optimization as a way of reducing,
so in other words, optimizing away calls, so they become jumps, which means that they use less
stack space. So I could see that would reduce the size of a return stack. But one thing that
seemed to get thrown away from my understanding of Classic Fourth is that you use tail call
optimization as a looping mechanism. And that you, when you do, when you, in Classic Fourth,
when you redefine a word, or when you define a word, you don't have access to that word,
it's hidden until you're finished defining it. Whereas in Color Fourth, I believe the word is
visible, so that you can call, so it can be called by itself. So can you talk a little
bit about that change in the language, and what are your thoughts about the way, you know, ditching
the idea of the original fourth and going forward in this way? Yeah. The original way would be my
preference, that you rarely reference a word within itself. More likely you want to redefine
the word, add some functionality to its previous definition. But that was complicated and awkward.
And in Color Fourth, I just threw it away and said, okay, I'll have to live with the fact that
if I want to redefine the name of a word, I'll have to say word, colon word, word zero,
word, word zero, stuff, stuff, stuff. That's awkward, but it doesn't happen very often.
Yeah.
Actually, I found that in my fourth that doing it the way that you did it before,
it's simply a matter of linking the word that you're compiling into dictionary after
you hit the semicolon at the end. And it works basically like how it was where you,
if you redefine a word, you refer to its old meaning from within the new word without any work at all.
Yes, that is exactly right.
But in my current fourth, semicolon does not indicate end of word. It merely indicates return
from word. Return, yeah. And so I have no word that identify the end of a word.
Okay. John, another question or?
No, that's it. Actually, you're done. Thank you very much.
So thank you. Satisfied. Okay. The last question for today comes from James Norris.
I was wondering what the most fun thing you ever worked on was.
Most fun thing.
A fun thing is something that gives you frequent positive feedback.
I have to say my chip layout and simulation.
It took years, five years.
But I was immediately doing good work after one week.
So I got this positive feedback which continued and continued and continued.
The hard part of that was when you submit a chip for fabrication.
And you have to wait three months before you know whether it worked or not.
And what do you do during those three months?
But I have to say that was a lot of fun for a lot of years.
Thank you. This is great. I was asking another question.
The chip simulation is fantastic. I think one of your very first projects you ever worked on
was the telescopic pointing and the data analysis you did interactively
on the system with all the other astronomers watching the work output.
Because that is quite significant to use something as large as a radio telescope
to capture the data live and to manipulate the data to generate those graphs.
That I think would be significant.
It was at the time there was this millimeter radio telescope
was being used to discover interstellar molecules.
And you would collect data and display it.
And if there was a peak where you expected a peak, you would discover the molecule.
And the immediate feedback was very useful for the astronomers.
But they still required that I record the raw data so they could take it home
and repeat the analysis even though that was completely unnecessary.
Brilliant. You've done the processing already.
Yeah. They were going to redo it probably not as well because I had good statistics.
Live statistics. Forget about post statistics.
Well, guys, I see we had a fantastic meeting today. We need to thank
1000 times to check. But there are people in the meeting.
I see Rob Jude from Australia. Do you want to say hello and anything to Chuck?
Not not questions, but only hi.
Or do you have questions? Sorry.
No questions. Okay. Who else? I see Ray Gardiner also from Australia.
Very late in the night. Ray.
Ray showed us in the group, in the Facebook group,
fantastic pictures of his boards with the RTX 2000 and image vision
in Australia for machines for different machines.
So he's a wonderful father and incredible, incredible stuff.
I see in the meeting, Ashley Faniello wanted to show us the wonderful
cognition. Do you want to say anything, Ashley? Something to Chuck?
Oh, just hello, Chuck. We met once in 2013 at the Strange Loop Conference.
It's great to see you again. It's always great to hear what you have to say.
Who else? I see Ilya Tarasov from Moscow. He's chatting,
but he does not like to talk. What happens, Ilya? Too much vodka today?
Say hello to Chuck. Okay. Okay. I'm here, but I'm afraid with my new microphone,
it will be not possible to hear me. Okay. Very good. It's very good.
I just want to say hello. No more. What else? Hello. What else? And wish everyone to be healthy.
Thank you. Thank you to you too. 3.30 in the morning in Australia.
It's indeed this is a word-by-word translation of Russian hello. Be healthy.
Yeah. Wonderful. Thank you, Ilya. I see also Jonas Carlson. Where are you in the world, Jonas?
Do you want to say hello to Chuck?
You are muted.
Oh, yeah. One moment. Yes. So, yeah, I'm in Bangkok at the moment. And well, at the moment,
we are all stuck where we are, right? So, it's two years. So, I had time to play with a lot of
things. And the last thing I played with a few months ago was 6502 Forth. And I was reading in
parallel a lot of things about Color Forth. And I found similarities when I was basically creating
a system with an online editor running on a 6502, where each page 256 bytes was,
maybe it was buffer size, basically. And this Forth was a bytecoded Forth. Actually,
it's alphabetical bytecoded Forth. So, I used D for dup and I used S for swap and so on. And,
of course, the arithmetic operations are plus. And I remember reading when I was working on this,
that you actually liked the idea of a bytecoded Forth, but you never really went to do that.
Do you have any comments about that? And especially about the code bloat today,
we have so big systems and they are compiled to yield hundreds of bytes.
Yeah. So, that's my general question. If Jacques is there.
I've thought about bytecoding. Other people have also. It's a good strategy. The closest I've come
to it is the GA-144 instruction codes. They are five bits. So, effectively done by coding on the
hardware. Right. Microcontrollers with ARM v7m have the bh and thh instruction, which are basically
what you're asking for, bytecode junk tables in mass manufactured CPUs, which can be used
to bytecode at Forth with a very tiny interpreter.
Yeah. I'm finally building my so-called alpha alphabetical Forth, which is supposedly half
readable kind of bytecode with letters and symbols. And I'm writing a very tiny C compiler that
compiles C to this Forth. And I have it kind of working for functional C with no variables.
And just the other day, I added variables. So, soon I will be able to compile C to Forth. And
the rationale for this is ESP32, which I calculated that, yes, it's a very powerful thing, but one
line of C code usually ends up being about 80 bytes of machine code.
Join us. We are saying bye-bye. Bye-bye. We are finishing. Bye-bye. Thank you. Another one here.
Holy Neppu. Holy Neppu. Is this correct?
Yeah, this is holy. Yeah, from Taiwan.
Holy. How are you, Taiwan?
You invite us to join this meeting. Actually, I want to say that I have developed the
cross compiler for different micros MCUs. And the cross compiler includes assembler,
disassembler, and compiler, and cross compiler. One special trick is that once the assembler is
generated, the disassembly is automatically generated. And the assembler that I designed
is based on algebraic assembler. So, every microcontroller can be seen the same, because we
use the same instruction like register and immediate word. You can see that all microcontrollers can
be seen as a false chip. Not a really false chip, but actually, if we say it is for chip,
and it contains only register and immediate word. So, that way, based on these two characters,
I can design the assembler based on these two. So, every microcontroller seems the same.
And the assembler has, I can design the assembler in a different way.
Fantastic. This is great news. So, we love to hear from you, and we send all our regards to the
fantastic FIC Taiwan and all the great members you have, also in the name of Dr. Ting, who is here,
and he wanted to show something, but we will do this in the next meeting, because we are out of
time. Thank you, Holly, for participating. Looking forward to hearing more about that in
a later time. Another friend here is Igor Matsnitsa from Estonia. Is this correct, the name? Igor?
Yes, do you hear me? Only to say hello to Chuck, and wish him well, and etc.
Do you hear me, yes? Yeah, but the mic is making noise, but it will do.
Hello, Chuck. Thank you very much for your creation. I met Ford the first time in my school, and it
made a big movement in my development as a programmer. Thank you very much, one more time,
and big help in this time, and I wish you many years and a lot of, implement your plans.
Thank you, Igor. Karsten, do you want to say hi to Chuck and bye-bye? Where are you from, Karsten,
from Germany? I cannot. Karsten, yeah, your microphone. I cannot.
Maybe you have to put on the volume, increase the volume, Karsten.
Okay, then just wave into the camera next time, so Karsten is from Hamburg, actually,
across the city. Thank you very much, Karsten, for participating. Next time, we talk with you.
Roy, also from Germany, do you want to say bye-bye to Chuck and thanks, etc.,
or Rolf has no microphone? Who else? I have...
You're muted, Roy. Hello, Chuck. I want to say hello from Germany,
Bühnefeld, and I was motivated to write my own force, my own tiny force,
because everybody should write their own tiny force before using a professional force, I think,
and I learned it from you. I see also Thomas Goeppel from Germany. He helped us putting the
link in the Hackaday, so I thank you very much to Thomas, and he's also a great participant here in
our meetings. No sound, Thomas. Hello. Thank you, then, if you have no sound. Thank you again.
Who else?
Atle from Norway, do you want to say bye-bye and thank you to Charles?
I'm a relative newbie in short, and I just want to say thank you and I find it brilliant.
Thank you. Anthony Fogler, do you want to say bye-bye and thanks to Chuck?
Yes, I say hello to Chuck, and thank you so much for all the difficult nights I have to work through
to find books in my programs for three later. It was very enjoyable, and still today, two months ago,
I started a new project with FORTH, so it is still very alive for me. Thank you.
Well, who else? Jorge from Brazil. Jorge Janaite, do you want to say?
Oh, hi. I'm Jorge Janaite from Brazil. I'd like to say thank you to everyone,
especially Peter, for organizing this event. Chuck, for discovering, like he says,
this incredible language. It's amazing. It's more than a language, it's a philosophy.
The FORTH way to think, I don't know. I really love this. It's a pleasure to talk about FORTH
with people who like FORTH. Oh, thanks. Thanks, Peter, Ulrich, John Hard, Chuck, Dr. Ting,
everyone. It's really, really, really nice to stay with that today. Thank you for your love
in the language, Jorge. You are a great father. I have also here, Thomas, from Kern. Thomas.
Thank you. Can you hear me? Thank you, Chuck. Thank you, everybody, for this very marvelous
meeting. And I was using FORTH at the beginning in, I think, 85 to 87, brought my PhD. No,
my thesis in Felix was a great time. So thank you all and have a good time, Chuck. See you soon.
Bye-bye. Thank you, Thomas. Pablo de Argentina. Pablo Reda. Hi. I'd like to say thank you to
Chuck Moore. I am a Color4Fan. I'm learning FORTH, reading the Color4Source, and I changed my life
with this marvelous language. Thank you. Thank you, Pablo. Who else, somebody else? And then we
close. Cecil Bayona. I don't know. Philip, Ellie. Yes, Chuck. Chuck, again, many thanks for the
inspiration you gave me during those years when I was a student and still now. And clearly,
you are a wonderful person. So thank you for everything. Fantastic. Thanks again, Chuck, for
being here. I've been following FORTH for many, many, many years. And in my youth,
when I first heard about FORTH, I was so excited. Somebody who wanted to keep things simple rather
than the abortions we had for programming at the time. So thanks again for your great idea.
And what can I say? Thank you again.
Well, guys, this was fantastic. I don't know if Chuck agrees to that. And we do all these meetings,
thinking and thanking everybody in the FORTH community. All people from SVFIC also who helped
us every meeting and from all the communities in the world. Howard, do you have a racing hand?
Yeah. Chuck, is there any chance I could get my hands on your clock code? I'd like to put it in
as an app in the color FORTH. Do you have any plans to post it anywhere?
I don't have a vehicle for posting things. Can you send it by email?
I could send screen captures maybe. I'll keep it in mind. Okay. I'd also like to see the source
for your character generator code. That interests me. That I would gladly publish.
Again, if I had some way of doing it, I used to have a website. I keep thinking maybe I should
reactivate the website. But I haven't yet. Okay. If you come up with any way of transferring it,
I can help in any way. Let me know and I'll help you gladly. Okay, Howard. I want to thank you all
for inviting me. It's been fun and it's gratifying to see so many interested FORTH people. I wish you
all will in your endeavors. Thank you. Thank you. Thank you very much. Thank you very much for joining
us. Thank you. Thank you, Chuck. Thank you, everybody. Chuck. Thank you. Thank you, Chuck.
