You, you, you accept data, you store it in your short term stack, and then you operate on it.
You don't prefix things.
Okay. Short answer. And are you satisfied with it?
Yes, I got my answer. Okay. Okay. Thanks, Jan. Next is Anton Erte. Anton, please go ahead.
Oh, maybe your mic volume has been turned down. So that's what happened to Jared. So we can't hear you.
Mic selection, maybe. Answer.
No, no, no. No, no, no. No, and now not again. So, yeah, yeah, no, I didn't speak.
Okay. Go ahead. All right. So the question is, what is your take on state smart words? I think you
have four systems, and then you eliminated them. And I'm not sure if you have them in
the reason systems. I don't think so. But can you talk a little bit about them? And yeah.
Yeah, I think maybe that's an area in which forth has made some progress, or at least my fourth.
And UHD forth is basically color force. And different words have different colors.
Now, the state smart words would have different colors for different states.
For instance, the color white means execute immediately. The color green means compile.
And those are only only two states that I need. But I do have to be aware in programming.
For instance, a conditional word like if or then is an immediate word and must be in white.
If I have an if in green, it means compile a reference to if for future use. And that's
basically what the state smart words did. You didn't have to be aware that they were
which state they were in. They knew. But now I must be aware
to distinguish green from white. And that is a programming challenge. Sometimes I get it wrong.
Thank you. Yeah, interesting. Yeah, Don, please. Hello, Chuck again.
How many items or how deep do you think we should build the return stack in our FPJ fourth?
32 bit fourth. That shouldn't matter.
I would go with eight. Eight, okay. I think the return stack
and the data stack need not be the same length. But by default, I would make them the same length
until experience proved otherwise.
The next thing. Sorry, can I just go in? Is it a circular stack that you're talking about?
It doesn't matter. Okay.
We actually implemented circular stacks. So that was Dr. Ting. We shared the code with
him. He said use circular stacks. Okay, so we did that. Demetri implemented that.
It costs nothing in hardware. My next question to you is
why don't you utilize FPJs? Because that is your desktop chip making scenario today.
And I will offer you when we get finished, I'll send you a complete system that you can play with.
And it's going to be in system bare log. And it's very beautiful code. Right now,
it's like two pages of code to implement a fourth processor basic.
So why haven't you used FPJ for development?
Because they wouldn't let me program them in fourth.
There you go. That's great.
That's literally the reason and the only reason. I would love to use an FPGA,
but they won't let me. I'd have to learn someone else's ugly language.
Yeah. Remember, that's only maybe five years that there are open source tool chains for FPGA
programming. Thanks, Jack. Okay. Or not. You're raising your hand and you're putting it down
and raising it. Maybe you have a question. I actually wasn't putting it down, but
yeah, I have a question. I think like fourth is like, you know, perceived as a runtime language,
but it could be like a meta language. It could be like incredibly like expressive and like, you know,
what are your thoughts about that? And also, yeah, I can ask the next question later.
So what exactly was your question? Oh, sorry. So the question is,
we're thinking about stacks and what stack to use and like, you know, what kind of stack size to use,
because like, that's a runtime for it, right? That's the fourth where it's like, you know,
we execute a stack-based, we have a stack-based runtime, right? And that has like a certain costs
in terms of like, you know, like third performance costs. And it doesn't actually map to architectures
like GPUs, for example, because there is not even like a concept of stacks. It's just like,
I mean, you could have like a memory stack on the GPUs. Sure. But it's got to work on like, you know,
I think, I think fourth can be an amazing like compiler, you know, like, it's, it's, it's,
I'm sorry. Yeah, I can be, I'm super excited. So I am somewhat in our particulates and can be harsh.
Sorry. Well, let me, let me try to address that. Yes. Thank you. The stack is nearly a tool that
fourth uses to express things compactly. And certainly fourth has applications far beyond
stack-oriented things. And yes, fourth would make an excellent compiler. Fourth would make a good
language translator. Fourth would make a good artificial intelligence effect.
And yes, I kind of agree. Fourth is a meta language. It lets you define an application
language suitable for your environment. Yes. Yes. Thank you. I mean, also that brings to the second
question, which is like, I also think like, having the, like, you know, the 144 chip, the,
how, like, in terms of like the simplicity, that's, that's the way to actually reach like the energy,
like consumption to the minimum, right? Yep. And yeah, we think there could be other constructs
other than the stack to like, you know, or like, it could be like, I don't know. I was thinking
maybe it could be like a hardware definition language where we define those kinds of constructs
for whatever problem at hand. So the hardware could morph, depending on like what kind of
application is what run we redefine the hardware sort of. You don't like need to be,
you don't want to think restricted to a stack. You don't have to use a stack
for everything. As I said earlier, you can have, you can have structures which relieve the depth
of the stack. And, but the stack I think is in this, at least the small stack is absolutely
essential for passing parameters. I think I also come to that conclusion, because like,
it's super simple to pass parameters. And yet I think like, you know, at some level, it's, it's,
it's all like, it's, it's, it could be even like, you know, of the implement the whole compiler
assembly and like, like use the, I, sorry, I can, I can, I can grab. Also, I just want to say like,
I, I thank you for, for all the inspiration and like, for everything. I mean, I am, I'm so, so
happy that I briefly got to introduce you to some of the work that I've been doing.
Okay, thank you very much. I think we follow up on that later. Dimitri, another one.
Oh, it's a very short question. It was, it was based on Don's question on the return stack.
And in the, in the chat on Peter Jackie, he was saying, well, you know, wouldn't the return
stack need to be deeper if you're going to factor your code heavily. So Chuck, how could we have a
return stack or say eight steep and still factor our fourth code?
Oh, no, it's a question. It's a question of complexity. If you, if you have two deep call
sequence, this calls that calls that calls that it gets complicated and you lose track of what's
going on. I rarely have more than two or three levels of nested calls, which is what the return
stack is for. I see. Okay. So it's quite flat to yes, because you can still, you can still
factor your application into lots of short words, but they're just not words that
call one another, one another in a chain. They all kind of stay at the same level.
That's right. The other use of the return stack is to hold
loop counts, although that's not the only way of doing it. So you want to consider how many nested
loops you have, as well as how many nested calls. Okay, that makes sense to me now. Thank you.
Okay, great. Thanks. So, Jan for another question. Yes, this time my question is regarding state smart
words, I found them a pain in the posterior to work with. And wouldn't it be possibly easier to
have an always compiling forth where interactive code is compiled into an anonymous function and
executed afterward, just to be immediately deallocated? Is there a downside to
setting up a fourth system like this, that it's always in compile mode? And
with the defining a word would only move the compile location from the scratchpad to the
dictionary? Yeah, I'm a little bit out of my depth because I don't know how state smart words are done
conventionally. But I do agree there needs to be two distinct
behaviors, one in which you're interpreting and one in which you're compiling.
And why do I need the interpreting state at all? Couldn't this be solved by
compiling into a temporary scratchpad area, large enough to hold a line of code or two,
then calling this code and reusing the scratchpad for the next interactive input. So always
being in compile mode? Yes, you could do that. I think I did that once upon a time.
What is the downside? It's no less clumsy. You still have to be aware of what you're doing.
And it's just a different way. Say there's three ways of doing it. One, you can have a state flag,
two, you can have different colors, or three, you could have this
compile the scratch and execute. There's three ways of doing the same thing. I think the color
way is latest. So what I went into with G4 or MACRISP still errors is that yes, there's a state
variable and some words respond to it. And as soon as you want to do heavy meta programming,
and you need one of those state smart words and another state smart word, we don't nest.
At that point, you're scratching your head and some four systems work around it by providing
non-state smart versions. And suddenly you have two or three times the number of words
for those words that got for special treatment. That's
that's bad. Yes. I would rethink your problem. Which is why I asked because
I have a state smart state smart question for Chuck. So you know what I was thinking is you
have a 32 bit wide fourth computer in an FPGA, but make the inside data bus
34 bits wide and then use the top four bits for your state or whether it's an immediate word
or you know compile. I guess it's compiling and immediate. Is that the two things you need to
figure out? I have done that on one of the early computers that I
had fabricated had 21 bit words. Whereas the memory was only 20 bits. And that extra bit
was used as a flag for various things. It was not good. It was as awkward and confusing and
difficult as anything else. Okay. Maybe I have a follow up question and another one on that.
You once talked about the ICE principle interpret compile execute. And so if we
enroll everything into just compile, don't we lose the interpretation capability
to calculate things upfront before we compile? So do we need interpret compile execute the ICE
principle? You're exactly right. We do need the ability to calculate things. And that's why in
color fourth, if I'm compiling green words, I can interpret interpolate white words to do the
calculation. Yeah. So we don't want to lose this. And maybe Jan, this also answers a little bit of
that. We don't want to lose the capability to do execution while we compile and calculate things
and generate code or whatever. I didn't propose to eliminate immediate words.
Anyway, my second question. You've been once talking about the map is not the territory.
And I would like to hear your current opinion on the statement and how you think about abstraction.
So do we... The map is not the territory.
But currently I prefer to work in the territory. No, that's not it. That's not accurate either.
In the case of drawing characters, you draw the character or you can describe the character.
And a long time ago, I would draw the characters. And that became a pain because I would somehow
move a pixel the wrong place. Now I describe the character. And I've come up with, I think,
a very compact way of describing characters. So I go back and forth between the map and the
territory. Yeah. Thank you. Thank you very much. And thank you very much for influencing my life
over the last 40 years. Sure. Yeah, maybe without knowing it, but you did. The responsibility.
Right. Next question. Come from Travis.
And you have to unmute so that we can hear you.
So about HD return stacks.
I've found a number of different uses for return stacks. Like, for instance, I'll make a word,
I have a word that out, that a lot space in the dictionary. And then deal lots afterwards.
And I'll use the return stack as scratch space for storing the top of the here pointer
for an afterwards so I can restore it and return it. Including if an exception occurs,
I'll catch the exception, restore the stationary, then rethrow the exception.
And also, in my fourth, I have to deal with exception frames, which go on the return stack.
And furthermore, there can be nested exception frames, where one exception is within another.
So furthermore, the multitasking uses the return stack. So to store registers and all that. So
in essence, I need far more than eight cells on the return stack to store all the possible states.
Even if my code itself does that go that deep. So what are your thoughts on this?
I understand. You can have a large, you can have a large multi-purpose return stack, certainly.
My concern is that it's getting complicated. And I tend not to like it being complicated.
I would observe that in the case of circular stacks, when you get an exception,
you don't need to do anything to the stacks. You just leave them where they are and get on
your business, because you don't need to keep them clean. So yeah, I think the simplest solution
is to have a small return stack. But I understand the convenience of having a large return stack.
Thank you. Okay. We have two other guys that want to ask questions. John Hardy, please.
So me again, I was just, I mean, it's return stacks, an interesting topic, because it is
necessary to discuss all sorts of different aspects of fourth, because the return stack is so
critical to the virtual machine. I'm interested in the changes that happened in Color Fourth.
Some of them have to do with your use of tail call optimization as a way of reducing,
so in other words, optimizing away calls, so they become jumps, which means that they use less
stack space. So I could see that would reduce the size of a return stack. But one thing that
seemed to get thrown away from my understanding of Classic Fourth is that you use tail call
optimization as a looping mechanism. And that you, when you do, when you, in Classic Fourth,
when you redefine a word, or when you define a word, you don't have access to that word,
it's hidden until you're finished defining it. Whereas in Color Fourth, I believe the word is
visible, so that you can call, so it can be called by itself. So can you talk a little
bit about that change in the language, and what are your thoughts about the way, you know, ditching
the idea of the original fourth and going forward in this way? Yeah. The original way would be my
preference, that you rarely reference a word within itself. More likely you want to redefine
the word, add some functionality to its previous definition. But that was complicated and awkward.
And in Color Fourth, I just threw it away and said, okay, I'll have to live with the fact that
if I want to redefine the name of a word, I'll have to say word, colon word, word zero,
word, word zero, stuff, stuff, stuff. That's awkward, but it doesn't happen very often.
Yeah.
Actually, I found that in my fourth that doing it the way that you did it before,
it's simply a matter of linking the word that you're compiling into dictionary after
you hit the semicolon at the end. And it works basically like how it was where you,
if you redefine a word, you refer to its old meaning from within the new word without any work at all.
Yes, that is exactly right.
But in my current fourth, semicolon does not indicate end of word. It merely indicates return
from word. Return, yeah. And so I have no word that identify the end of a word.
Okay. John, another question or?
No, that's it. Actually, you're done. Thank you very much.
So thank you. Satisfied. Okay. The last question for today comes from James Norris.
I was wondering what the most fun thing you ever worked on was.
Most fun thing.
A fun thing is something that gives you frequent positive feedback.
I have to say my chip layout and simulation.
It took years, five years.
But I was immediately doing good work after one week.
So I got this positive feedback which continued and continued and continued.
The hard part of that was when you submit a chip for fabrication.
And you have to wait three months before you know whether it worked or not.
And what do you do during those three months?
