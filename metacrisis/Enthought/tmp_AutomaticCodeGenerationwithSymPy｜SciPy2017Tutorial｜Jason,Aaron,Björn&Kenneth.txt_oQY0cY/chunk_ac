And we're going to, I'm going to apply it to a few examples. So a raise of hands,
how many people here are familiar and feel comfortable working with ordinary differential
equations? All right. So that's the vast majority. So we're going to skip the notebook on ordinary
differential equations. And those of you who need a refresher, you can have a look at that notebook.
So we're going to skip ahead then straight to the notebook called Lambda Phi.
So Aaron showed us some examples where we could evaluate expressions numerically.
And he did so using the eval F method. So if we import Sympi into our namespace
and just take an arbitrary function, depending on two variables, so mapping R2 to R1,
we can run the subs command and exchange our variables.
Oh, yeah, sure.
Is this better? All right. So running the subs command
and eval F gives us a numeric value for this expression. The problem with doing this is that
it's quite slow. This eval F is a general arbitrary precision function. So if we would time this one,
we see that it takes almost a millisecond for each call.
And if we compare that to a pure Python function of the same, representing the same equation,
we see that it runs in three microseconds. So if we're doing this in a tight loop,
doing some numerical computations, this becomes problematic. So and we don't want to write this
Python function by hand. So there's a function in Sympi called Lambda Phi that generates Python code,
executes the eval function on it, and gives us back a working function.
So running Lambda Phi gives us g. And if we time the g function,
we see that it's just as fast as the Python version.
Another good thing about using Lambda Phi is that you can change what back end it targets.
So we can have it generate functions using NumPy functions, which then broadcasts to arrays of
arbitrary shapes. So if we run Lambda Phi, and as of the latest version, Sympi, which you all have,
the default is that it's going to use the NumPy back end when available.
We can see that we can give H an array here, and it will give you
an answer which has the same shape. So this is the NumPy broadcasting that kicks in.
And this is just to show this once more. If we have two arrays, one or two vectors,
a column vector, and a row vector, and give this function those vectors,
it will do the NumPy broadcasting for you. So the out shape is the number of rows in
the row vector and the number of columns in the column vector.
Sometimes it is important that you have control over the function signature
of the function that's generated by Lambda Phi. It can be because you're using a numeric solver
from the Sympi library, and it has certain requirements on the signature.
To specify this, we just give an arbitrarily nesting of our arguments in the first argument
passed to Lambda Phi. So in this case, we will have a symbol Z, which is actually
a tuple of three symbols. And it means that the function generated by Lambda Phi here,
function two, will expect to get a length three tuple as its third argument.
So this works as expected. So now it's time for you to do an exercise,
and we have this little exercise line magic in the Python notebooks. So if you run the first few cells
and evaluate the exercise cell once, it will expand, and you need to fill in
the triple question marks here. If you want to take a sneak peek on the solution,
you can rerun that same expansion, but instead of using that exercise magic, you can use the load magic.
So this would give you the solution, but I'm not going to run that one.
So yeah, give it a shot and put up the blue sticky notes when you're done.
Yeah, so it was a good remark that we got we can change this matplotlib inline to be
matplotlib notebook. And if you change that, you actually get an interactive widget,
which allows you to manipulate the data and look at it from different angles.
Question?
Oh yeah, I think most people are getting done. So let's let's take a look at the solution.
So getting the partial derivative there, the mixed partial derivative, we need to
write x and y, and the function which we're interested in is the lambda phi function.
And running, we can first run this with an inline. It will give us a PNG image, which is static.
So I can't really rotate the axis, I can't zoom, I can't do anything with it.
If I rerun this with a matplotlib notebook magic,
it might have to rerun it.
Okay, all right.
Oh yeah, yeah, there we go. Thanks. So now you can actually grab this and
supposedly you can, yeah, you can actually rotate the graph and it rerun this as this
three-dimensional picture and you get a sense of the depth. All right, so that was our exercise
notebook on the lambda phi function. Let's now take a look at the next notebook and see how we can
apply this to an example from chemistry. So let's move to the chemical kinetics introduction notebook.
All right, so chemical kinetics, it's actually a study of the time evolutions of concentrations
in reactive systems where we have competing chemical reactions occurring. So we will be
looking at a rather simple but yet interesting chemical reaction, and it's
the formation and breakdown of this molecule, nitrous or bromide.
But before we look at that actual case, we need to look at the governing equations.
So the most rates of chemical reactions follow the law of mass action.
So that the rate of change is proportional to the concentration of the reacting species,
raised to the power of the multiplicity, which they are appearing on the reacting side.
And then we can formulate ordinary differential equations as a sum of contributions from all
the different directions. And for a constant temperature and pressure, there's a coefficient
which is the rate constant, which as you hear is constant, but it's often under the assumption at
least constant temperature. So the law of mass action looks like this, and studying this chemical
reaction, we have two processes, a forward process forming nitrous or bromide, and a backward process
where it decomposes into three constituents, two NO molecules and one BR2. And we were just going to
rename this to C1, C2 and C3, the concentrations. So NO, BR2 and NO, BR are just one, two and three,
those are the chemical species. And applying this law of mass action gives us then this system
of ordinary differential equations. So it's a free state problem. You can actually reduce this by
applying such, mass is preserved, for example, so that gives you a relation so you can reduce the
number of states here, but we're not going to look into that. And that above equation
had two matrices in it, this S and R matrix, but the details are not that important right now.
So we're going to look first, how can we just write this using non pi, psi pi, not using
sin pi, and then we will look at what can actually sin pi do for us, which helps.
So doing this numerically, we will be using a numeric solar from the psi pi library called
ODE int. Raise your hands how many people have used this or another solar for ODE's in psi pi.
Okay, so then what it needs is that we need to have the right hand side of our system of
ordinary differential equations, that is these three expressions. So we need to have a function
evaluating these three expressions. So in this case, it's just hard coded. We say that
we have two reactions forward and backward. They have this form from the low or mass action,
and we just return a list of size three, which is the numeric value of the derivative.
Of each concentration with respect to time.
And if you look at the function RHS, the right hand side here, we see that it has this signature,
that it takes Y, which is state vector, and then a scalar T, and then two scalars. And it can be
any number of parameters passed to the solar. The important thing with this trailing
arguments is that there are parameters which stay constant during the time of integration.
All right, so it's time for an exercise.
So you're supposed now to
give the arguments to ODE int. So this has not anything to do with simpi in particular. It's
just reading the documentation string for ODE int. You can do so maybe the easiest way to do it
is to insert the cell and write ODE int, and then a question mark, and then
it executes, and you get the documentation.
All right, I think most people are getting there. So in this case, the arguments are named quite
nicely. The first argument is the function, which needs to be called, and that's our right
hand side function. And then it's the initial state vector, what we start with,
and then we need to specify the time points for this. Where are we interested in getting this
state vector? At what times do we want to know the concentrations? So that would be our T out
argument. Then the tricky part might be how to specify these arguments. So in this case,
it's just a tuple or K values. So that's K values.
All right, so the integration is done, so we can plot the solution.
And yeah,
it looks good. Nothing words happening. This one can actually be solved analytically,
and Sympi can do it for us, but we're not going to look at that here. And writing this right hand
sign function by hand, well, it wasn't that bad for this system, but the number of terms
increases rapidly as the number of species and as the number of reactions
increase in your system. So you usually want to do that by some system. And if you choose to
represent it using Sympi, you get additional benefits, as you will see.
So we're going to construct it symbolically, and then we're going to have Sympi generate a function
using Lambda Phi, and then we'll look at what more can be done here.
So this is also a nice feature of using Sympi in your workflow, that if you generate symbols and
symbolic expressions, you know that you can take the LaTeX output from these equations and put it
in a paper or a report, and you will know that the equations in the report are exactly those
that you used when you ran your simulations, because it's, at least to me, it happens every
now and then that you write one thing in the paper, and in reality, it was a minus sign in the code
or something. By the way, the LaTeX, if you want LaTeX output from that expression, the function
is called LaTeX, and every time you string it, it's LaTeX.
Yeah, so for example here, we can look at the first element in this
vector, we can just run the LaTeX command there. Okay, so it's time for another exercise.
Now we're just going to construct the function from this symbolic expression.
All right, I think most people are getting there, so what we need to
remind ourselves of is that the ODE int function from the Sympi library, it needed a special
signature, right? So if we look back at the right-hand side function, we see that we have
a state vector and then free scalars, where the two last scalars are the arguments
or the integration parameters, which take constant during the time of integration.
We can construct those by adding, making a tuple called arcs maybe, and have it be the
symbol's y, t, and then we add the tuple of the k values, and this will then look like this.
Oh yeah, the symbol's t needs to be defined.
All right, so that gives us the same solution, so this didn't add that much, but for a large
class of problems when dealing with initial value problems with ordinary differential
equations, these problems may become stiff, and when they are stiff, you need to use an implicit
solver, and the implicit solver would need a Jacobian of the right-hand side. That is,
we need to form the matrix where we take the partial derivatives of each of the rate equations
with respect to each state, and Sympi can generate this quite easily for us. We just
write Jacobian, and it's done, and then we can use this together with lambda phi to give us an
analytic expression or a function evaluating the analytic Jacobian, and this can be the
difference between a successful integration and a failed one, because what the solver usually does,
or what it does if it wants to use an implicit solver, and it does not have an analytic Jacobian,
is that it's going to be using finite differences, and depending on the scale, the scaling of the
variables of the problem, these finite differences may or may not be accurate enough, so it can really
be a dramatic difference to give this function. All right, so then we're going to take a look at
the final notebook for this part of the tutorial, the easy part, and it's more of the same, it's
still chemical kinetics, and we will be looking at how to construct the expressions symbolically from
the start, because this time we had the right-hand side function, and we had already done the work
of transforming or hard coding the right-hand side of the ordinary differential equations into
Python, and we don't want to do that, we want to have some domain-specific representation
and just from that construct our equations symbolically.
So in this notebook we will be looking at
the Robertson's example, so it's an example from the 60s, it's chemical kinetics,
and it's interesting because it's a stiff problem, so it's been a challenge, even though it's just a
free-state problem, it's just, it only has three variables, it's been a somewhat of a benchmark
for numerical ODE solvers, so we have three chemical species, A, B, and C, and there are three
reactions, one is the decay of A into B, one reaction is between B and C, forming A and C,
so C acts as what's known as a catalyst, it is not consumed in this reaction,
and the final reaction, which is a bimolecular reaction converting two B molecules into B and C,
and what you can say by just looking at these three reactions is that C is never consumed, right?
The only time C is on the reacting side is in the second reaction, and there it's reformed,
so this system will have a solution at infinite time where all your molecules will be converted
into C. So again, applying the law of mass action, we can write the ordinary differential equations,
but this time we're going to be representing it as a tuple of a coefficient
and two dictionaries, which specifies the stoichiometric coefficients of each
species on the reacting and product side for these three reactions, so we will start with
an exercise for you to complete the function constructing the symbolic representation of
this right-hand side function, so this is the vector which was known as y dot in the previous notebook,
and depending on how familiar you are with Python, this may or may not be a hard exercise,
you don't feel too bad if you get stuck, all right? Okay, so I'll give you the first part
of the solution, the first three question marks there. So if you look at the equations below,
this corresponds to the product, so we need to raise the concentration of the species to this
number r, and the concentration of the species is symbolically available in the C dictionary,
and then we need to have the right key, and that's given by the dictionary which we're looping over,
so that's rk, and the dictionary values are that stoichiometric coefficient,
so what's left now is
this part, which corresponds to this summation here. The details here are not that important,
I see some more blue sticking out coming up, so I'm going to give you the final part here,
so it's just the net multiplicity multiplied by this variable r which we computed just before this
loop, so the only thing that's important here is that this function in a general manner does what
we hard-coded in the last notebook, that right-hand side function, so now we can just give it
these kinds of dictionaries, and it will do the right thing,
if we actually run all the cells.
All right, so that looks familiar from the introduction text,
so in the next step we will do exact same steps as we did in the last notebook,
we will create a function, a Python function evaluating this expression using lamdify,
and you recognize the signature from the last notebook,
and we will run the integration with some parameters from the literature,
and what's interesting here is that the solver tells us that it has evaluated the Jacobian
a number of times, but it's kind of weird because we haven't given it to Jacobian, so it did just
what I said for the last notebook, it approximated the elements of the Jacobian matrix by doing finite
differences, so we'll see if we can provide this function manually or using sympy to give it an
analytic expression, so the next exercise is for you to do justice, to make a function evaluating
the analytic Jacobian.
Question?
