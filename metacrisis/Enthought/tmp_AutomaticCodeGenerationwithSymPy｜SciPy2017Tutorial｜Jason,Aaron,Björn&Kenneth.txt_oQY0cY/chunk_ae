point here is that I didn't just return a string, I passed it to this defined underscore print,
which is a very general print method that will dispatch whatever you pass it to the correct
printer. So if I were to put a symbol in there, it would call print symbol. If I would put a
list in there, it would call print list. In this case, I'm passing a string and it's going to call
print string ultimately. So it's good practice to always call self print instead of just sending
out the string, so that if you have a complex expression that it will recursively go through
and make sure it gets all those pieces. I don't know if that's probably losing everybody there,
but we can talk about it more. But in this case, I'm essentially just returning a string. So I'll
define that class, instantiate it, create a symbol. And now if I call the do print method of my class,
instead of printing the symbol I expected, it does, it just prints this string that I created.
So you can manipulate any object in Senpai and calls it to print in a different way.
Any question, how about questions right there? I guess is I probably lost people.
Everybody got that? Raise your hand if you did not understand that.
Nobody's going to admit. All right, fantastic. So now you get to try printing,
subclassing a printer, changing how it prints. In this case, in our ODE's we have Y0, Y1
through Y13. And we'd rather it say state values 0 through 13. We want to replace
those normal symbol prints with the array notation in this case. So there's two solutions here if
you want to check, but let's take 10 minutes and try to create a printer that will print
all the Y symbols like I have above there. And if you're fast, you can move on to this bonus exercise
and try to make another type of printer. All right, so let's take 10 minutes and do that.
Okay, I've got a solution here that I tried. I basically said if you find the symbol that gets
passed into print symbol in my state matrix, get its index value and then print this string,
state values, where I replace the curly braces with index. We can see if that works.
So I can create my printer
and then print
my printer, do print. In this case, we'll try the right hand
side of ODE's and we'll also need to assign it to our result. Close the parentheses.
And it looks like that works. So now I have
all of the symbols that were the Y's replaced with the indexed array values there automatically.
So now this would more properly work with my function that I showed earlier in the C template.
Anybody get the bonus exercise? A few people?
So in this case, I'll just briefly say, in this case, you had to do a POW object,
a POW or taking something to an exponent and that particular expression has two attributes,
a base and an exponent and you can replace those. Here was my solution. I basically said if the
expression is an integer, if the exponent is an integer and it's between zero and four,
just do an expanded multiplication and otherwise return the
printer, the power printer from the superclass. Yeah, so I could paste that in and run it
and then it prints as x times x instead of POW x, two. So you can have a look at that a little more.
Okay, so we've got a little less than 10 minutes. I'll probably have to fly through this last bit.
But another useful thing is something called common sub expression elimination. A lot of
compilers will do this for you if you set the proper optimization flags.
But the gist is if I have an expression, two expressions like A and B,
both of them have x times y in it and a computer doesn't really need to do x times y twice.
We could do x times y once and just replace the result of that in these expressions.
So this is called the sub expression and it's common to these other expressions.
But SIMPAI can do this pre compilation for you and it becomes useful in particular when
you're not using optimization settings and with different particular compilers and things and
also find that it increases the compile time and our CSE is reasonably fast even for large
expressions and you can save time sort of further down the road. So we have a function
called CSE and oh yeah. And it takes some expressions as its argument and then it spits out if you
look at the returns, the replacement which are a list of symbols and expressions, tuples,
and then the reduced or simplified expressions. So let's see what that looks like.
If I call CSE on the right hand side of the ODE's and then I have a little loop that just prints
those, we see that it finds all of these sub expressions in our ODE's.
Right, 87 common sub expressions that found that were common to those larger expressions.
And then the, it always returns a list of the simplified expressions because you can pass in
multiple so we're going to grab the first one and then you'll see how our longer
multivariate polynomials haven't been replaced with all these sub expressions here, all these x's that
were defined above. You can also pass in multiple items so I can get the common sub expressions
that are in both the right hand sides and the Jacobian. And then we see there's some odd,
I don't know, 200 and some, sorry, my scrolling is not that great, 200 some sub expressions
and then you can look at the simplified right hand side and then the Jacobian,
which looks a little, just a little simpler. All right, so we, this is particularly useful.
So the last exercise, and I've only, we've only got five minutes for that, sorry that it didn't
quite get a little, get through a little faster, but the goal would be is to create a
bunch of sub expressions for both that are common to the right hand side and the Jacobian
and then output the valid C sub expression, I mean simplified expressions for the right
hand side result and the Jacobian result. And I've given you some clues here.
One is that there's this assignment object that is useful. So if I print an assignment
object, I can print a left hand side and a right hand side by passing an symbol and a value in
this case. So that's, that's useful. And then here I show you how I can override the immutable dense
matrix method and when it gets our matrix, it calls CSE and then it sort of builds out the correct
printing for us. So that is a printer that can take a single matrix, print valid C code here
that we want for all the sub expressions and then an array of the, of the other expressions. Okay.
So the exercise has been looking to how you might be able to use print list so you can pass in two
expressions, both the right hand side and the Jacobian expression and generate all the sub
expressions and then populate the two arrays in C with the simplified expressions as I described
in the top of that. So you can write your answer there and four, four minutes. It might be a little
hard to get that one done. But you can also look at the solution and if you're really fast,
you can try to compile your C program and see if it, if it actually functions. Okay. So
yeah, should I, should I, should I just go through it since we're out of time? All right.
All right. Okay. So let me just copy my solution here. Good idea.
So what I did is I overrode, I guess I need to stay with the mic. Yeah. I overrode both
print list and print immutable dense matrix. So in the immutable dense matrix, I said, well, if
that matrix has a certain shape, print it differently. I knew that the Jacobian was a 2D
matrix and that the right hand side result was a column vector. And so I sort of just check here
which one it is and make sure that I assign the right variable to them.
And then I overrode the print list so I could pass in a list of Sympi matrices.
And in this case, I basically just see a C, the list of expressions right here.
And then collect all the sub expressions, make my assignments right here. So I assigned the
sub expression, the new variable to the expression. And then I also print the simplified matrices.
And I did a quick hack here to just replace all the Ys with state underscore vowels
also. So you can look at this after the fact. But if I run that, I get a name error.
And that is because I haven't defined state array map somewhere. Oh, I think that's in my
solution, my second solution to the above problem is where we'll find that.
Right. I've got a lot of code generated here. So right here, I have this, these two lines,
which I'll bring down. So you can examine, take a look at this in the break to try to
get a better idea of what I'm doing. Okay. So I have this map that maps the state
vowels. And then I print, and I get all of my sub expressions and notice that state
vowels has been replaced. I get all the sub expressions. And then I have the right hand side
result, the 14 elements of that, and then the hundred and site 196 elements of the Jacobian result.
There. So that is a quite a few lines of generated code that Senpai helps us
do fairly easily. And just for fun here, I'll show you the last bit. I have a little template
of the code that I had before. And you can use our new printer to generate a file.
So here I use my, take the T C template, I print, I use my new printer right there
to print out what I want. And I plug it in to the function in, in this spot right here,
where we need to fill in the code. And then I write it to a file, a C file.
And that's, that's what the C file now looks like, right? We see our prototype. We see all the
computations it has to do. And then this is different on every operating system, depending
on what compiler you have. But I'll run GCC here to compile that new file. Looks like it
and then run it. And it does my calculation, right? Right hand side, it calculates the values
and the Jacobian evaluates to. Okay? So that's, you'll have to dig through that last bit a little
more, probably to see some of the details. But the gist here is that we learned how to subclass
printers, right, and change how they print so that we can do custom things with them. And then
we've printed a fully functioning C program now that also use common sub-expression elimination to
give us maybe some faster compile times and potentially more efficient computation. Okay?
Okay, so let's take a 10 minute, I mean, I'm sorry, we'll take a five minute,
five minute break. So come back at six after. And if you have any questions come up and then
Kenny's going to lead us on the next round. So we just saw how to use code printers to
generate code that evaluates expressions. So we're going to take that one step further
with code generation. And so we'll go ahead and get started. This is the, right after the hard
way, this, or the harder way, this is the easy hard way. I'm not sure if that's accurate or not.
And everyone else finished on time, I'm not sure that I'm going to be able to finish on time.
I'm just going to go through it at a nice pace. And if we don't get to the end,
hopefully you can just take a look at the rest of it later. I hope it's written
clearly enough that you can work through it on your own. But if you run into issues, you can
go to the GitHub page for this tutorial and file an issue.
So the point of this tutorial, or this part of the tutorial, is to write a, we're going to see
how to write a scython function, just as kind of a demonstration of what scython is if you're not
familiar with it. And then we'll use Sympi's code gen function to take code printing one
step further. Not only does it print the C code that corresponds to an expression, but it'll
actually put it into a function and then put that into a file that you can then compile.
And then we're going to wrap that code using scython. So that's one use case for scython,
is to wrap existing C code. And then we will use Sympi's auto wrap function, which can do all this
for us rather than us doing it manually. And then last, if we can get to it, you can actually
now pass a custom code printer to auto wrap and some preprocessor statements to get,
be able to use a external C library with your auto wrap code. So we'll go ahead and get started.
These are just a few imports we'll be using throughout. So every, every Sympi thing is
going to be under the sym namespace. All right. So as a little quick introduction to what
scython is, scython is a compiler and a programming language. And it is used both, well, it's used
to generate extension modules for Python. So Python allows you to write C code and compile it into
a binary that you can import just like a normal Python module. And so the functions that are
declared or defined in that module can be imported and used just like normal Python functions.
And so the scython language is sort of a creole of Python and C, but it's primarily Python
with some keywords added that allow you to specify data types. So you can see this is very
Python looking, but it has these keywords like int, C def float that tell, that tell it what the type
of these things is. And what this does is it basically allows, it takes the dynamicism of
Python away. And so it knows now that this is an integer and this is a float. And so it doesn't
have to look up the types of every object before it can do things like add and multiply and everything.
So the compiler is going to take this scython source code and turn it into C code. And it's
kind of a specific flavor of C code. The imports includes Python.h, so it uses py objects and
things. And this is what allows it to be compiled into a Python extension module.
And then, so aside from writing scython for computations like this function up here,
you can use scython to wrap existing C code. And that's primarily what we'll be focusing on
for this part of the tutorial. But just as a quick example of the scython language and what it can
do, we'll go through a little demonstration of generating Fibonacci sequence numbers. So if
you're not familiar with what the Fibonacci sequence is, it's just a sequence that's initialized with
zero and one as the first two elements. And then every element after that is defined recursively
as the sum of the previous two elements. Okay. And so our objective is to write a function
that computes the nth Fibonacci number. And so this is a simple, pretty simple function. It's
just an iterative solution. And so it generates numbers. And if you run that and then run the
next cell, you can see that it generates a list of the numbers, so zero, one, one, two, three, five,
et cetera. So we can see how long it took to, or how long it takes to generate the 100th Fibonacci
sequence number. And it takes about 4.9 microseconds on this machine. So now let's go ahead and
implement the exact same thing with scython. And so since scython is basically Python with types,
it can be a little more complicated than that. But in some cases, it's pretty simple.
We just, we can pretty much literally copy and paste the code and then add in types
and see what it does. So there are a few, so anyway, that's the benefit is that it's so easy to do
that. But it comes with the cost of having to compile the code before you can run it and import
it. So there are a few ways to go about the compilation process. I'll use a couple of different
ones in this part of the tutorial. So the first one, since we're just writing scython code, there's
no really complicated stuff going on. You can use this scython magic command in Jupyter notebooks.
And to do that, you can load the scython extension. And this will take the contents of the cell,
compile it into the C code, the kind of extension module flavor of C, and then compile it and then
import its contents into your namespace. So you can use it just like a normal, normal Python cell.
So go ahead and run this. And you can see that it's really just exactly the same thing, but with
cdef float, or cdef, sorry, cdef double, a double, b declaring the types of all these things.
You can still use for i and range n, that kind of stuff. And so if you run this, it should compile.
And then you can time how long it takes to do that. And you can see 217 nanoseconds.
So it's several orders of magnitude faster than the pure Python implementation.
And all we had to do was add these types and then use a magic command to compile it.
Does anyone have any issues with getting it to run? It should be pretty easily cross platform, but
yeah, okay, good. It gets more complicated, so we'll see how it goes as we go.
So if you want to know a little bit more about writing Scython for computation,
there's an extra notebook I was going to have in this, but I just kind of cut it out because it was
just extra material. So that's contained in the notebooks folder of the repository.
And even better, there's a tutorial going on right now on Scython, and it goes way more in depth
into writing Scython code. And this is just a link to the GitHub page for that tutorial.
So you can check that out later if you're interested.
Okay, so we're going to switch gears a little bit and go back to the main point,
which is we want to generate ccode. And then we want to be able to compile it and then call
it from Python. The reason we want to be able to call it from Python is we're going to use
SyPy's ODE int to integrate the equations and plot the results and everything. So Sympy's code
gen function is what's going to take the code printing and then wrap that into a c function and
a c file and write them to the file system so we can use them and compile them into an extension
module. So this is a really quick overview or review of the system we're looking at. This is the
water radiolysis system that Jason talked about. So it's a system of ordinary differential equations.
We have these 14 state variables y0 through y13. That's the left-hand side. And on the right-hand
side, we have these functions of all the state variables and possibly time, although none of
these functions actually have time in them, but in general, ODE's can. So we're going to represent
