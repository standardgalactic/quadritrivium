instead of defining function u equals function u, I can just write this.
So that way u, the variable u is always just going to be this function at tx.
And so if I'm never going to use u for anything other than calling it tx, then I can keep this
like this. It's a good idea if you never use it except in this context. Yeah.
The thing, the thing where this can trip you up now is if you try to call you,
if you try to evaluate this, this, this isn't the function. This is the function evaluated. So
you'd have to do, you know, you'd have to do subs say at t zero x one.
But yeah, if you, if you are creating differential equations, this can save typing
and mistakes and stuff. Any other questions?
All right. Matrices on you matrix, you, this uppercase n matrix function creates matrices.
There are several different ways to create a matrix. If you, if you look at the help,
you can see them, but the most simple one is just a list of lists. And you can see here this,
these are basically the rows of the matrix. So one comma two, three comma four here.
And if I pass just a, a list with one level of nesting, this is going to create a column vector.
And so matrices and SMPI can contain any, anything that can be symbolic expressions
inside of them. So here's a matrix with x, y, z. And matrices, of course, they support all the
matrix operations that you'd expect. So I can do times here. I think we're actually
running Python three, five here. So I can use this matrix multiplication operator too, if I want.
But matrix, SMPI does just use the times symbol on matrices for multiplication.
And, you know, there's a whole bunch of other advanced things you can do. For example,
I can take Jacobians. So this, this, here's the Jacobian of this matrix with respect to x, y,
z. And so now your exercise is just create, your exercise is actually three parts. So first,
create this matrix. And you're probably going to want to save it to a variable because you're
going to use it for the next part. And then second, create this matrix and multiply it with this one.
And that should give you this matrix. And then finally take the Jacobian of
your, of this matrix.
And I'm going to, I'm just going to leave this up so that you can see this part. All right. Well,
we're, I see a lot of blue sticky. So I'm going to, I'm going to jump ahead here and try to type
out this answer as fast as I can. So one, zero, one, negative one, two, three, one, two, three.
Oh, and I'm just going to call this M.
And then my vector is going to be x, y, z. And since it's a column vector, I just write a list here.
And then, so now I want to do M times V.
And let's call that A.
And so now I want to take the Jacobian
with respect to this. So I can just do Jacobian V here, or I could retype out x, y, z.
And you may notice this is, this is going to be familiar. This is the same thing as M. So
if you take a constant matrix times a, a matrix of variables, and then you take the Jacobian,
which is basically the matrix derivative, the derivative of constant times a variable is just
the constant again. Okay, so one more thing in this notebook. Question? Oh, sorry. Yes.
Okay, so if you want a row matrix here, so I can, I can type this as a nested list, x, y, z.
Just using the same syntax here. So if I have nested lists, then each list here is a row.
I can also type v.t. That'll give me the transpose of this column. Either one of those will give you
what you want. All right, so final thing is these matrix symbols. These are useful in
code generation for representing matrices in the code that you're generating.
And so now I'm here, I'm creating some integer symbols. And I have a matrix symbol M,
matrix symbol B. And this here, these second and third argument is going to be the shape of
these matrices. So I have M times, M and B here, I can take M times B. And so I see here, for example,
M dot shape. This is an N by M. M is an N by M matrix. And B is a M by one column vector.
And so I can multiply these, the shapes align. And yeah, if I take the shape of the product,
it knows that the shape is N by one. And there's different functions you can use on
matrix expressions. The transpose, for example, a lot of functions don't actually evaluate unless
you call this do it method. So you can choose whether to have a transpose evaluated or not.
And what do you think? Do we have time for this exercise? Should we skip it?
Well, I have 20 minutes for my next notebook. So if you want to do this exercise, by all means,
do it. But I'm going to skip it. And there is also some material down here if you want to learn some
more. I think our latest version of our tutorial is not actually going to use anything below
this matrix expression. So it's not something that we need to know.
All right. So now we're going to the code printers. And this is just going to be basically
kind of showing off more than anything. We're just going to show you all of
these languages that we support in SimPy. So here's a function. I chose this function because
it sort of has a good demonstration of how different languages represent things mathematically.
So absolute value sine of x squared here. And we can see how is this function represented by
different languages. And so we can just run through here. All these functions are going to take an
expression and convert them to a language. And oh, okay. Yeah. So the first one is C code.
That converts it to C. So we can see absolute value is now fabs power is this power function,
which will, fcode is Fortran, which looks remarkably like Python, which is not a coincidence.
In fact, it looks exactly like the Python code. Here we have Julia. Julia looks pretty similar
too, except they have this different power operator. JavaScript. Everything is prefixed
with Mathematica. The MATLAB printer is called Octave code, but the code generated by Octave
Toad should work with Octave or MATLAB. This Rust code is new in the latest version of SimPy.
So this is what this function looks like in Rust. Here we have R. And here we have C++.
And I forget what the default standard is for C++. Yes, Nathan?
So I think, for example, the C1 is just going to assume you have Math.h, for example.
We are going to go over later. Yeah, like, you know, if, so this is, this is sort of going back to
here. This is sort of this top level of abstraction. We're just generating expression.
So later we're going to look at, okay, what happens if we, we would not want not just the
expression, but we want some other code that goes with it, like a header and some stuff to wrap
around it. And also, if you look, all of these functions have options to them. So C code, for
example. So C code, I can change the C standard that I'm targeting. I can, you know, decide to
assign it to a variable where there's going to be T referenced, things like this.
And so, for example, f code, let's look at f code. I think, I don't think this is actually, yeah,
so these are the different Fortran standards. I think this expression is the same regardless of
what standard we use. Yeah, so the default standard is, is it 95? No, it's 77. Yeah, so
oops. So that's the default standard. This expression doesn't, doesn't matter, but other things might.
So yeah, your exercise is just play around with this, come up with some functions, see what works,
see what doesn't work, what's different for different languages. A lot of these, a lot of
these printers, some of them support more things and some buy than others. So you may run into errors
and, you know, if you have any questions or observations, feel free to raise your hand
or use the red sticky note. How are people doing? Anybody discover anything interesting?
What, which of these languages is the most different from the others?
I personally think that Rust is the most unique language here, at least in terms of its syntax.
Does anyone here consider themselves an expert in any of these, these languages?
We're only Python experts here.
Uh, so the question was, do any of the languages support derivatives? So do you mean like taking a
numeric derivative or? Oh yeah, well, so probably not.
Uh, that's something that you would get out of like a numeric library. So,
like for example, a NumPy would have a derivative function. Yeah, but
derivative would be more like a, like a sub-protein call.
Uh,
for the most part, if you have an expression and you, in Sympy, you just take a symbolic derivative
and then generate that. Okay, I'll start with you here.
So I'm getting hyperbolic tangent not supported in JavaScript.
Is it true?
It tells you something like that. Is it usually like abandon hope while you enter here or?
Well, I don't know JavaScript very well. Does, does JavaScript support hyperbolic tangent
in the math, in the math library?
If you, if you have a JavaScript library that supports it, you can,
you can extend the printer. I don't know if that's something we're going to go over
later about how to do that. Um, or if, uh, hyperbolic tangent,
what is, so, oh my gosh. Uh, so that's tan, tan H of X.
So we can use Sympy to rewrite this using exponentials and it does not do this.
So, yeah, this, this is another powerful thing about Sympy is it knows these identities.
We had a question over here.
Okay. So the question is why does Fortran put some spaces and that's a good question.
But it's because this, this Fortran printer is kind of, uh,
like that.
Oh, no, it doesn't, it doesn't know it, it doesn't know what format means.
It's, it's because it's, it's one of these things that we, we might actually end up changing.
It's because it's sort of designed for inserting into the function.
Oh, just the 90 standard doesn't do it. No.
There's a way to do it.
Yeah. So this guy, this guy standing in the back, uh, Bjorn Dahlgren is actually a Google
summer of code student this year and he's, uh, he's working on improving our code generation.
So we have a lot of sort of dusty corners like this that, that might end up being cleaned up.
Well, they're brand new. The question is why are Rust and C plus plus not in the name, name space?
Honestly, they probably could be, especially C plus plus.
I don't know what you guys think about that.
I mean, you know, given that, given that the rest of these are, I think,
I don't think there's any reason that they shouldn't be. It was probably just an oversight
when they were added. It's always that it's always easier to add something to name space than to
remove it. Are there any other questions on, otherwise I want to move on to this last exercise
for the last few minutes of my section. And this is sort of going more in depth on this
JavaScript printer. So, uh, this is just some boilerplate you should execute.
And that doesn't work. Interesting. Why don't I have the library installed? Oh, I know why.
Okay. So I'm actually, I'm actually a very bad person. I didn't actually activate the environment.
But all you guys did, so it's going to work.
You're just showing us, right? That's right.
Okay. So let's make sure this stuff's imported again.
Okay. So, yeah, and if you run this boilerplate, we've got a little,
some JavaScript template here. It's not too important what this is doing, but we're basically
using a library called chart.js, which is, you know, some fancy JavaScript thing. And we've got a
lot of boilerplate here. But if you look at this, fill me in, basically we're saying, here's two
functions f of x and g of x in JavaScript. And these are going to end up getting plotted with this
library. So let's create two functions here. So let's say the first one is sign x. The second one
is cosine x. And there's also this chart ID, which is, again, JavaScript stuff. You can just put
anything in there. And so I convert these, want to convert these to JavaScript code. So for example,
JS code f one is going to convert sine of x to JavaScript. And then so I plug that into this
JavaScript template. And yeah, so our top function now is going to be sine of x and our bottom function
is cosine of x. You know, and so, you know, maybe I can, maybe I can try different things here.
So here's cosine of x squared, for example.
And so your exercise now is here's two equations.
I don't, they're intentionally quite complicated equations. But your exercise is now to just plot
these as is your top and bottom. Yes.
So I want to print the code for matrix vector, while the i just get a start the, the reason that doesn't expand up.
So the question is you print a code for matrix in JavaScript, do you mean?
In C, for example.
In C. So the question is why does the matrix vector multiply not expand out? So it doesn't,
we're basically assuming that if you're multiplying two vectors, you're going to be using some library
to do that. So it's not really supported directly. The thing that we'll be using matrix symbols for is
sort of accessing the different elements of the matrix. So doing something more complicated
than multiplication. But yeah, so that's something, if you wanted to support just
multiplication, you would need to tell the printer, you know, what, you're, you're
simply using some matrix library to multiply for you. So you need to tell it what that function is.
And so the, let me go back, let me go back here and just show you.
And we'll get to this later. But if you look at,
I'm wondering if this saved at all.
Yeah, so if you look at this, a here, let's wait for math jacks.
Here we go. Oh, that's not the one I want. That's not even the one I want. This one. All right.
So if you look at this, M times B, this, this thing here is this mat model object. So you would,
what you would be doing is telling the printer how to print mat model objects and, you know,
you'd tell it whatever C function. And that's, that's what we're going to go over later.
The other questions, it looks, I see a lot of blue sticky. So I think I'm just going to
go over this. This is, we basically just copy paste here. And so this is going to be
our top function, the bottom function. And so these crazy equations,
and I'm plotting something like looks like this. These are the, the Batman equations.
All right. So are there any other questions on the
last two notebooks that I went over? Yes.
There is a Python code printer, but it's something that needs to be
cleaned up actually. So we didn't include it in the tutorial. Right now, right now there isn't
actually like a very clear just Python versus Sympy code printer. It's something that we were
going to try to clean up, but I guess we didn't get to it. But yes, you can definitely co-generate
to Python itself or to Python with NumPy or Python with SyPy. Do you have a question?
Yeah. So on the plotting, on the one x-axis, all of the labels are really long decimal numbers,
like the sine and cosine functions. They'd be really great if they could be in terms of pi.
Is there any way to make the labels in terms of pi? Is that really long?
Well, it's, it's whatever's, whatever's going on in this charting library. I didn't write this
JavaScript template. So you would need to, you would need to tell chart.js whatever,
how to, how to get the labels. Yeah, the question was about these, these, making these labels look
like something nicer than just long floating point numbers.
All right. Well, if there's no more questions, that's the conclusion of my section.
Who's next, Bjorn? So what, the question now that we'll have to decide on is, are we going to,
do we feel like we need to break now or should we break after Bjorn's section in an hour?
All right. So yeah, quick five minute break and then Bjorn.
As Aaron said, I'm actually working this summer on a scholarship from, from Google,
on Google summer code to, to work on the code generation capabilities of Sympi.
So we had a question about the Python printer. So there is a Python printer, but it prints code
that assumes that we already have Sympi in the namespace. So that's quite suboptimal.
We're, we're working on changing that. So my name is Bjorn and I'm a PhD student
in chemistry, computation chemistry, Stockholm, Sweden. And my part here will actually be looking at
the easy way. So we're going to try to use functions that generate Python functions.
