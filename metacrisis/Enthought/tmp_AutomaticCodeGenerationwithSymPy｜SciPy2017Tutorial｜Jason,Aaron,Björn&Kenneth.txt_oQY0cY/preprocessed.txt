Okay, so who are we? My name is Aaron Muir. I'm a researcher at the University of California
of South Carolina, and I'm also a lead developer of SimPy. Jason Moore in the red shirt back
there is a faculty, mechanical, and aerospace engineer at University of California Davis,
and he's also a SimPy developer, and also a developer of a library called PiDyn. Bjorn
Tolgren here in the green shirt is a Ph.D. student at KTH Royal Institute of Technology
in Sweden, and also a SimPy contributor. And finally Kenny Lyons, I guess he's over back
here in the red, Ph.D. student at University of California Davis. So this tutorial we're
going to be learning about code generation with SimPy. Some basic SimPy knowledge is
going to be assumed, although we are going to do a refresher. SimPy, if you don't know,
it's a library for symbolic mathematics, so we just did a big release a couple days ago.
If you did the installation correctly and your test script passes, that means you have
it. So just a quick, what do we mean by code generation for this tutorial, or just code
generation? And for our purposes, this means taking a SimPy expression and converting it
to some other language, into code for some other language. So for example, here's a
SimPy expression representing some mathematical formula, absolute value, sine of pi x, and
this is the equivalent C code. And so code generation, basically you start with the left
side, and you want to get the right hand, the right side here. You want to do that automatically.
So SimPy supports quite a few languages. If you're targeting or want to target any of
these languages, we have support, C, C++, Fortran, MATLAB Octave, Python, Via NumPy,
SciPy, Julia, Mathematica, JavaScript, LVM, Rustiano, TensorFlow, and it's very easy
to write extensions to these, or basically to extend to whatever language you want. So
this is sort of how I think of code generation, the workflow. Basically you've got three
steps, and the first step is you're using SimPy to sort of help you model your problem
mathematically using symbolic capabilities. So you're basically using it to derive formulas
that represent whatever it is you're trying to do. And then the code generation step is
you want to take those formulas and convert them to something that can be numerically
evaluated. And then at that point you use the thing that you code generation to actually
solve your problem. And so code generation is this middle, this translation step from
sort of the modeling stage to the actual solving of the problem. And at the other
layer here, there's several different abstraction levels for SimPy code generation, depending
on how much you want SimPy to do for you and how much you want to do yourself. And it's
actually upside down. So at the bottom here, basically SimPy is going to create a Python
callable. So if everything's in Python, you just take your SimPy expression, pass it to
one of these functions. I think auto-rep should be in here too, which is what we're going
to be showing you today. And it's going to do some magic, and then it's going to spit
out a function, and that function is going to be a fast numeric version of your expression.
On top of abstraction layer below that is you actually want to generate some code, a
larger block of code, but maybe generate the whole function in some language, say in C.
And this is going to be like the code gen module. And then the most basic level of abstraction
is you're just generating the expression. And then this expression is going to go somewhere
else in some other code that you've already written. So here are a few reasons why code
generation is something that you might want to consider doing. First off, SimPy is a symbolic
library. It's a very powerful library. It can deal with expressions in very high level
way. It can do things symbolically like take derivatives, or it can solve equations, or
take integrals, or do all sorts of things. By doing things automatically, you can avoid
mistakes. So doing things naively, if you're just writing out your C code by hand, you're
going to end up making a typo, a sign error somewhere. By doing things in this higher
level way, you can avoid that because SimPy is basically deriving the formulas for you.
You can deal with insanely large expressions. I don't know if we're going to show that
today, but you can have expressions that are literally millions of lines of code would
be literally impossible to do by hand because it's very large, but computers are very good
with doing bookkeeping. Then the final is, which I also don't know if we're going to
be talking about today, but just something to sort of think about. SimPy is a very smart
library. It can sort of simplify expressions in ways that standard C compilers or Fortran
compilers don't know how to do. It can do things like trigonometric simplification. It
knows how to factor polynomials, things like this. Here's a quick outline for today. We're
going to try to get through as much as we can. We're going to start with just a refresher
for SimPy. We're going to go over some code printers. We're going to look at the easy
way to do code generation, which is sort of this higher level abstraction I was talking
about. Then we're going to go sort of lower abstractions and the harder way basically.
Then we're going to look at doing some sithinization. We have bonus material this time. Don't be afraid
to slow us down. Raise your hand. Jason, do you want to go over the sticky notes maybe
at this point? We just passed each of you a blue and a red sticky note. We're going
to use those during the exercises. You may be familiar with this from Salford Carpentry
or other workshops. When we ask you to do an exercise, when you're done, you'll place
a blue sticky note on your laptop so we know how many people are done. Then if you need
help at any time, just put a red sticky note. One of the helpers, everybody raised their
hand that's going to help today. The four presenters, we have Mark in the yellow shirt
and Alan, I think. Are you going to help too? Alan in the corner? All of us will be here
to give everybody a hand. Sartaj too. He's a SimPy dev. We'll put those red sticky notes
up and we'll come around and help you out. All right. Let's jump in and find, is this
the live version? Let's start with this intro to SimPy expressions notebook here. This is
going to be a refresher. If you need me to slow down, just tell me to slow down. Quick
introduction to SimPy. First step, if you're using SimPy in the notebook, you generally
want to use this in the printing function. That's going to make it so that things print
as LaTeX instead of as strings. It's going to be much easier to see what's going on with
SimPy expressions. The most basic SimPy object are symbols. You create them with the symbols
function and you assign them to Python variables. Here I'm creating symbols x, y, and z. Also,
is the font size okay? Do we need to go up, down? I doubt we need to go down. Is that
hopefully better? Okay, good. Here I've created three symbols x, y, and z. Now I can use these
to create expressions, for example. If symbols is actually pretty smart as far as the LaTeX
printing goes. For example, here I've created a symbol, symbol is alpha 1, omega underscore
2. It recognizes that these are Greek letters. It recognizes that these numbers are subscripts
on the symbols. Here's an example expression with SimPy. Did you just build it up naturally?
Your first exercise now is here's a moderately complicated, hopefully not too complicated
expression. You may recognize this function. If you don't recognize it, it comes from the
normal distribution. Your exercise is simply to just create this expression in SimPy. When
I don't have it here, but the square root function is sqrt. Go ahead and use the sticky
notes when you're ready. I guess I'm just going to go over it now. The first thing is
we already defined x, y, z up here. We have x already defined, but there's two other symbols
in here that we don't have to find, the sigma and this mu. Pi is not going to be a symbol
here because pi is a number. Pi is already defined by SimPy as this number, but we don't
have sigma defined yet. Sigma and mu are symbols. Then I'm just going to basically just type it out
as I see it. One over the square root of two times pi times sigma squared times, and then
exponential is just exp. exp to the negative x minus mu squared over, and then I need parentheses
here to group this denominator, two times sigma squared. You see SimPy has done some automatic
simplification, but it's the same expression if you look closely. So are there any questions on this?
Yes.
Ah yeah, so the question is it didn't simplify this sigma squared, and the reason for that is that
the square root of x squared is not equal to x in general. This is only true if x is
positive number, and so we didn't tell SimPy anything here about sigma. So as far as SimPy,
no, sigma is just some complex number, and it's only going to do these simplifications
based on what it knows is true for all complex numbers. So if I knew, for instance, that these
were positive, I can type positive equals true here in the symbols function. These are called
assumptions. I don't think we're going to be using assumptions a whole lot today, but this is one way
to get SimPy to do some of these simplifications, especially relating to this square root of x
squared deal. And if I do that, now you can see it knows the square root of sigma squared is just sigma.
So good question. Thank you for bringing that up.
All right, so now I want to go over just some important things that can trip you up using SimPy.
These trip up everybody. So I think that one of them already tripped somebody up.
At least one person up in here, probably a few of you. So when SimPy evaluates an expression,
basically Python just evaluates it, and SimPy has operator overloading. But when Python sees
sort of this integer divided by integer here, this one over two here gets evaluated before
SimPy ever gets kicked in. And what Python is going to do to this is going to create a floating
point number. So you can see here we have x plus 0.5, which is sometimes that's fine for what you
want. But often, SimPy works better if you use exact rational numbers instead of floating point
numbers. And so the trick here is you just use the, you can use either one of these forms. You
can use x plus this little s function. Basically, this is going to convert this one into a SimPy
number, and then it knows that SimPy number divided by two gives a rational, or I can do x plus
the rational number one half. And so now we get an exact number. And this is only an issue if
you're dividing basically integer literals, because Python evaluation order basically kicks in.
So if you have an issue where you're getting floats where you don't want them,
you can just wrap your integers with this s function. Second gotcha, which hopefully you
knew this before this previous exercise. But in Python, the carrot is not the power operator,
and SimPy follows Python conventions. So carrot is actually XOR. This is a logic expression right
here, which is not what you want. So you have to use this double star.
And then the final gotcha. All SimPy expressions are immutable. So if you just remember that.
So no function anywhere in SimPy is going to change the SimPy expression in place. It's going
to always return a new expression. So right here, I've taken this thing x plus one, I've
assigned it to the variable expert. And now I'm using this function subs to evaluate that at x
equals two. And so that gives me three. But this does not change the original expression expert.
I still have x plus two on here. So this subs is returning new thing here.
Okay, are there any questions on what we've done so far?
All right. So the next thing is floating point numbers. SimPy, in addition to doing symbolics,
has the ability to evaluate numeric expressions, exact numeric symbolic expressions. It's a
floating point number. So here's the exact expression for square root of two. And if I
use the eval-f function, that's going to give me a float. And here, if I just do eval-f,
I get a float. If you put a number here, like seven, that's going to give me a floating point
number with seven digits. So, and SimPy has arbitrary precision. So I can put any number
here I want. I can put 100. Get 100 digits of this.
All right. So now your exercise is to compute 100 digits of pi.
Okay. See a lot of blue sticky notes. Not intended to be a difficult exercise, by any means.
So yeah, we just take pi and call it the eval-f method on it with 100 as its argument.
And here are the first 100 digits of pi. And of course, if you want, you can play around with it.
You can do 10,000 digits of pi. Eventually, it's going to start taking a little longer
to compute all those digits. But there you go.
What are we doing actually? Oh, okay. So the next thing to go over to, as a review, is the
undefined functions. So up here, the symbols, these create these variables.
But if you want to have something that actually depends on another variable,
then you need to create a function. And this is important whenever you want something
basically to have a derivative that depends on a variable, is typically where this ends up
getting used, at least in terms of code generation. And so this is function.
You call function and then the name of the function. And so that creates a function called f.
This is an undefined function. And so now I can create expressions with f of x.
And so now this gets used by the, we'll see here, it gets used by the derivative functionality.
So to take symbolic derivatives, we use the diff function.
And then diff, the syntax is you just do diff and then the variables that you want to differentiate.
So here we have this expression sine x plus one times cosine y. We're going to take the
derivative with respect to x and then the derivative with respect to y.
And so, you know, if I do this stepwise, here's a derivative with respect to x.
Here's a derivative of this now with respect to y. And this also works with undefined functions.
So if you want to build an ODE, this is how you build an ODE. Basically,
you take the derivative of an undefined function, which is going to be our next step, actually.
So your exercise now is to basically write an equation for this, this wave equation.
And remember here, this is sort of implicit in the way this is written. But this u here
is not going to be a symbol because u depends on two variables. It depends on t and x.
And then one final thing is if you want to write something with an equal sign here,
you can use this eq function. So go ahead and do this exercise.
All right. Well, so I'm going to go over it. So the first thing is we need to define this u
function. So u is just function u. And then u is going to be a function of two variables.
And I'm sort of free how to write that, but I'm just going to write it like this.
And we can see already that t is not defined. We never define t. And we also notice up here
that we didn't define c either. So I'm going to just define those. t and c are t and c.
And so now I have a function of t and x. And so I'm going to create and use this eq
object. And so the left hand side is the derivative of this with respect to t twice.
And the right hand side is c squared times the derivative of u of tx with respect to x twice.
And just to show you something here, you can either write t comma t or you can write
you can just write the number after the variable for the number of times to take the derivative.
Any questions? I'm going to leave that up there for just a little bit.
I have a question. You could have been a function of t on the left and a function of x
on the right. That's right. Still wouldn't have worked, but I'm assuming that we mess us up later.
Well, yeah. So I mean, I can also, I mean, you need to be consistent.
Sympi, this undefined function doesn't, Sympi doesn't know anything about it at this point.
It doesn't know how many variables it has. It doesn't know, you know, what variables it's supposed
to be with respect to. So yeah, I could have, I could have, I could have also written this whole
thing as x comma t, if that makes more sense to you. No, even worse, like only a function of x
on the left or only a function of t on the left. Oh, okay. Well, yeah. So that would be wrong.
That would actually, that's not what this equation means. And you can see here, it's,
so let me, let me actually show this.
So if you notice the difference here, Sympi is even printing these differently.
This one is printing to D. This one's printing a partial. So this one is, this one here is a
partial differential equation. This one is some weird ODE where we've used a different variable
on the left-hand side and the right-hand side. But this is not the, this is not the same thing
as this. So, you know, this is, this is what you get on Wikipedia. And, you know, they tend to
leave out the, of t and comma x everywhere because it gets tedious when you're writing it down. But
Sympi needs to know that what variables it depends on. And yeah, we can write things that
don't really make sense physically, but they make sense mathematically. You know, I can write
you know, I can pretend like it's just one variable here. I can get my variables backwards.
So you need, you need to keep things straight. One thing that helps if you're writing
differential equations, let me actually cut this. Let me delete this. So one thing you can do
instead of defining function u equals function u, I can just write this.
So that way u, the variable u is always just going to be this function at tx.
And so if I'm never going to use u for anything other than calling it tx, then I can keep this
like this. It's a good idea if you never use it except in this context. Yeah.
The thing, the thing where this can trip you up now is if you try to call you,
if you try to evaluate this, this, this isn't the function. This is the function evaluated. So
you'd have to do, you know, you'd have to do subs say at t zero x one.
But yeah, if you, if you are creating differential equations, this can save typing
and mistakes and stuff. Any other questions?
All right. Matrices on you matrix, you, this uppercase n matrix function creates matrices.
There are several different ways to create a matrix. If you, if you look at the help,
you can see them, but the most simple one is just a list of lists. And you can see here this,
these are basically the rows of the matrix. So one comma two, three comma four here.
And if I pass just a, a list with one level of nesting, this is going to create a column vector.
And so matrices and SMPI can contain any, anything that can be symbolic expressions
inside of them. So here's a matrix with x, y, z. And matrices, of course, they support all the
matrix operations that you'd expect. So I can do times here. I think we're actually
running Python three, five here. So I can use this matrix multiplication operator too, if I want.
But matrix, SMPI does just use the times symbol on matrices for multiplication.
And, you know, there's a whole bunch of other advanced things you can do. For example,
I can take Jacobians. So this, this, here's the Jacobian of this matrix with respect to x, y,
z. And so now your exercise is just create, your exercise is actually three parts. So first,
create this matrix. And you're probably going to want to save it to a variable because you're
going to use it for the next part. And then second, create this matrix and multiply it with this one.
And that should give you this matrix. And then finally take the Jacobian of
your, of this matrix.
And I'm going to, I'm just going to leave this up so that you can see this part. All right. Well,
we're, I see a lot of blue sticky. So I'm going to, I'm going to jump ahead here and try to type
out this answer as fast as I can. So one, zero, one, negative one, two, three, one, two, three.
Oh, and I'm just going to call this M.
And then my vector is going to be x, y, z. And since it's a column vector, I just write a list here.
And then, so now I want to do M times V.
And let's call that A.
And so now I want to take the Jacobian
with respect to this. So I can just do Jacobian V here, or I could retype out x, y, z.
And you may notice this is, this is going to be familiar. This is the same thing as M. So
if you take a constant matrix times a, a matrix of variables, and then you take the Jacobian,
which is basically the matrix derivative, the derivative of constant times a variable is just
the constant again. Okay, so one more thing in this notebook. Question? Oh, sorry. Yes.
Okay, so if you want a row matrix here, so I can, I can type this as a nested list, x, y, z.
Just using the same syntax here. So if I have nested lists, then each list here is a row.
I can also type v.t. That'll give me the transpose of this column. Either one of those will give you
what you want. All right, so final thing is these matrix symbols. These are useful in
code generation for representing matrices in the code that you're generating.
And so now I'm here, I'm creating some integer symbols. And I have a matrix symbol M,
matrix symbol B. And this here, these second and third argument is going to be the shape of
these matrices. So I have M times, M and B here, I can take M times B. And so I see here, for example,
M dot shape. This is an N by M. M is an N by M matrix. And B is a M by one column vector.
And so I can multiply these, the shapes align. And yeah, if I take the shape of the product,
it knows that the shape is N by one. And there's different functions you can use on
matrix expressions. The transpose, for example, a lot of functions don't actually evaluate unless
you call this do it method. So you can choose whether to have a transpose evaluated or not.
And what do you think? Do we have time for this exercise? Should we skip it?
Well, I have 20 minutes for my next notebook. So if you want to do this exercise, by all means,
do it. But I'm going to skip it. And there is also some material down here if you want to learn some
more. I think our latest version of our tutorial is not actually going to use anything below
this matrix expression. So it's not something that we need to know.
All right. So now we're going to the code printers. And this is just going to be basically
kind of showing off more than anything. We're just going to show you all of
these languages that we support in SimPy. So here's a function. I chose this function because
it sort of has a good demonstration of how different languages represent things mathematically.
So absolute value sine of x squared here. And we can see how is this function represented by
different languages. And so we can just run through here. All these functions are going to take an
expression and convert them to a language. And oh, okay. Yeah. So the first one is C code.
That converts it to C. So we can see absolute value is now fabs power is this power function,
which will, fcode is Fortran, which looks remarkably like Python, which is not a coincidence.
In fact, it looks exactly like the Python code. Here we have Julia. Julia looks pretty similar
too, except they have this different power operator. JavaScript. Everything is prefixed
with Mathematica. The MATLAB printer is called Octave code, but the code generated by Octave
Toad should work with Octave or MATLAB. This Rust code is new in the latest version of SimPy.
So this is what this function looks like in Rust. Here we have R. And here we have C++.
And I forget what the default standard is for C++. Yes, Nathan?
So I think, for example, the C1 is just going to assume you have Math.h, for example.
We are going to go over later. Yeah, like, you know, if, so this is, this is sort of going back to
here. This is sort of this top level of abstraction. We're just generating expression.
So later we're going to look at, okay, what happens if we, we would not want not just the
expression, but we want some other code that goes with it, like a header and some stuff to wrap
around it. And also, if you look, all of these functions have options to them. So C code, for
example. So C code, I can change the C standard that I'm targeting. I can, you know, decide to
assign it to a variable where there's going to be T referenced, things like this.
And so, for example, f code, let's look at f code. I think, I don't think this is actually, yeah,
so these are the different Fortran standards. I think this expression is the same regardless of
what standard we use. Yeah, so the default standard is, is it 95? No, it's 77. Yeah, so
oops. So that's the default standard. This expression doesn't, doesn't matter, but other things might.
So yeah, your exercise is just play around with this, come up with some functions, see what works,
see what doesn't work, what's different for different languages. A lot of these, a lot of
these printers, some of them support more things and some buy than others. So you may run into errors
and, you know, if you have any questions or observations, feel free to raise your hand
or use the red sticky note. How are people doing? Anybody discover anything interesting?
What, which of these languages is the most different from the others?
I personally think that Rust is the most unique language here, at least in terms of its syntax.
Does anyone here consider themselves an expert in any of these, these languages?
We're only Python experts here.
Uh, so the question was, do any of the languages support derivatives? So do you mean like taking a
numeric derivative or? Oh yeah, well, so probably not.
Uh, that's something that you would get out of like a numeric library. So,
like for example, a NumPy would have a derivative function. Yeah, but
derivative would be more like a, like a sub-protein call.
Uh,
for the most part, if you have an expression and you, in Sympy, you just take a symbolic derivative
and then generate that. Okay, I'll start with you here.
So I'm getting hyperbolic tangent not supported in JavaScript.
Is it true?
It tells you something like that. Is it usually like abandon hope while you enter here or?
Well, I don't know JavaScript very well. Does, does JavaScript support hyperbolic tangent
in the math, in the math library?
If you, if you have a JavaScript library that supports it, you can,
you can extend the printer. I don't know if that's something we're going to go over
later about how to do that. Um, or if, uh, hyperbolic tangent,
what is, so, oh my gosh. Uh, so that's tan, tan H of X.
So we can use Sympy to rewrite this using exponentials and it does not do this.
So, yeah, this, this is another powerful thing about Sympy is it knows these identities.
We had a question over here.
Okay. So the question is why does Fortran put some spaces and that's a good question.
But it's because this, this Fortran printer is kind of, uh,
like that.
Oh, no, it doesn't, it doesn't know it, it doesn't know what format means.
It's, it's because it's, it's one of these things that we, we might actually end up changing.
It's because it's sort of designed for inserting into the function.
Oh, just the 90 standard doesn't do it. No.
There's a way to do it.
Yeah. So this guy, this guy standing in the back, uh, Bjorn Dahlgren is actually a Google
summer of code student this year and he's, uh, he's working on improving our code generation.
So we have a lot of sort of dusty corners like this that, that might end up being cleaned up.
Well, they're brand new. The question is why are Rust and C plus plus not in the name, name space?
Honestly, they probably could be, especially C plus plus.
I don't know what you guys think about that.
I mean, you know, given that, given that the rest of these are, I think,
I don't think there's any reason that they shouldn't be. It was probably just an oversight
when they were added. It's always that it's always easier to add something to name space than to
remove it. Are there any other questions on, otherwise I want to move on to this last exercise
for the last few minutes of my section. And this is sort of going more in depth on this
JavaScript printer. So, uh, this is just some boilerplate you should execute.
And that doesn't work. Interesting. Why don't I have the library installed? Oh, I know why.
Okay. So I'm actually, I'm actually a very bad person. I didn't actually activate the environment.
But all you guys did, so it's going to work.
You're just showing us, right? That's right.
Okay. So let's make sure this stuff's imported again.
Okay. So, yeah, and if you run this boilerplate, we've got a little,
some JavaScript template here. It's not too important what this is doing, but we're basically
using a library called chart.js, which is, you know, some fancy JavaScript thing. And we've got a
lot of boilerplate here. But if you look at this, fill me in, basically we're saying, here's two
functions f of x and g of x in JavaScript. And these are going to end up getting plotted with this
library. So let's create two functions here. So let's say the first one is sign x. The second one
is cosine x. And there's also this chart ID, which is, again, JavaScript stuff. You can just put
anything in there. And so I convert these, want to convert these to JavaScript code. So for example,
JS code f one is going to convert sine of x to JavaScript. And then so I plug that into this
JavaScript template. And yeah, so our top function now is going to be sine of x and our bottom function
is cosine of x. You know, and so, you know, maybe I can, maybe I can try different things here.
So here's cosine of x squared, for example.
And so your exercise now is here's two equations.
I don't, they're intentionally quite complicated equations. But your exercise is now to just plot
these as is your top and bottom. Yes.
So I want to print the code for matrix vector, while the i just get a start the, the reason that doesn't expand up.
So the question is you print a code for matrix in JavaScript, do you mean?
In C, for example.
In C. So the question is why does the matrix vector multiply not expand out? So it doesn't,
we're basically assuming that if you're multiplying two vectors, you're going to be using some library
to do that. So it's not really supported directly. The thing that we'll be using matrix symbols for is
sort of accessing the different elements of the matrix. So doing something more complicated
than multiplication. But yeah, so that's something, if you wanted to support just
multiplication, you would need to tell the printer, you know, what, you're, you're
simply using some matrix library to multiply for you. So you need to tell it what that function is.
And so the, let me go back, let me go back here and just show you.
And we'll get to this later. But if you look at,
I'm wondering if this saved at all.
Yeah, so if you look at this, a here, let's wait for math jacks.
Here we go. Oh, that's not the one I want. That's not even the one I want. This one. All right.
So if you look at this, M times B, this, this thing here is this mat model object. So you would,
what you would be doing is telling the printer how to print mat model objects and, you know,
you'd tell it whatever C function. And that's, that's what we're going to go over later.
The other questions, it looks, I see a lot of blue sticky. So I think I'm just going to
go over this. This is, we basically just copy paste here. And so this is going to be
our top function, the bottom function. And so these crazy equations,
and I'm plotting something like looks like this. These are the, the Batman equations.
All right. So are there any other questions on the
last two notebooks that I went over? Yes.
There is a Python code printer, but it's something that needs to be
cleaned up actually. So we didn't include it in the tutorial. Right now, right now there isn't
actually like a very clear just Python versus Sympy code printer. It's something that we were
going to try to clean up, but I guess we didn't get to it. But yes, you can definitely co-generate
to Python itself or to Python with NumPy or Python with SyPy. Do you have a question?
Yeah. So on the plotting, on the one x-axis, all of the labels are really long decimal numbers,
like the sine and cosine functions. They'd be really great if they could be in terms of pi.
Is there any way to make the labels in terms of pi? Is that really long?
Well, it's, it's whatever's, whatever's going on in this charting library. I didn't write this
JavaScript template. So you would need to, you would need to tell chart.js whatever,
how to, how to get the labels. Yeah, the question was about these, these, making these labels look
like something nicer than just long floating point numbers.
All right. Well, if there's no more questions, that's the conclusion of my section.
Who's next, Bjorn? So what, the question now that we'll have to decide on is, are we going to,
do we feel like we need to break now or should we break after Bjorn's section in an hour?
All right. So yeah, quick five minute break and then Bjorn.
As Aaron said, I'm actually working this summer on a scholarship from, from Google,
on Google summer code to, to work on the code generation capabilities of Sympi.
So we had a question about the Python printer. So there is a Python printer, but it prints code
that assumes that we already have Sympi in the namespace. So that's quite suboptimal.
We're, we're working on changing that. So my name is Bjorn and I'm a PhD student
in chemistry, computation chemistry, Stockholm, Sweden. And my part here will actually be looking at
the easy way. So we're going to try to use functions that generate Python functions.
And we're going to, I'm going to apply it to a few examples. So a raise of hands,
how many people here are familiar and feel comfortable working with ordinary differential
equations? All right. So that's the vast majority. So we're going to skip the notebook on ordinary
differential equations. And those of you who need a refresher, you can have a look at that notebook.
So we're going to skip ahead then straight to the notebook called Lambda Phi.
So Aaron showed us some examples where we could evaluate expressions numerically.
And he did so using the eval F method. So if we import Sympi into our namespace
and just take an arbitrary function, depending on two variables, so mapping R2 to R1,
we can run the subs command and exchange our variables.
Oh, yeah, sure.
Is this better? All right. So running the subs command
and eval F gives us a numeric value for this expression. The problem with doing this is that
it's quite slow. This eval F is a general arbitrary precision function. So if we would time this one,
we see that it takes almost a millisecond for each call.
And if we compare that to a pure Python function of the same, representing the same equation,
we see that it runs in three microseconds. So if we're doing this in a tight loop,
doing some numerical computations, this becomes problematic. So and we don't want to write this
Python function by hand. So there's a function in Sympi called Lambda Phi that generates Python code,
executes the eval function on it, and gives us back a working function.
So running Lambda Phi gives us g. And if we time the g function,
we see that it's just as fast as the Python version.
Another good thing about using Lambda Phi is that you can change what back end it targets.
So we can have it generate functions using NumPy functions, which then broadcasts to arrays of
arbitrary shapes. So if we run Lambda Phi, and as of the latest version, Sympi, which you all have,
the default is that it's going to use the NumPy back end when available.
We can see that we can give H an array here, and it will give you
an answer which has the same shape. So this is the NumPy broadcasting that kicks in.
And this is just to show this once more. If we have two arrays, one or two vectors,
a column vector, and a row vector, and give this function those vectors,
it will do the NumPy broadcasting for you. So the out shape is the number of rows in
the row vector and the number of columns in the column vector.
Sometimes it is important that you have control over the function signature
of the function that's generated by Lambda Phi. It can be because you're using a numeric solver
from the Sympi library, and it has certain requirements on the signature.
To specify this, we just give an arbitrarily nesting of our arguments in the first argument
passed to Lambda Phi. So in this case, we will have a symbol Z, which is actually
a tuple of three symbols. And it means that the function generated by Lambda Phi here,
function two, will expect to get a length three tuple as its third argument.
So this works as expected. So now it's time for you to do an exercise,
and we have this little exercise line magic in the Python notebooks. So if you run the first few cells
and evaluate the exercise cell once, it will expand, and you need to fill in
the triple question marks here. If you want to take a sneak peek on the solution,
you can rerun that same expansion, but instead of using that exercise magic, you can use the load magic.
So this would give you the solution, but I'm not going to run that one.
So yeah, give it a shot and put up the blue sticky notes when you're done.
Yeah, so it was a good remark that we got we can change this matplotlib inline to be
matplotlib notebook. And if you change that, you actually get an interactive widget,
which allows you to manipulate the data and look at it from different angles.
Question?
Oh yeah, I think most people are getting done. So let's let's take a look at the solution.
So getting the partial derivative there, the mixed partial derivative, we need to
write x and y, and the function which we're interested in is the lambda phi function.
And running, we can first run this with an inline. It will give us a PNG image, which is static.
So I can't really rotate the axis, I can't zoom, I can't do anything with it.
If I rerun this with a matplotlib notebook magic,
it might have to rerun it.
Okay, all right.
Oh yeah, yeah, there we go. Thanks. So now you can actually grab this and
supposedly you can, yeah, you can actually rotate the graph and it rerun this as this
three-dimensional picture and you get a sense of the depth. All right, so that was our exercise
notebook on the lambda phi function. Let's now take a look at the next notebook and see how we can
apply this to an example from chemistry. So let's move to the chemical kinetics introduction notebook.
All right, so chemical kinetics, it's actually a study of the time evolutions of concentrations
in reactive systems where we have competing chemical reactions occurring. So we will be
looking at a rather simple but yet interesting chemical reaction, and it's
the formation and breakdown of this molecule, nitrous or bromide.
But before we look at that actual case, we need to look at the governing equations.
So the most rates of chemical reactions follow the law of mass action.
So that the rate of change is proportional to the concentration of the reacting species,
raised to the power of the multiplicity, which they are appearing on the reacting side.
And then we can formulate ordinary differential equations as a sum of contributions from all
the different directions. And for a constant temperature and pressure, there's a coefficient
which is the rate constant, which as you hear is constant, but it's often under the assumption at
least constant temperature. So the law of mass action looks like this, and studying this chemical
reaction, we have two processes, a forward process forming nitrous or bromide, and a backward process
where it decomposes into three constituents, two NO molecules and one BR2. And we were just going to
rename this to C1, C2 and C3, the concentrations. So NO, BR2 and NO, BR are just one, two and three,
those are the chemical species. And applying this law of mass action gives us then this system
of ordinary differential equations. So it's a free state problem. You can actually reduce this by
applying such, mass is preserved, for example, so that gives you a relation so you can reduce the
number of states here, but we're not going to look into that. And that above equation
had two matrices in it, this S and R matrix, but the details are not that important right now.
So we're going to look first, how can we just write this using non pi, psi pi, not using
sin pi, and then we will look at what can actually sin pi do for us, which helps.
So doing this numerically, we will be using a numeric solar from the psi pi library called
ODE int. Raise your hands how many people have used this or another solar for ODE's in psi pi.
Okay, so then what it needs is that we need to have the right hand side of our system of
ordinary differential equations, that is these three expressions. So we need to have a function
evaluating these three expressions. So in this case, it's just hard coded. We say that
we have two reactions forward and backward. They have this form from the low or mass action,
and we just return a list of size three, which is the numeric value of the derivative.
Of each concentration with respect to time.
And if you look at the function RHS, the right hand side here, we see that it has this signature,
that it takes Y, which is state vector, and then a scalar T, and then two scalars. And it can be
any number of parameters passed to the solar. The important thing with this trailing
arguments is that there are parameters which stay constant during the time of integration.
All right, so it's time for an exercise.
So you're supposed now to
give the arguments to ODE int. So this has not anything to do with simpi in particular. It's
just reading the documentation string for ODE int. You can do so maybe the easiest way to do it
is to insert the cell and write ODE int, and then a question mark, and then
it executes, and you get the documentation.
All right, I think most people are getting there. So in this case, the arguments are named quite
nicely. The first argument is the function, which needs to be called, and that's our right
hand side function. And then it's the initial state vector, what we start with,
and then we need to specify the time points for this. Where are we interested in getting this
state vector? At what times do we want to know the concentrations? So that would be our T out
argument. Then the tricky part might be how to specify these arguments. So in this case,
it's just a tuple or K values. So that's K values.
All right, so the integration is done, so we can plot the solution.
And yeah,
it looks good. Nothing words happening. This one can actually be solved analytically,
and Sympi can do it for us, but we're not going to look at that here. And writing this right hand
sign function by hand, well, it wasn't that bad for this system, but the number of terms
increases rapidly as the number of species and as the number of reactions
increase in your system. So you usually want to do that by some system. And if you choose to
represent it using Sympi, you get additional benefits, as you will see.
So we're going to construct it symbolically, and then we're going to have Sympi generate a function
using Lambda Phi, and then we'll look at what more can be done here.
So this is also a nice feature of using Sympi in your workflow, that if you generate symbols and
symbolic expressions, you know that you can take the LaTeX output from these equations and put it
in a paper or a report, and you will know that the equations in the report are exactly those
that you used when you ran your simulations, because it's, at least to me, it happens every
now and then that you write one thing in the paper, and in reality, it was a minus sign in the code
or something. By the way, the LaTeX, if you want LaTeX output from that expression, the function
is called LaTeX, and every time you string it, it's LaTeX.
Yeah, so for example here, we can look at the first element in this
vector, we can just run the LaTeX command there. Okay, so it's time for another exercise.
Now we're just going to construct the function from this symbolic expression.
All right, I think most people are getting there, so what we need to
remind ourselves of is that the ODE int function from the Sympi library, it needed a special
signature, right? So if we look back at the right-hand side function, we see that we have
a state vector and then free scalars, where the two last scalars are the arguments
or the integration parameters, which take constant during the time of integration.
We can construct those by adding, making a tuple called arcs maybe, and have it be the
symbol's y, t, and then we add the tuple of the k values, and this will then look like this.
Oh yeah, the symbol's t needs to be defined.
All right, so that gives us the same solution, so this didn't add that much, but for a large
class of problems when dealing with initial value problems with ordinary differential
equations, these problems may become stiff, and when they are stiff, you need to use an implicit
solver, and the implicit solver would need a Jacobian of the right-hand side. That is,
we need to form the matrix where we take the partial derivatives of each of the rate equations
with respect to each state, and Sympi can generate this quite easily for us. We just
write Jacobian, and it's done, and then we can use this together with lambda phi to give us an
analytic expression or a function evaluating the analytic Jacobian, and this can be the
difference between a successful integration and a failed one, because what the solver usually does,
or what it does if it wants to use an implicit solver, and it does not have an analytic Jacobian,
is that it's going to be using finite differences, and depending on the scale, the scaling of the
variables of the problem, these finite differences may or may not be accurate enough, so it can really
be a dramatic difference to give this function. All right, so then we're going to take a look at
the final notebook for this part of the tutorial, the easy part, and it's more of the same, it's
still chemical kinetics, and we will be looking at how to construct the expressions symbolically from
the start, because this time we had the right-hand side function, and we had already done the work
of transforming or hard coding the right-hand side of the ordinary differential equations into
Python, and we don't want to do that, we want to have some domain-specific representation
and just from that construct our equations symbolically.
So in this notebook we will be looking at
the Robertson's example, so it's an example from the 60s, it's chemical kinetics,
and it's interesting because it's a stiff problem, so it's been a challenge, even though it's just a
free-state problem, it's just, it only has three variables, it's been a somewhat of a benchmark
for numerical ODE solvers, so we have three chemical species, A, B, and C, and there are three
reactions, one is the decay of A into B, one reaction is between B and C, forming A and C,
so C acts as what's known as a catalyst, it is not consumed in this reaction,
and the final reaction, which is a bimolecular reaction converting two B molecules into B and C,
and what you can say by just looking at these three reactions is that C is never consumed, right?
The only time C is on the reacting side is in the second reaction, and there it's reformed,
so this system will have a solution at infinite time where all your molecules will be converted
into C. So again, applying the law of mass action, we can write the ordinary differential equations,
but this time we're going to be representing it as a tuple of a coefficient
and two dictionaries, which specifies the stoichiometric coefficients of each
species on the reacting and product side for these three reactions, so we will start with
an exercise for you to complete the function constructing the symbolic representation of
this right-hand side function, so this is the vector which was known as y dot in the previous notebook,
and depending on how familiar you are with Python, this may or may not be a hard exercise,
you don't feel too bad if you get stuck, all right? Okay, so I'll give you the first part
of the solution, the first three question marks there. So if you look at the equations below,
this corresponds to the product, so we need to raise the concentration of the species to this
number r, and the concentration of the species is symbolically available in the C dictionary,
and then we need to have the right key, and that's given by the dictionary which we're looping over,
so that's rk, and the dictionary values are that stoichiometric coefficient,
so what's left now is
this part, which corresponds to this summation here. The details here are not that important,
I see some more blue sticking out coming up, so I'm going to give you the final part here,
so it's just the net multiplicity multiplied by this variable r which we computed just before this
loop, so the only thing that's important here is that this function in a general manner does what
we hard-coded in the last notebook, that right-hand side function, so now we can just give it
these kinds of dictionaries, and it will do the right thing,
if we actually run all the cells.
All right, so that looks familiar from the introduction text,
so in the next step we will do exact same steps as we did in the last notebook,
we will create a function, a Python function evaluating this expression using lamdify,
and you recognize the signature from the last notebook,
and we will run the integration with some parameters from the literature,
and what's interesting here is that the solver tells us that it has evaluated the Jacobian
a number of times, but it's kind of weird because we haven't given it to Jacobian, so it did just
what I said for the last notebook, it approximated the elements of the Jacobian matrix by doing finite
differences, so we'll see if we can provide this function manually or using sympy to give it an
analytic expression, so the next exercise is for you to do justice, to make a function evaluating
the analytic Jacobian.
Question?
Yeah, I can show you how to get the solution, so if you just delete the contents of this cell,
and uncomment that magic command, change exercise to load, and evaluate the cell,
you get the solution here, so it just says exercise in the comment.
All right, I think most people are getting there, so what we were looking for here was,
as you saw in Irene's introductory notebook, you can run the Jacobian method on a matrix
to get its Jacobian, and if you look at the documentation of the ODE int function,
you see that this D fun argument, it requires the exact same signature as the funk argument,
so again, it's just the y comma t plus k signature again,
and running the integration with this function given as D fun, we see that it did not need to
evaluate the Jacobian quite as many times as when it was not available. The difference here is quite
small, but that's made it because this is a very small problem, it's only three variables,
and even on this small problem, you can actually see a small impact on the total running time of
the integration, it's slightly faster giving the analytic Jacobian, but as the problem grows bigger,
this effect grows quite rapidly, so are there any questions at this point?
All right, so we would appreciate if you just write some feedback on the sticky notes,
and some negative feedback on the red one, and some positive on the blue one, was that it?
Yeah, all right, and then we'll take a five minute tour, ten minute break.
Okay, so we'll be back here five past. Okay, I think it's five after according to my clock,
so we could go ahead and get started. So I'm Jason, as Aaron mentioned before, and we're going to
move into the third section, the third hour. The title is the Hardaway Seaco Generation Custom
Printers and CSE, which stands for Common Sub-Expression Elimination. So Bjorn just showed you a high level
look, use of the Code Generation Facilities in Senpai, and now we're going to start to dig into
that and sort of expose how some of that works under the hood, how you can manipulate and change
how it behaves, and that'll lead into the final lesson too that Kenny will deliver
that'll show you how to further make use of these things. So if you open up the Hardaway Seaco Generation
Notebook, you can read through some of this intro here, but the main learning objectives that we're
going to tackle during this next hour, we're going to use a Code Printer class to convert a Senpai
expression into Compilable C code, so we're going to start looking specifically. Font size up?
Oh, every notebook you got to do it. Is that good? Thank you. The first one is, okay,
we're going to generate C code, and we're going to generate more complex C code. Secondly, we're
going to be working with arrays in C, so we're going to transform various Senpai expressions into
Array Compatible Code. We're going to learn how to subclass the different printers in Senpai to
have them behave differently. We've had a few questions already about, well, what if you wanted
to print something differently than what the defaults are, so we'll show you how to change that.
And then finally, we're going to introduce Common Subexpression Elimination, which is a
pre-optimization that you can potentially use to speed up your computations.
So those are the main things. We'll go ahead and import Senpai and turn on the pre-printing.
Which notebook this is? How do I get back to that? Yes, seven the hard way, and you can link to it
from the index right here. And the title is 707 the hard way. Got it? Anybody else?
Okay, so I've initialized some things. So Bjorn just introduced you all to these
chemical kinetic problems, and he gave a couple of textbook examples. He works on bigger problems,
harder things to solve, more complex sets of chemical reactions, and in particular,
he is going to, I'm going to use one of his sort of research level sets of ordinary differential
equations that models how water is exposed to ionizing radiation, and you might find this in
research about nuclear reactors and such. I don't know a bunch of details about that, so I'm going
not talk that, but if you want to ask, we'll get Bjorn to answer more detailed questions. But
the gist of it is that we still have a set of ordinary differential equations. In our case,
now we're going to have 14 states, and I'm already screwing things up.
Okay, back here. We have a function that just loads in these symbolic
right-hand side of the ordinary differential equations, the f of yt, and then the value states,
which is y of t. So as a first exercise, have a look at these. Investigate maybe what types they
are, what the expressions look like, you know, how complex are the mathematics. Spend a couple
of minutes doing that, and you can put up your blue sticky notes when you're done, and you're red
if you need help. In one other note, so I have a little bit of different solution, if you want to
see the solution, you can double click this cell, and it'll reveal an answer. May not be the only
answer, but an answer to that. But go ahead and give it a try first. Okay, what did you all learn?
What do we see? Anybody like to volunteer?
What kind of equations do we have?
Polinomials. So if I, nonlinear polynomials,
so if I just print this to the screen, it'll actually render, and I have a vector of expressions
that are multivariate polynomials in these 14 different state variables. So these equations
look a little nastier than before, being that it's more of a non-toy problem. But this is also
stored in a matrix, and then you can check the shape 14 by 1, and then our state vector
is also a 14 by 1 of the various symbols in there. Okay, so you've learned about the Jacobian
now in the two previous notebooks, so go ahead and compute the Jacobian of this
function of the states, and then take a look at that too and see what you get, and if it's what's
expected. And you could take down your blue sticky notes, and then put them back up when you
got it.
So it looks like about half of the people got, got something. Put your blue note up if you've
got it.
So what do people find here? So you can use the Jacobian method as we have before.
What is, what do we end up with?
You already answered. An awful matrix. That's what I like to hear. So we've got a,
now a large matrix, and if I look at the shape which Sartaj informed us of,
14 by 14, and I'm seeing one column right now, and I have a bunch of linear expressions in the
states, and I can, you can do this on your own screen too, scroll through and just sort of see,
we've got a bunch going on there. 196 entries and full of them are zero, it seems, but most of them
have, have some small expressions in the linear expressions in the states. So I think, you know,
hopefully these two examples here should give you some idea that when you're, have a non-toy problem,
this is a little unwieldy to handle by hand and try to type yourself. So this is
very, particularly very useful, and we can work with these and start to generate code from them
and, and then be able to evaluate them numerically. So let's talk a little bit about C code now. So
we're going to start printing C code, and I think we had some questions earlier. Well, how do I
include libraries? How do I have more than just printing a single line of code? And we're going
to sort of give some idea now of how you might make a compilable piece of C code that was generated
by the expressions that we just saw. So here, I have a template for a C program. We include
both the math library, which we're going to use a lot of the math functions, and that, and the
C code printer automatically assumes that we'll be using those. And I've also included the
standard input output library here too, so that we can print out some results to the screen.
If you recall, how many people are comfortable writing C programs? Raise your hand. Okay, good. So
at least half, maybe a little more. I'll give a little refresher here. And
in general, we need a, there's always has to be a main function, and the function looks like this.
There's a return type on the left. And then within the curly braces is what that function does.
So our main function, when we run this C, this program after it's compiled, it will execute
the lines in this function. The first thing that I do is I introduce some variables, okay,
and we're going to work with arrays sort of explicitly. And I'm going to avoid talking about
pointers and things, but just sort of talk about this in the context of an array variable.
Everything in C has a type, right? So these are double precision arrays. This is the name of the
variable. And then this value here tells me that it is a 14 entries long, 14 double precision values.
And then I assign some default values to the states, right? Just some example numbers here,
one through 14. With that command, everything has to end with a semicolon. And then here,
I also have to introduce two arrays to hold the results of our computations.
And these are essentially empty, of sorts, when I create them if I don't initialize them.
But when I evaluate the right hand side function, that's a 14 by one, so we want 14 entries.
And then we're also going to map the 14 by 14 Jacobian to a
1D array where all the rows are stacked of 196 entries, okay? So we're going to
just use two simple 1D arrays to store the results of that. We're then going to call a
function that we're going to create, and that's evaluating the ordinary differential equations.
It's going to take whatever the state values are, which we predefined. And then it's going to pass in
to these two empty arrays that we're going to populate inside the function with the values that
we compute. The bit down here is less interesting, but all we're doing is going to print the results
after we've done that computation. So I'm not going to go over that. It's just some basic printing code.
And then if we look up above, I have this function prototype sort of set up for evaluate ODE's.
Notice that it's going to return nothing and that it's going to take these three things.
First is the state value vector, our array. I have a constant declaration here because we're
not going to manipulate that. We're going to leave it constant inside the function,
and then it's going to take in these two double precision arrays that we will manipulate inside
the function. And our job is to do that manipulation. So we need to fill in right here how to populate
the values, given the state values, how to populate the values of the Jacobian and the right hand
side of the ODE's. So we're going to generate some code that's going to go in that bit there.
So Aaron showed you the C code function. There's a class that is operating behind the scenes any
time you call those kind of functions, and we call these printer classes. So we have a variety
of printer classes from printing to latex, from printing to the different codes that you saw,
pretty printing, et cetera. But we're going to load in explicitly the C99 code printer here.
And all you have to do is initialize it with no arguments if you don't want to provide any.
And then how do you use it? Well, all the printers have a method called do-print,
and if I pass a Sympi object, in our case this matrix, to that do-print method and print it,
it's going to try to print it. Interestingly enough here it says this is not supported in C,
this immutable dense matrix that we have, and it just gives us the sort of Sympi representation.
So why is that? This next bit here explains that some, or hopefully all.
In C we have to make assignments. So I want to, I can't just print necessarily the right hand side,
which are just these arbitrary expressions without assigning them to a variable. It doesn't
really mean anything useful unless you assign the results of those expressions to a variable.
So I already explained how you sort of instantiate an array, and then you can, I showed you how to
populate it like, double clicking is not a good idea on these, how to populate an array like so,
but you can also index into each item of the array and then pass in, in our case,
a double precision value or a computation that would produce one of those. So we need to ensure
that Sympi code printing prints this left hand side of the equal sign in addition to the right
hand side. So there's a, we introduced the matrix symbol, and the matrix symbol is,
is how we sort of provide what the left hand side of all those assignments are going to be.
So we're going to create a matrix symbol called RHS result, which is the variable name that I'm,
that I want, of the correct shape, which matches what our right hand side is going to be.
So I can create that matrix symbol, have a look at it, notice that it indexes into a 2D array
by default when you print it. But if I pass in that matrix symbol now to a keyword argument
to the do print method called assign to, it's going to do the right thing. And notice that
I get the first index and I assign that first expression to it. So I have the left hand and
right hand sign of this assignment in the printer. And we can scroll through and see all 14
of those array assignments. So this is a valid C code now that has these expressions assigned
to the entries of that array. Okay. So with that new knowledge, print out some
valid C code for the Jacobian matrix. You can take about five minutes for that.
And take down your sticky notes, which I think they're all, they're all down and
give us your blue one when you're, when you're ready, when you're done.
Okay. I think that's most everybody. So you can do the same thing that we did above.
We basically want to print the Jacobian now. And in differently, slightly differently,
we want a matrix symbol. I think I've got S Y M matrix symbol.
And I called that, I think Jack result. Maybe I should put this on a separate line so it all fits.
And we can pass in the shape one, one quick way to do that is
you can do that with Python to sort of expand that tuple. And then we'll call that Jack result.
So if I create that matrix symbol, and then pass in this,
and I have enough parentheses, and then I print, we will get a 196. And notice that it takes care
of this indexing already. The default is that matrices, 2D matrices get mapped to 1D arrays in the,
in the code generator, and we get all, all of those values there. So you can print
the Jacobian quite easily. Any questions at this point?
Okay, let's move on. So what if you want to change the behavior of the printer?
It's often useful change, maybe you want to change variable names, maybe you want to
have a, use a special function that you need, or use a library function, and you want to change how
the default printing happens in these, in these printers. All of the code printers have these
methods that start with underscore print. Now if I do underscore print underscore and I hit tab,
notice that I get all kinds of different things. All of these things are all the different objects
in SMPI that you might want to print. So in general, all the printers have a method defined on them
that tells the printer how to print that particular object. Here's some matrices, how to print the
how to print the infinity symbol, how to print an integer, right, how to print a list,
how to print matrix elements, matrix symbols, etc, etc. So if I sort of use those,
or look at those, let's just look at matrix symbols since we were using those.
And I double-question mark, I could look at the source code. And for some reason that
I printed them, I would just print the name. I guess it calls, is it called symbol?
Let's look at symbol because I'm going to, should have used the example I already had.
Some of these may or may not be. So if I open up print symbol, which is just a basic SMPI symbol,
we notice that that method takes the instance of the object and then some kind of expression
comes in. In this case, it would be a symbol object that would be coming in. And then inside
that function, you basically need to look at that symbol or expression that comes in
and do what you want to do and return ultimately a string that gives a representation of the
printing. So if I were to return like a latex printer, I might have dollar signs wrapped around
whatever my latex expression would be, et cetera. Question.
In this case, the C, I'm probably going to get this wrong, but the C89 is a subset of C99. So
when C99 came along, there's new things that were added to the language. So a lot of times we can
just use the C89 printer. So we have a hierarchy of classes that cascade. There's a code printer,
a C code printer, I'm sorry, a code printer that subclasses from a printer and then a C89
printer that subclasses from the code printer and a C99 that subclasses from the C89, probably.
This function is actually defined as C89. It's a subclass of C89.
So they may not be always as super clear, and maybe I should have picked one that was simpler,
but the gist is is that inside of that, you get the expression, you do something,
you look at that expression and then you return a string from there. So let's just play with that.
I think it'll be easier once we play with it a bit. Say I want to make a custom symbol printer.
So here I have my code printer, which is a new class name, and I'm going to subclass
the C99 code printer. And I just want to change how the symbol prints. And in this case, I will
define a new method, just like we saw, the print symbol method. And then anytime it finds a symbol,
it's going to do what I say here. And in this case, I am going to return
self dot underscore print, no matter what symbol you pass in, I'll always print
me. All right, so I just give it a string, a return of string. And it's in another key
point here is that I didn't just return a string, I passed it to this defined underscore print,
which is a very general print method that will dispatch whatever you pass it to the correct
printer. So if I were to put a symbol in there, it would call print symbol. If I would put a
list in there, it would call print list. In this case, I'm passing a string and it's going to call
print string ultimately. So it's good practice to always call self print instead of just sending
out the string, so that if you have a complex expression that it will recursively go through
and make sure it gets all those pieces. I don't know if that's probably losing everybody there,
but we can talk about it more. But in this case, I'm essentially just returning a string. So I'll
define that class, instantiate it, create a symbol. And now if I call the do print method of my class,
instead of printing the symbol I expected, it does, it just prints this string that I created.
So you can manipulate any object in Senpai and calls it to print in a different way.
Any question, how about questions right there? I guess is I probably lost people.
Everybody got that? Raise your hand if you did not understand that.
Nobody's going to admit. All right, fantastic. So now you get to try printing,
subclassing a printer, changing how it prints. In this case, in our ODE's we have Y0, Y1
through Y13. And we'd rather it say state values 0 through 13. We want to replace
those normal symbol prints with the array notation in this case. So there's two solutions here if
you want to check, but let's take 10 minutes and try to create a printer that will print
all the Y symbols like I have above there. And if you're fast, you can move on to this bonus exercise
and try to make another type of printer. All right, so let's take 10 minutes and do that.
Okay, I've got a solution here that I tried. I basically said if you find the symbol that gets
passed into print symbol in my state matrix, get its index value and then print this string,
state values, where I replace the curly braces with index. We can see if that works.
So I can create my printer
and then print
my printer, do print. In this case, we'll try the right hand
side of ODE's and we'll also need to assign it to our result. Close the parentheses.
And it looks like that works. So now I have
all of the symbols that were the Y's replaced with the indexed array values there automatically.
So now this would more properly work with my function that I showed earlier in the C template.
Anybody get the bonus exercise? A few people?
So in this case, I'll just briefly say, in this case, you had to do a POW object,
a POW or taking something to an exponent and that particular expression has two attributes,
a base and an exponent and you can replace those. Here was my solution. I basically said if the
expression is an integer, if the exponent is an integer and it's between zero and four,
just do an expanded multiplication and otherwise return the
printer, the power printer from the superclass. Yeah, so I could paste that in and run it
and then it prints as x times x instead of POW x, two. So you can have a look at that a little more.
Okay, so we've got a little less than 10 minutes. I'll probably have to fly through this last bit.
But another useful thing is something called common sub expression elimination. A lot of
compilers will do this for you if you set the proper optimization flags.
But the gist is if I have an expression, two expressions like A and B,
both of them have x times y in it and a computer doesn't really need to do x times y twice.
We could do x times y once and just replace the result of that in these expressions.
So this is called the sub expression and it's common to these other expressions.
But SIMPAI can do this pre compilation for you and it becomes useful in particular when
you're not using optimization settings and with different particular compilers and things and
also find that it increases the compile time and our CSE is reasonably fast even for large
expressions and you can save time sort of further down the road. So we have a function
called CSE and oh yeah. And it takes some expressions as its argument and then it spits out if you
look at the returns, the replacement which are a list of symbols and expressions, tuples,
and then the reduced or simplified expressions. So let's see what that looks like.
If I call CSE on the right hand side of the ODE's and then I have a little loop that just prints
those, we see that it finds all of these sub expressions in our ODE's.
Right, 87 common sub expressions that found that were common to those larger expressions.
And then the, it always returns a list of the simplified expressions because you can pass in
multiple so we're going to grab the first one and then you'll see how our longer
multivariate polynomials haven't been replaced with all these sub expressions here, all these x's that
were defined above. You can also pass in multiple items so I can get the common sub expressions
that are in both the right hand sides and the Jacobian. And then we see there's some odd,
I don't know, 200 and some, sorry, my scrolling is not that great, 200 some sub expressions
and then you can look at the simplified right hand side and then the Jacobian,
which looks a little, just a little simpler. All right, so we, this is particularly useful.
So the last exercise, and I've only, we've only got five minutes for that, sorry that it didn't
quite get a little, get through a little faster, but the goal would be is to create a
bunch of sub expressions for both that are common to the right hand side and the Jacobian
and then output the valid C sub expression, I mean simplified expressions for the right
hand side result and the Jacobian result. And I've given you some clues here.
One is that there's this assignment object that is useful. So if I print an assignment
object, I can print a left hand side and a right hand side by passing an symbol and a value in
this case. So that's, that's useful. And then here I show you how I can override the immutable dense
matrix method and when it gets our matrix, it calls CSE and then it sort of builds out the correct
printing for us. So that is a printer that can take a single matrix, print valid C code here
that we want for all the sub expressions and then an array of the, of the other expressions. Okay.
So the exercise has been looking to how you might be able to use print list so you can pass in two
expressions, both the right hand side and the Jacobian expression and generate all the sub
expressions and then populate the two arrays in C with the simplified expressions as I described
in the top of that. So you can write your answer there and four, four minutes. It might be a little
hard to get that one done. But you can also look at the solution and if you're really fast,
you can try to compile your C program and see if it, if it actually functions. Okay. So
yeah, should I, should I, should I just go through it since we're out of time? All right.
All right. Okay. So let me just copy my solution here. Good idea.
So what I did is I overrode, I guess I need to stay with the mic. Yeah. I overrode both
print list and print immutable dense matrix. So in the immutable dense matrix, I said, well, if
that matrix has a certain shape, print it differently. I knew that the Jacobian was a 2D
matrix and that the right hand side result was a column vector. And so I sort of just check here
which one it is and make sure that I assign the right variable to them.
And then I overrode the print list so I could pass in a list of Sympi matrices.
And in this case, I basically just see a C, the list of expressions right here.
And then collect all the sub expressions, make my assignments right here. So I assigned the
sub expression, the new variable to the expression. And then I also print the simplified matrices.
And I did a quick hack here to just replace all the Ys with state underscore vowels
also. So you can look at this after the fact. But if I run that, I get a name error.
And that is because I haven't defined state array map somewhere. Oh, I think that's in my
solution, my second solution to the above problem is where we'll find that.
Right. I've got a lot of code generated here. So right here, I have this, these two lines,
which I'll bring down. So you can examine, take a look at this in the break to try to
get a better idea of what I'm doing. Okay. So I have this map that maps the state
vowels. And then I print, and I get all of my sub expressions and notice that state
vowels has been replaced. I get all the sub expressions. And then I have the right hand side
result, the 14 elements of that, and then the hundred and site 196 elements of the Jacobian result.
There. So that is a quite a few lines of generated code that Senpai helps us
do fairly easily. And just for fun here, I'll show you the last bit. I have a little template
of the code that I had before. And you can use our new printer to generate a file.
So here I use my, take the T C template, I print, I use my new printer right there
to print out what I want. And I plug it in to the function in, in this spot right here,
where we need to fill in the code. And then I write it to a file, a C file.
And that's, that's what the C file now looks like, right? We see our prototype. We see all the
computations it has to do. And then this is different on every operating system, depending
on what compiler you have. But I'll run GCC here to compile that new file. Looks like it
and then run it. And it does my calculation, right? Right hand side, it calculates the values
and the Jacobian evaluates to. Okay? So that's, you'll have to dig through that last bit a little
more, probably to see some of the details. But the gist here is that we learned how to subclass
printers, right, and change how they print so that we can do custom things with them. And then
we've printed a fully functioning C program now that also use common sub-expression elimination to
give us maybe some faster compile times and potentially more efficient computation. Okay?
Okay, so let's take a 10 minute, I mean, I'm sorry, we'll take a five minute,
five minute break. So come back at six after. And if you have any questions come up and then
Kenny's going to lead us on the next round. So we just saw how to use code printers to
generate code that evaluates expressions. So we're going to take that one step further
with code generation. And so we'll go ahead and get started. This is the, right after the hard
way, this, or the harder way, this is the easy hard way. I'm not sure if that's accurate or not.
And everyone else finished on time, I'm not sure that I'm going to be able to finish on time.
I'm just going to go through it at a nice pace. And if we don't get to the end,
hopefully you can just take a look at the rest of it later. I hope it's written
clearly enough that you can work through it on your own. But if you run into issues, you can
go to the GitHub page for this tutorial and file an issue.
So the point of this tutorial, or this part of the tutorial, is to write a, we're going to see
how to write a scython function, just as kind of a demonstration of what scython is if you're not
familiar with it. And then we'll use Sympi's code gen function to take code printing one
step further. Not only does it print the C code that corresponds to an expression, but it'll
actually put it into a function and then put that into a file that you can then compile.
And then we're going to wrap that code using scython. So that's one use case for scython,
is to wrap existing C code. And then we will use Sympi's auto wrap function, which can do all this
for us rather than us doing it manually. And then last, if we can get to it, you can actually
now pass a custom code printer to auto wrap and some preprocessor statements to get,
be able to use a external C library with your auto wrap code. So we'll go ahead and get started.
These are just a few imports we'll be using throughout. So every, every Sympi thing is
going to be under the sym namespace. All right. So as a little quick introduction to what
scython is, scython is a compiler and a programming language. And it is used both, well, it's used
to generate extension modules for Python. So Python allows you to write C code and compile it into
a binary that you can import just like a normal Python module. And so the functions that are
declared or defined in that module can be imported and used just like normal Python functions.
And so the scython language is sort of a creole of Python and C, but it's primarily Python
with some keywords added that allow you to specify data types. So you can see this is very
Python looking, but it has these keywords like int, C def float that tell, that tell it what the type
of these things is. And what this does is it basically allows, it takes the dynamicism of
Python away. And so it knows now that this is an integer and this is a float. And so it doesn't
have to look up the types of every object before it can do things like add and multiply and everything.
So the compiler is going to take this scython source code and turn it into C code. And it's
kind of a specific flavor of C code. The imports includes Python.h, so it uses py objects and
things. And this is what allows it to be compiled into a Python extension module.
And then, so aside from writing scython for computations like this function up here,
you can use scython to wrap existing C code. And that's primarily what we'll be focusing on
for this part of the tutorial. But just as a quick example of the scython language and what it can
do, we'll go through a little demonstration of generating Fibonacci sequence numbers. So if
you're not familiar with what the Fibonacci sequence is, it's just a sequence that's initialized with
zero and one as the first two elements. And then every element after that is defined recursively
as the sum of the previous two elements. Okay. And so our objective is to write a function
that computes the nth Fibonacci number. And so this is a simple, pretty simple function. It's
just an iterative solution. And so it generates numbers. And if you run that and then run the
next cell, you can see that it generates a list of the numbers, so zero, one, one, two, three, five,
et cetera. So we can see how long it took to, or how long it takes to generate the 100th Fibonacci
sequence number. And it takes about 4.9 microseconds on this machine. So now let's go ahead and
implement the exact same thing with scython. And so since scython is basically Python with types,
it can be a little more complicated than that. But in some cases, it's pretty simple.
We just, we can pretty much literally copy and paste the code and then add in types
and see what it does. So there are a few, so anyway, that's the benefit is that it's so easy to do
that. But it comes with the cost of having to compile the code before you can run it and import
it. So there are a few ways to go about the compilation process. I'll use a couple of different
ones in this part of the tutorial. So the first one, since we're just writing scython code, there's
no really complicated stuff going on. You can use this scython magic command in Jupyter notebooks.
And to do that, you can load the scython extension. And this will take the contents of the cell,
compile it into the C code, the kind of extension module flavor of C, and then compile it and then
import its contents into your namespace. So you can use it just like a normal, normal Python cell.
So go ahead and run this. And you can see that it's really just exactly the same thing, but with
cdef float, or cdef, sorry, cdef double, a double, b declaring the types of all these things.
You can still use for i and range n, that kind of stuff. And so if you run this, it should compile.
And then you can time how long it takes to do that. And you can see 217 nanoseconds.
So it's several orders of magnitude faster than the pure Python implementation.
And all we had to do was add these types and then use a magic command to compile it.
Does anyone have any issues with getting it to run? It should be pretty easily cross platform, but
yeah, okay, good. It gets more complicated, so we'll see how it goes as we go.
So if you want to know a little bit more about writing Scython for computation,
there's an extra notebook I was going to have in this, but I just kind of cut it out because it was
just extra material. So that's contained in the notebooks folder of the repository.
And even better, there's a tutorial going on right now on Scython, and it goes way more in depth
into writing Scython code. And this is just a link to the GitHub page for that tutorial.
So you can check that out later if you're interested.
Okay, so we're going to switch gears a little bit and go back to the main point,
which is we want to generate ccode. And then we want to be able to compile it and then call
it from Python. The reason we want to be able to call it from Python is we're going to use
SyPy's ODE int to integrate the equations and plot the results and everything. So Sympy's code
gen function is what's going to take the code printing and then wrap that into a c function and
a c file and write them to the file system so we can use them and compile them into an extension
module. So this is a really quick overview or review of the system we're looking at. This is the
water radiolysis system that Jason talked about. So it's a system of ordinary differential equations.
We have these 14 state variables y0 through y13. That's the left-hand side. And on the right-hand
side, we have these functions of all the state variables and possibly time, although none of
these functions actually have time in them, but in general, ODE's can. So we're going to represent
these state variables in a state vector that's a matrix of 14 by one matrix. And the right-hand
side is going to be a 14 by one matrix of these expressions. So we call it RHS of ODE's, right-hand
side of ODE's. So we can start by importing the ODE's. This is exactly the same stuff that Jason
showed earlier. Then we just print the first row of the right-hand side matrix just to refresh on
what it looks like. So it's these polynomial expressions in the state variables. So now we can
use Sympy's code gen function, which is under the Sympy Utilities Code Gen namespace, to output C
source and header files that compute the right-hand side of the ODE's, numerically, given the current
value of all the state variables. So we'll import that, and I'll just go ahead and uncomment this
so you can see the doc string. So, yeah, you can see it takes a, what's this called, a named
expression. This is just a tuple or a list of tuples giving a name and an expression for each
thing you want to evaluate. It can take multiple expressions where we're just going to use one.
It takes a language. You can pass some other stuff to it. I don't think we use much else
right now. So we just have the one expression we're interested in computing. That's the right-hand
side of the ODE's. It's actually a matrix of expressions, but that's equivalent to just being
one expression or one kind of Sympy object, I guess. And what we want code gen to do is generate a
C function that takes the current values of the state variables and computes the derivatives.
And so I guess zooming in means you can't really see everything, but
so you have what code gen will return. A list of tuples, it's the C file name,
the C source code as a string, the header file name, and the header source as a string.
Okay, so if you run that, we can go ahead and print the C source code, and I'm going to zoom out a
bit. That's okay. All right, so the comments get a little messed up, but
so it prints this little banner comment up at the top. It prints out the include statement
so you're going to need, so it includes the header file that it generated and math.h,
so it can make use of pow and sign and things like that. And then it generates this function,
and the formatting is a little bit hard to tell what's going on, but this is the function
signature right here. So it's void, it doesn't return anything. It's called C ODE's because
that's the name that we gave right here. And then it takes the state variables, y0 through y13,
and it takes in the output as a pointer. So a lot of you said that you knew C,
so those of you who know C, this is not a super complicated use of pointers, but those of you
that don't, the only thing I'm going to mention is that in C it's idiomatic to
pass in, to pre-allocate some memory as an array, and then pass in the location of that memory
and the number of elements it holds instead of passing the array itself. And so when you do that,
it just takes the memory location, fills in the values because it knows the type of thing that
it's holding, and then you don't actually return anything, the memory is now modified,
and so the output of the function, it doesn't need to be returned. So that's all you need to
know about pointers for right now. And so you can see that it generated all the code. There's a
couple of things to note here, though. It takes in each of the state variables independently
or individually, which isn't ideal, and it also takes in the state variables in the wrong order.
So when we called the code gen function, we didn't tell it that we have this matrix of state
variables and what order they're in. It just took the right hand side of the ODEs, and so it
alphabetized the state variables. In that case, y1, y10, rather than y2, comes next. So that's not
ideal. It also gave us this kind of automatically generated name for the output, and so we'll deal
with that too. So starting with just the taking in the state variables individually, and this will
actually end up taking care of the ordering problem as well, we can use this matrix symbol thing we
saw before, so we can, instead of using the state's matrix of individual symbols, now we have a
matrix symbol where we can index into it the individual elements. So what we need to do then
is make use of this matrix symbol inside of our ODEs expressions, and Jason kind of glossed over,
I don't think he actually showed this how to do this in the previous notebook. He did it by
subclassing the printer. There's another way to do it. All we want to do is take a map of these
symbols, y0, y1, etc., and map those to these things right here, y00, y10, etc. So this corresponds
to the symbols that are in our state's variable. This corresponds to the 0th element of our y
matrix symbol. So we want to map those, and so you can create this state array map,
and it does this, so it's just a dictionary that maps y0 to y00, and then we need to replace the
occurrence of y0 in our right-hand side expressions with these, with these. So you can use this
extra place function, and it takes a map just like what we just generated, and so what you can see
is when we run that, the first row of our ODE matrix, it has now y00 squared instead of y0
squared. So the pretty printing actually kind of gets rid of what's actually happening, but now
this is an indexed variable, a matrix symbol that takes an index rather than a symbol y0.
So you can now use this RHS of ODE's end instead of RHS of ODE's to generate code, and you can see
what happens. So you can just take this little template and figure out what arguments it needs
to take in order to generate the code, and you can look up at the above example to see an idea,
and you add another solution. I just put some white space above the solution, so if you don't
want a sheet, you can avoid scrolling down. So go ahead and take a couple minutes to see if you
can generate the code and print it out and see what it looks like. Those people got it figured
out. So if you didn't, you can just scroll down and see the solution. We just pass in this RHS
of ODE's end instead of RHS of ODE's, and then see what it prints out. So now the signature of our
function is much shorter and quite a bit cleaner. Instead of having individual state variables,
we have this pointer to, well, pointer to double, which is representing an array of our state
variables, and that's what we want. We're going to pass in an array of our state variables rather
than the individual ones, which will be nicer when we talk about ODE end later.
So it still has this issue of kind of this ugly variable name. We can actually change this,
and I'll show you how to do that. So, yeah, so you can make another matrix symbol dy,
and this is going to represent the left-hand side of our equations, and so it's basically the same
thing. We just generate a matrix symbol that's the same shape as y, and what we're going to do now
is we're going to form an equality object that equates the left-hand side, this dy, with the
right-hand side, and you can use the indexed version of the right-hand side of the ODE's.
You form an equation, and then you can use that equation rather than just the right-hand side
expressions, and generate code and see what comes out of that. So take a couple minutes to
see what happens there. It looks like most people are getting there. So in this case,
you form the equality, you just put the left-hand side, and then the right-hand side is the second
argument of the EQ function, and then just pass this ODE EQ instead of the right-hand side,
and it will print out. In this case, we're just going to print the header. I think I forgot to
mention that, but this will just print out just the header source so you can just see the signature
rather than all the generated code. And now we get a nice clean function signature. It's called
C-E-O-D-E's. It takes a pointer, which represents an array of our state variables, and it takes a
pointer to an array that represents the values we want to fill in, which represent the derivatives
of our state variables. So I kind of already explained some of that. Okay, so now just so
we can actually compile this code and use it later on in the tutorial, I'm actually going to use the
two files keyword argument of CodeGen and just run the exact same thing. In this case, it doesn't
return the source code as a string. It just writes it to the file system. You can just write that,
and you should be able to see in your, if you navigate to the notebooks folder, you should be
able to see the C-O-D-E's, C and H files. Okay, so now we've got some actual source code written to
the file system. The question is, how do we get this into a Python extension module so we can
call it from ODE int? So now we're going to work on wrapping generated code with Scython.
So you basically write a script, a Scython script that does two things. It just reiterates the
function signature that's found in the C source code, and then it implements a Python interface to
that C function. And so we'll see an example of wrapping the C-O-D-E's function in order to be able
to call it from Python. The build system of Scython is able to take the wrapper source code
and the C library source code, compile and link them, and then generate an extension module that
has functions in it that you can call. This process is a little different depending on how exactly
you want to use things. In this case, we're going to use this Scython PYX import to do
everything for us. And in that case, it's going to write the contents of the cell to a file that
has the name that we specify with the PYX extension. That indicates that it's Scython source code.
It looks for a mod name, just the name of the thing we generated dot PYX BLD,
Pyrex build file, for instructions on how to build everything. So if we don't tell it like where the
files are that we want to link with our extension module, it won't know how to find them. So we
just basically need to tell it where that is. And then it will build everything into extension
module, and then it's going to import everything that we declare into our namespace so we can
just call it like normal Python functions. So it does a lot of stuff in the background, but it
does need to be coached on how to actually do the compilation process. But this file that we're
going to have to write is pretty similar to what you would put into a setup.py file. If you're
going to write Scython code that wraps C code, you would do a similar thing there, and I'll kind
of show you how that works. So in the end, this Scython Pyrex import works similarly to the Scython
magic, but everything's a little more complicated now because we need to tell it where the C library
is. So in either case, we need to tell setup tools slash Scython. The name of the extension
module we want to make the location of the Scython and the C source code, and the location of the
headers needed during compilation. And so this will include the header of the generated code that
we made, and NumPy headers. We're going to use NumPy within our Scython source, and that's one
of the cool things about Scython, actually, is it uses NumPy fairly well. And so we'll tell it
where NumPy's headers are, so we can use NumPy's C API. And so we're going to call our extension
module SciODEs. And so here we'll write our build file to tell it how to build everything. So I'll
just break this down. It's not super complicated. And again, it looks a lot like what you would put
into a setup.py file if you're packaging this stuff and you want to ship it to someone. So
you can import setup tools.extension. There's an extension class. That means extension module.
That's what we want to make. So we're going to tell it the module name. We're going to tell
the sources. And so the sources are just going to be the Scython source that we have,
and then the CODE's file that we had. So this is just telling it what are the things we need to
actually build to get this extension module to work. And then the include directories are going to
be the current directory because that's where we wrote the CODE's .h file and the NumPy's headers
you can get with this get include function. Okay, so when you run this cell, it will write the
contents. It's got this write file magic that will just write the contents to a file that's
called SciODEs.py rex build. And so you can look at that in the directory if you want.
So finally we can write our wrapper code. And the first thing we do is specify the
we just replicate the function signature from the header. So this is literally just copied and
pasted from the header file we generated. And this just says that this is where this
function is located. And then here's our wrapper. And this is just our Python interface to the C
function. And this is, by the way, this is all Scython source code basically, right? So
it's going to write this file SciODEs.pyx and then the SciODEs.pyx build file. We'll tell
it how to build everything. So the wrapper, we're going to make this wrapper conform to the ODE int
interface. And if you remember from, I think Jorn talked about it, it takes the array of the
state variables at the current time and a scalar time. And so this syntax looks a little ugly,
but I'll break it down. So we get the y is going to be a NumPy array. Its type is double.
So that matches with the C code. It takes an array double. And then it has, it's a one-dimensional
array. And it's called y. And then it takes a double t. Okay. And then, like I said, the pointer
thing is you just preallocate memory. And then you pass the C function where that memory is located
rather than passing in the thing itself. And so we preallocate our dy. This is going to hold our
result. And it's the same shape and everything as y. So we can declare it as an empty array
of the same size as y. And also you can give it the d type.
So now the final thing is we call the C function and then we return its result. So we call CODE's.
We, this is a little bit, this might be a little confusing, but basically we
grab a pointer to our array by getting the data attribute. So NumPy arrays all have the data
attribute that is basically a pointer to the raw memory of the array rather than all the array
itself. And then we just cast it. This is how you cast in Scython. Cast it to a double pointer
rather than by default. This is a pointer to character, HR. So we do that for both of these.
And I guess it's not super important exactly what's going on here. If you are not familiar with C,
you can treat this as a recipe and it should work. So if you run that, this should hopefully
build in the background and give you a Scy ODE's function that you can now call.
So your next exercise is just to use NumPy's random dot random, generate some random numbers
that you can put into your Scy ODE's function and see if it returns something reasonable.
Let's go ahead and try that. I think we'll try to move on. This is towards the end of this section
and then we'll start a new thing. So this won't cascade to problems later. If you run it, you
should now have this Scy ODE's function. So you can generate some random vowels. The shape of this
should just be 14 by nothing. So it's a one-dimensional array of size 14. And then you can call the
Scy ODE's function with the random values. And then you need to add in the time value. You can
use any time value because the equations don't actually make use of it. If you run that, you
should get some numbers. They also probably be different than mine. So now our goal was basically
to now be able to use this Scythonized function within ODE int. So now we have this function
that takes the interface that ODE int expects. And so we can use it like we've already seen
how to use ODE int. So we'll just go ahead and run it. I've added a couple of just utility functions
in our package that comes with the tutorial. There's a function that just generates some
initial conditions that are reasonable for the system and then just plots it in a kind of reasonable
way. So we can make some initial conditions and then just run ODE int, calling the Scy ODE's function,
give it the initial values and the time values we want, and then plot it. And we should get something
like that. Okay. So just to kind of recap what just happened, we took a symbolic expression
which is a matrix of ODE's. We use the CodeGen function to generate C code that evaluates the
right-hand side of those ODE's. We played around a little bit with matrix symbols and stuff like
that just to get the kind of function signature to look nice. But otherwise, it's just running CodeGen
to generate C code. And then we wrote a Scython wrapper around that C code. And so everything
that we just did is sort of just a recipe. You can use that for lots of different problems
that you might want to use it for with ODE int or really anything, any kind of numerical
solver or whatever. The Scython wrapper won't change too much, but yeah, question.
You would have to redo it for whatever system you want because it took
the symbolic expressions and generated C code. It's like hard-coded C code that evaluates
that specific system. So you'd rerun that. The Scython wrapper could basically be reused,
but you'd have to recompile with the new C code that you generate.
Yeah, is that it? Answer the question. Any other questions about what we just did?
Okay, cool. So now we'll see how to avoid doing all that and use AutoRap. So AutoRap,
as the name implies, automatically generates a Scython wrapper for us. And there are some
advantages and some disadvantages to this. But this is basically another kind of layer
of abstraction on top of everything. So we started out with just taking a SimPy expression,
generating a little snippet of code using the code printers. We added on top of that the code gen
stuff, which takes that little snippet, puts it into a function and a file. And now we're going to
add a little layer on top of that that takes the file, writes a Scython wrapper,
compiles it all, and gives you back a function that you can call. Okay, so we can take
an import AutoRap. It's under SimPy Utilities to AutoRap. You can look at the doc string here.
Its interface is sort of similar to code gen, but slightly different. In this case,
it just takes the one expression. It also has this extra back end keyword. Okay, in this case,
by default, it uses F2Py. So we're going to actually use the Scython back end instead.
So we'll have to specify that. The language argument is similar, but it can actually be
inferred if we're using the Scython back end where it's implied that we're going to be using C code
as the language. So we won't actually be using the language keyword argument. It takes a few other
arguments that we will hopefully get to see toward the end. But anyway, we can use AutoRap.
And what AutoRap is going to do is going to take, like I said, is going to take the expressions,
generate C code, generate Scython wrapper around that C code, compile it all into a Python extension
module, and then give us back a function, a binary function that is just a Python callable. We can
call it with arguments and it comes back with results. So it's pretty cool. It does everything we
just did for us. And so you can call it like this. We're going to give it the ODE EQ so that the
function interface is the same as the one we just used with CodeGen. Give it the back end
with Scython. And then it also takes a temporary directory. And I'm just going to put everything
in this AutoRap temp. I'm actually going to, I think I have some leftover stuff. So I'm just
going to get rid of my old ones. There. Okay. So if we run that cell, what is it doing?
Okay. Run that cell. It will do everything in the background for us. You can go,
actually, this is the next exercise. So now you can use this notebook tab, the main notebooks tab,
go into the directory we just created, which is called AutoRapTemp, and look at some of the files
that are in there and see if you can kind of map the files that it generated to what we just did
with CodeGen manually. So just take a couple minutes and kind of look through what it did.
You might also be interested in seeing how it did the Scython compilation stuff. It's slightly
different than how we did it with the Pyrex build file. So you can take a look at that too.
We got about 10 minutes. So I'm going to run through a couple of the extra things
rather than making them like full exercises so we can get to the last part, which is pretty neat too.
So if you go into the notebook cell, you can see this AutoRapTemp directory.
And it created a bunch of files. So the first one we can look at is the wrapper module. This is
the Scython wrapper that we wrote manually. It's a bit different than the one we wrote.
One thing you'll notice is that it creates two-dimensional arrays.
This is because we're passing in matrix symbols that is a 14 by 1 matrix symbol y
and a 14 by 1 matrix symbol dy. So that'll be sort of an issue when we want to use ODE in
because it expects to be able to pass in a one-dimensional array of state variables and
it expects to get back a one-dimensional array of derivatives. So we'll have to deal with that.
It also generated the wrapped code. This looks basically identical to the CodeGen
generated code except it uses an automatic name rather than the one we gave it when we used CodeGen.
It also generated the header file. And then it has this, I guess I don't really need to
look at this, but this is the Scythonized code. This is what Scython generates when it takes
the Scython source code and generates the extension module code. You can take a look at it if you
want. There's quite a lot of code there. And then the setup.py file, I mentioned this earlier.
It uses this setup tools extension or alternatively distutils extension class to generate
an extension module until Scython or the build tools where to find the source code that it
generated and the Scython source code. And it also uses the include numpy include or the numpy
header files. So it works pretty similarly to the manual like pyrex build file that we generated
or recreated. But this would be useful if you're actually going to package your Scython or your
wrapped Scython code into a module that you can install with Python setup.py install and things
like that. Okay. So I just explained a bit of that here. The next thing I'll do is I kind of
already pointed this out, but we can't pass in a one dimensional array of state variables. So I,
in this case, I had to make the shape 14 by one so we can get outputs. And then the output is
two dimensional array. So that's not ideal for using with OD int. So our solution for that
is going to be to just write a little Python wrapper around our auto wrapped C code.
And all it's going to do is just take, take in the one dimensional array of state variables,
add an extra dimension so we can pass it into our auto ODs function and then
squeeze the result so that it's one dimensional again when it comes out. So you can run that.
And then we can now put in a one dimensional vector and get out a one dimensional vector.
Also notice our wrapper, we included this time value or time variable in the signature
because auto wrap didn't add that. We could actually add that with auto wrap. I didn't show that,
but you can actually specify additional arguments if you want to. It's just a keyword argument to
the autogen function. And then finally, we can, you know, use auto wrap to generate a function
that evaluates the Jacobian like we have been doing. And I'll kind of skip this also. Got about
five, seven minutes. So all we're going to do is compute the Jacobian analytically, call auto wrap
with the Jacobian as our expression. Everything else is the same. And then write a wrapper around
it again because it's going to take in, it expects a two dimensional array input. So we're just going
to add an extra dimension to that. The Jacobian is actually a two dimensional entity, so you don't
need to change the output at all. And then we can just call it with some random values and make
sure that the shape is correct. It should be 14 by 14. Okay. And finally, we can use our auto
ODE's wrapper, the function we made, the wrap, the auto wrapped ODE evaluator, and the Jacobian
as the D fun. And then generate our plot. It should look similar to what we had before.
Okay. Any questions about this before I kind of just get to the last part and touch on
another cool thing about auto wrap? No? Okay. So the last thing we can do is,
this is actually a very recent feature of SimPy. Auto wrap accepts a custom
code gen object. And a code gen object is one layer on top of the code printer. So the code
gen object is responsible for taking the code printer that generates the snippets of expression
evaluation code and wrapping it into a function and a file. And so the code gen object actually
takes a custom printer. And we already saw we can implement some custom printing by subclassing
or, yeah, subclassing a printer and overriding some of its methods to do something. And so
we're going to use this to actually use a external library. So say we have some library,
in this case, I'm going to look at the Fast Approx library. This is just a headers library.
You can go on GitHub and download it. It's already downloaded into the package that we provided.
But it's just some header files that basically approximate things like power and exponentials.
I think it's got sinusoids to logarithms. And it just does that with limited precision with respect
to like math.h. And so I forgot to evaluate this. So this library provides a fast pal function.
And so the point of this is just to see how we can take an external library
and use its functions in place of what auto-rap does by default. So auto-rap, if you noticed,
in the generated code, any of these should be fine. Wrapped code. You see that it,
that's for the Jacobian. The other one. Wrapped code, zero. You see that it has this pal.
We're going to replace that with fast pal. And so in order to do that, we're going to have to
replace how the printer generates the string pal of the base to the exponent.
And we're also going to have to include the header file that specifies where the fast pal function.
So we can, I guess we can try to do this as an exercise. It's the last thing. So
you can take the last few minutes and try to generate a custom printer that will use fast
pal instead of pal and then instantiate it and then try to print out x cubed and see if it uses
fast pal and see if it works basically. And then after that, if you get it to work or you don't,
you can run it and see how it generates the code. So go ahead and spend the last couple minutes trying
to do that. Okay, never mind. We'll just go ahead and run it. Just so you can see how it works.
So it's not too bad. All you do is the expression that gets passed into the pal function has a base
and an exp attribute. And then we can replace instead of pal, we're just going to return
fast pal with these two things. And instantiate the custom printer, generate an expression x cubed.
You can see it just prints out as fast pal x three instead of pal x three.
Okay. And so now we're going to create a code gen. This corresponds basically directly to the
code printer C 99 code gen. We'll take a code printer and wrap what it generates into a function.
And then the last thing is we need to add the preprocessor statement that says we need to include
fast pal.h. If you're not super familiar with C, this is just equivalent to like include math.h
to give the pal function. Now we're going to use fast pal instead of pal. And so we append
the preprocessor statement to our code gen object. And then the last thing I promise is specifying
where this fast procs library is. And so we've put this into a sub folder of our sci-pi 2017
code gen package. So we can find that by just looking for the code gen vendor in it. And then
looking for the fast procs directory under that. So you can run that. And finally,
we use ODEQ. This is the equation that has our dy is equal to our right hand side of the ODE's.
We use passing our custom code gen. And then we just need to tell it that there's an additional
include directory. And that should run, I hope. And now you can look at the the code that it
generated. It should have fast pal instead of pal. And now you can run it. It turns out that the
limited precision of the fast pal function makes our integration blow up. So you can check that out
if you want. You can see that if we use our fast pal implementation, the normal math.h pal, you can
see that there's it's pretty different actually. So when you just evaluate it with some random values,
you get like pretty pretty big differences between the outputs. So that's why it blew up.
But anyway, the point was you can use an external library, subclass your printer,
and pass that into auto wrap. So you can use external libraries and auto wrapped code.
And it should all just work in quotes. All right, I think that's it for me.
So we can conclude, I guess. If you want to write some feedback, good feedback on the blue,
negative feedback on the red, and just pass them up to the top, we'd appreciate that.
And I don't know if we have anything else to say.
