Greetings, ladies and gentlemen. This is a video about why the programming language Haskell and functional programming languages in general is and are awesome, respectively.
This is a video for all people regardless of your level of programming knowledge. Noobs and pros all are welcome.
Okay, let me drop some jargon on you. Haskell is a purely functional, strongly typed, lazily executed, expressive, high-level programming language, although it's alright for low-level purposes as well.
In Haskell, there are no for loops, no while loops, no go-tos, and no variables. There are constants, which are like variables, only you can't change them.
That may sound like a lot of disadvantages, but you can do pretty much anything in Haskell that you can do in other programming languages, and by not having for loops, while loops, go-tos, and variables, that actually comes with some interesting advantages.
Okay, let's get in. Just hit the start button, type in command to get to the command line, and type in GHCI to get the Glasgow Haskell compiler interactive environment, assuming you have it installed.
So this is the thing in which you can load programs, scripts, and modules that you've written. You can also type Haskell code into it line by line, and it will interpret what you type in.
Alright, GHCI, when you answer the phone, you have to say Vandalay Industries, and Vandalay Industries is in the business of importing, among other things.
And now let's get down to business. Let's let greeting equal hello. That's a declaration. Now the name greeting and the string hello are synonymous.
And let's let Swedish equal interspers f. That's a little trick which works for translating most languages into Swedish.
Okay, let's try this out. Swedish greeting. And as expected, the result is the standard greeting in the Swedish language.
Applicable morning, noon, and night, in case you don't know any Swedish. Well, that's weird. We used a let statement to declare the name of a value and the name of a function.
That's not just a linguistic convenience. It's also a linguistic convenience. Values and functions are kind of the same thing in Haskell, at least more so than in procedural languages.
Okay, let's do some building up. Let person name equal satoshi. And let's see how that translates into Swedish. Swedish person name.
Svaft fafs fifi, which is like the third most common name in Sweden. And let's also let sentence equal greeting plus a space, plus a person name.
And that's lazy evaluation in action there. When we use a let statement, it doesn't evaluate it. It just checks to see if it has an error. But when we ask what something is like a Swedish sentence, then it evaluates the functions and parameters which it needs.
And the result, as expected, is ffffafs, Svaft fafs fifi, which is of course how you greet your friend Svaft fafs fifi in Swedish.
And when I said that that little trick works for converting most languages into Swedish, I mean most languages, including bytecode.
One more functional need is yell, which is to add an exclamation mark at the end of something. And now let's get more technical. Let the enthusiastic version of a function.
I'm going to put an f and an x on the left side and 1, 2, 3 f's and an x on the right side. And this is how that reads. To enthusiastically do something is to really, really do that thing.
And for the purposes of diversifying our adverbial vocabulary, we will define the word vary to mean the same thing as enthusiastically.
Now we're ready to make some complexity. We can yell a greeting. We can enthusiastically, enthusiastically yell a greeting.
We can yell a Swedish greeting. And we can enthusiastically yell a very Swedish greeting.
And we can very enthusiastically yell a very Swedish sentence. All these things work. Don't worry about those dots and dollar signs, they're just grammar. Who needs it?
Now be careful though. If you ever try to say something in a very, very Swedish way, whoa, we get like a bazillion f's. I terminated the program long before it had a chance to finish.
If you try to pronounce this word, you'll die because there are so many f's that your lungs soon get empty and when your lungs have zero air left in them and you try to keep going, they at some instant become enormous, much bigger than the rest of your body and you pretty much explode.
That's why you hear so many people dying in their attempts at the most dangerous task of learning Swedish.
I'll leave it as an exercise for the viewer to figure out why we get a bazillion f's and not six or some other number.
Actually, you have to provide a well-reasoned and clearly worded response in answer to that question in order to become a licensed doctor in Sweden.
There actually is a way to pronounce this word, but you need one of those special lung blowers that blows in from the bottom.
Here, I drew some figs to help explain what I'm talking about.
Here's a person, here's a lung blower, here's lungs and you make a hole here and you attach the hose like so and the air goes straight through.
This enables you to exhale continuously for as long as you want while maintaining your blood oxygenated and other conditions for life satisfied.
But this is on the cutting edge of biomedical technology right now.
I think they've fitted one lucky person with this setup and then he proceeded to pronounce a very very Swedish word.
But you know the way technology is, prices will be driven down and before long anyone who wants one of these will be able to afford to have it done.
So Haskell is great because functions are first-class citizens.
You can pass functions to functions and build up complexity in a very natural way.
This is in contrast to procedural languages where you can pass values through a function and then through another function which is not quite as good.
This affords an advantage to functional programming languages because functions can be very modular with a great number of simple functions and more complicated functions built of the smaller replaceable ones.
This makes it very easy to troubleshoot and modify programs.
Compared to procedural languages, it makes the program code less burdensome as programs get more advanced.
I've only scratched the surface of the mind-crogling powers of Haskell by passing functions to functions which take functions.
I didn't even mention the more advanced features like applicative funk doors and monad transformers.
To be truly literate in Haskell is to know how to use a tool which is useful yet difficult to wield.
That's why it has reputation for being only liked by professional mathematician and logician type people.
So let's do some logicizing, some philosophizing, some theologizing.
I've always wondered whether the ontological argument isn't just a whole bunch of linguistical mumbo-jumbo, so let's see what Haskell can do about that.
Now, the most famous version of the argument due to Anselm relies on this strange assumption that if something truly exists,
then that's better than it being false and not really existing.
And that compiles.
Well then, Haskell, what do you think of Anselm's assumption?
True. Simple as that.
Well, the people who made this thing really know what they're doing when they programmed it, so checkmate atheists.
So I hope you've noticed how expressive this programming language is.
It reads just like English. I've practically just been typing English into the Haskell interpreter this whole time.
And the compilers, the language itself, all these things are continually improving over time.
So in the near future, you'll be able to just walk up to your hyperspherical Haskell interpreter and announce to it,
I like toast in the morning.
And just like that, your unbihexium quantum toaster will be programmed to zap you up a fresh one every morning the moment your head leaves the pillow.
Alright, if you liked this video, then maybe I'll make some more educational videos about Haskell,
and I promise those ones won't feature an excessive overabundance of overextended jokes.
So, in conclusion, Haskell is great. Functional programming is great.
Learn Swedish responsibly, always with a spotter, and following proper safety precautions, and stay up to date on those.
Anyways, like and favorite this vid. Subscribe. Become Haskellite today.
